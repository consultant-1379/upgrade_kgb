#********************************************************************
# Ericsson Radio Systems AB                                     SCRIPT
# ********************************************************************
#
#
# (c) Ericsson Radio Systems AB 2014 - All rights reserved.
#
# The copyright to the computer program(s) herein is the property
# of Ericsson Radio Systems AB, Sweden. The programs may be used
# and/or copied only with the written permission from Ericsson Radio
# Systems AB or in accordance with the terms and conditions stipulated
# in the agreement/contract under which the program(s) have been
# supplied.
#
#
#######################################################################################
# START ORC_COMMON FUNTIONS ORC_COMMON FUNTIONS ORC_COMMON FUNTIONS ORC_COMMON FUNTIONS
#######################################################################################
# ********************************************************************
# Name      : orc_common_functions.lib
# Date      :
# Revision  : A
# Purpose   : Common, Orchestra-level, library functions
#
#
#
# ********************************************************************
#
#   variable Section
#
# ********************************************************************
declare GABTAB=/etc/gabtab
declare HOSTS=/etc/hosts
declare LLTHOSTS="/etc/llthosts"
declare MAIN_CF="/etc/VRTSvcs/conf/config/main.cf"
declare MC_START_DIR="/etc/opt/ericsson/nms_cif_smssr"
declare MC_START_LIST_SMSSR="${MC_START_DIR}/mc_start_list"
declare IPF_CONF="/etc/ipf/ipf.conf"
declare CLUSTER_INI="/ericsson/config/cluster.ini"
declare SSH_RES_FILE="/tmp/ssh_res.$$"
declare USE_CONFIG="/ericsson/config/ericsson_use_config"
declare INST_TYPE="/ericsson/config/inst_type"
declare SMRS_CONFIG=/ericsson/smrs/etc/smrs_config
declare ORIG_MC_START_LIST=/opt/ericsson/sck/lib/mc_start_list
declare CONFIG_INI="/ericsson/config/config.ini"
declare DHCPD_PID_FILE="/var/run/dhcpd.pid"
declare DHCPD_STARTUP_SCRIPT="/etc/rc2.d/S96dhcpd"
declare ERIC_JUMP_PKG="ERICjump"
declare FTH_SERVICE="asn_"
declare ORCLIB="/ericsson/orchestrator/lib/orc_common_functions.lib"
declare ORCWRAPPER="/ericsson/orchestrator/bin/orc_wrapper.bsh"
declare SUDO="/usr/local/bin/sudo"
declare ORCRAPPER="/orcha/.orc/orc_wrapper.bsh"
declare RAPPERDIR="/orcha/.orc"
declare SPINNER_SUBDIR=""
declare SPINNER_PID=0
declare SSH_OPTS="-o PubkeyAuthentication=yes \
-o KbdInteractiveAuthentication=no \
-o PasswordAuthentication=no \
-o ChallengeResponseAuthentication=no \
-o LogLevel=quiet \
-o StrictHostKeyChecking=no \
-o HostbasedAuthentication=no \
-o PreferredAuthentications=publickey"
declare SMTOOL_OPFILE="/tmp/orc_admin_mc_list"
declare SMTOOL_FTH_OPFILE="/tmp/orc_admin_mc_fth_list"
declare SMTOOL_FTH_NOTMIG="/tmp/orc_admin_mc_to_migrate"
declare ORCUSER="orcha"
#****************
# OSS-52060
#****************
PORTPING_PL=/ericsson/orchestrator/bin/port_ping.pl
SSH_PORT=22


# ********************************************************************
#
#   Command Section
#
# ********************************************************************
AWK=/usr/bin/awk
BASENAME=/usr/bin/basename
BOOTADM=/usr/sbin/bootadm
CAT=/usr/bin/cat
CD=/bin/cd
CHMOD=/usr/bin/chmod
CHOWN=/usr/bin/chown
CLEAR=/usr/bin/clear
CMP=/usr/bin/cmp
CP=/usr/bin/cp
CPIO=/usr/bin/cpio
CRONTAB=/usr/bin/crontab
CTXSRV=/opt/CTXSmf/sbin/ctxsrv
CUT=/usr/bin/cut
DATE=/usr/bin/date
DBATOOL=/ericsson/syb/util/dba_tools
DF=/usr/bin/df
DIFF=/usr/bin/diff
DIRNAME=/usr/bin/dirname
DOMAINNAME=/usr/bin/domainname
DMTOOL=/ericsson/dmr/bin/dmtool
DTCONFIG=/usr/dt/bin/dtconfig
ECHO=/usr/bin/echo
EGREP=/usr/bin/egrep
EJECT=/usr/bin/eject
ENV=/usr/bin/env
EXPECT=/usr/local/bin/expect
EXPORTFS=/usr/sbin/exportfs
EXPR=/usr/bin/expr
FIND=/usr/bin/find
FMTHARD=/usr/sbin/fmthard
FORMAT=/usr/sbin/format
FUSER=/usr/sbin/fuser
GETENT=/usr/bin/getent
GETTEXT=/usr/bin/gettext
GREP=/usr/bin/grep
GROUPADD=/usr/sbin/groupadd
GTAR=/usr/sfw/bin/gtar
GZCAT=/usr/bin/gzcat
HARES=/opt/VRTS/bin/hares
HASTART=/opt/VRTS/bin/hastart
HASTATUS=/opt/VRTS/bin/hastatus
HASTOP=/opt/VRTS/bin/hastop
HAGRP=/opt/VRTS/bin/hagrp
HASYS=/opt/VRTS/bin/hasys
HEAD=/usr/bin/head
HNAMECMD="/usr/bin/hostname"
ID=/usr/bin/id
IFCONFIG=/usr/sbin/ifconfig
INIT=/usr/sbin/init
IST_RUN=/opt/ericsson/sck/bin/ist_run
KILL=/bin/kill
LDAPCLIENT=/usr/sbin/ldapclient
LDAPLIST=/usr/bin/ldaplist
LDAPCACHEMGR=/usr/lib/ldap/ldap_cachemgr
LS=/usr/bin/ls
LN=/usr/bin/ln
LUACTIVATE=/usr/sbin/luactivate
LUCREATE=/usr/sbin/lucreate
LUCURR=/usr/sbin/lucurr
LUDELETE=/usr/sbin/ludelete
LUDESC=/usr/sbin/ludesc
LUMOUNT=/usr/sbin/lumount
LUUMOUNT=/usr/sbin/luumount
LUSTATUS=/usr/sbin/lustatus
LUUPGRADE=/usr/sbin/luupgrade
LUX86menu_PROPAGATE=/usr/lib/lu/lux86menu_propagate
METACLEAR=/usr/sbin/metaclear
METAINIT=/usr/sbin/metainit
METASTAT=/usr/sbin/metastat
MKDIR=/usr/bin/mkdir
MORE=/usr/bin/more
MOUNT=/usr/sbin/mount
MV=/usr/bin/mv
NAWK=/usr/bin/nawk
NETSTAT=/bin/netstat
PATCHRM=/usr/sbin/patchrm
PGREP=/usr/bin/pgrep
PING=/usr/sbin/ping
PKGADD=/usr/sbin/pkgadd
PKGINFO=/usr/bin/pkginfo
PRTCONF=/usr/sbin/prtconf
PRTDIAG=/usr/sbin/prtdiag
PRTVTOC=/usr/sbin/prtvtoc
PS=/bin/ps
PWADMIN=/opt/ericsson/bin/pwAdmin
RM=/usr/bin/rm
RMDIR=/usr/bin/rmdir
RCP=/usr/bin/rcp
RSH=/usr/bin/rsh
SCP=/usr/bin/scp
SCREEN=/usr/local/bin/screen
SED=/usr/bin/sed
SHOWREV=/bin/showrev
SLEEP=/usr/bin/sleep
SMTOOL=/opt/ericsson/nms_cif_sm/bin/smtool
SORT=/usr/bin/sort
SSH=/usr/bin/ssh
SSHKEYGEN=/usr/bin/ssh-keygen
SU=/usr/bin/su
SVCADM=/usr/sbin/svcadm
SVCCFG=/usr/sbin/svccfg
SVCS=/usr/bin/svcs
SWAP=/usr/sbin/swap
SYNC=/usr/sbin/sync
TAIL=/usr/bin/tail
TAR=/usr/bin/tar
TEE=/usr/bin/tee
TOUCH=/usr/bin/touch
TPUT=/usr/bin/tput
TR=/usr/xpg4/bin/tr
UADMIN=/usr/sbin/uadmin
UNAME=/usr/bin/uname
UNIQ=/bin/uniq
UMOUNT=/usr/sbin/umount
UNZIP=/usr/bin/unzip
USERADD=/usr/sbin/useradd
VOLD=/usr/sbin/vold
WC=/usr/bin/wc
XPG4GREP=/usr/xpg4/bin/grep
ZFS=/usr/sbin/zfs
ZPOOL=/usr/sbin/zpool
# NAS mount points
MASHOST="/var/opt/ericsson"
NAS_HOME="/home/nmsadm"
NAS1_MOUNT="/var/opt/ericsson"
ADMIN_OPT="/opt/ericsson/bin"

# ********************************************************************
#
#   Services Section
#
# ********************************************************************

ORC_SVCS_APPLICATION_CDE_PRINTINFO="svc:/application/cde-printinfo:default"
ORC_SVCS_APPLICATION_DATABASE_POSTGRESQL_81="svc:/application/database/postgresql:version_81"
ORC_SVCS_APPLICATION_DATABASE_POSTGRESQL_82="svc:/application/database/postgresql:version_82"
ORC_SVCS_APPLICATION_DATABASE_POSTGRESQL_82_64BIT="svc:/application/database/postgresql:version_82_64bit"
ORC_SVCS_APPLICATION_DATABASE_POSTGRESQL_83_32BIT="svc:/application/database/postgresql_83:default_32bit"
ORC_SVCS_APPLICATION_DATABASE_POSTGRESQL_83_64BIT="svc:/application/database/postgresql_83:default_64bit"
ORC_SVCS_APPLICATION_FONT_FC_CACHE="svc:/application/font/fc-cache:default"
ORC_SVCS_APPLICATION_FONT_STFSLOADER="svc:/application/font/stfsloader:default"
ORC_SVCS_APPLICATION_GDM2_LOGIN="svc:/application/gdm2-login:default"
ORC_SVCS_APPLICATION_GRAPHICAL_LOGIN_CDE_LOGIN="svc:/application/graphical-login/cde-login:default"
ORC_SVCS_APPLICATION_MANAGEMENT_DMI="svc:/application/management/dmi:default"
ORC_SVCS_APPLICATION_MANAGEMENT_OCM="svc:/application/management/ocm:default"
ORC_SVCS_APPLICATION_MANAGEMENT_SEAPORT="svc:/application/management/seaport:default"
ORC_SVCS_APPLICATION_MANAGEMENT_SMA="svc:/application/management/sma:default"
ORC_SVCS_APPLICATION_MANAGEMENT_SNMPDX="svc:/application/management/snmpdx:default"
ORC_SVCS_APPLICATION_MANAGEMENT_WBEM="svc:/application/management/wbem:default"
ORC_SVCS_APPLICATION_MANAGEMENT_WEBMIN="svc:/application/management/webmin:default"
ORC_SVCS_APPLICATION_OPENGL_OGL_SELECT="svc:/application/opengl/ogl-select:default"
ORC_SVCS_APPLICATION_PRINT_IPP_LISTENER="svc:/application/print/ipp-listener:default"
ORC_SVCS_APPLICATION_PRINT_PPD_CACHE_UPDATE="svc:/application/print/ppd-cache-update:default"
ORC_SVCS_APPLICATION_PRINT_RFC1179="svc:/application/print/rfc1179:default"
ORC_SVCS_APPLICATION_PRINT_SERVER="svc:/application/print/server:default"
ORC_SVCS_APPLICATION_STOSREG="svc:/application/stosreg:default"
ORC_SVCS_APPLICATION_SUN_DS_SERVER="svc:/application/sun/ds:ds--var-ds"
ORC_SVCS_APPLICATION_VIRTUALBOX_VBOXSERVICE="svc:/application/virtualbox/vboxservice:default"
ORC_SVCS_APPLICATION_X11_XFS="svc:/application/x11/xfs:default"
ORC_SVCS_APPLICATION_X11_XVNC_INETD="svc:/application/x11/xvnc-inetd:default"
ORC_SVCS_ERICSSON_COMINF_PORTD="svc:/ericsson/cominf/ericportd:default"
ORC_SVCS_ERICSSON_SMRS_ALSERVICES="svc:/ericsson/smrs/smrs_AIServices:default"
ORC_SVCS_ERICSSON_SMRS_SLAVE_ALSERVICES="svc:/ericsson/smrs/smrs_slave_AIServices:default"
ORC_SVCS_ERICSSON_GLASSFISH="svc:/ericsson/eric_3pp/glassfish:default"
ORC_SVCS_MILESTONE_DEVICES="svc:/milestone/devices:default"
ORC_SVCS_MILESTONE_MULTI_USER="svc:/milestone/multi-user:default"
ORC_SVCS_MILESTONE_MULTI_USER_SERVER="svc:/milestone/multi-user-server:default"
ORC_SVCS_MILESTONE_NAME_SERVICES="svc:/milestone/name-services:default"
ORC_SVCS_MILESTONE_NETWORK="svc:/milestone/network:default"
ORC_SVCS_MILESTONE_PATCHING="svc:/milestone/patching:default"
ORC_SVCS_MILESTONE_SINGLE_USER="svc:/milestone/single-user:default"
ORC_SVCS_MILESTONE_SYSCONFIG="svc:/milestone/sysconfig:default"
ORC_SVCS_NETWORK_APOCD_UDP="svc:/network/apocd/udp:default"
ORC_SVCS_NETWORK_CDE_SPC="svc:/network/cde-spc:default"
ORC_SVCS_NETWORK_CHARGEN="svc:/network/chargen:dgram"
ORC_SVCS_NETWORK_CHARGEN="svc:/network/chargen:stream"
ORC_SVCS_NETWORK_COMSAT="svc:/network/comsat:default"
ORC_SVCS_NETWORK_DAYTIME="svc:/network/daytime:dgram"
ORC_SVCS_NETWORK_DAYTIME="svc:/network/daytime:stream"
ORC_SVCS_NETWORK_DHCP_SERVER="svc:/network/dhcp-server:default"
ORC_SVCS_NETWORK_DISCARD="svc:/network/discard:dgram"
ORC_SVCS_NETWORK_DISCARD="svc:/network/discard:stream"
ORC_SVCS_NETWORK_DNS_CLIENT="svc:/network/dns/client:default"
ORC_SVCS_NETWORK_DNS_SERVER="svc:/network/dns/server:default"
ORC_SVCS_NETWORK_ECHO_DGRAM="svc:/network/echo:dgram"
ORC_SVCS_NETWORK_ECHO_STREAM="svc:/network/echo:stream"
ORC_SVCS_NETWORK_FINGER="svc:/network/finger:default"
ORC_SVCS_NETWORK_FTP="svc:/network/ftp:default"
ORC_SVCS_NETWORK_HTTP="svc:/network/http:apache2"
ORC_SVCS_NETWORK_ILOMCONFIG_INTERCONNECT="svc:/network/ilomconfig-interconnect:default"
ORC_SVCS_NETWORK_INETD="svc:/network/inetd:default"
ORC_SVCS_NETWORK_INETD_UPGRADE="svc:/network/inetd-upgrade:default"
ORC_SVCS_NETWORK_INITIAL="svc:/network/initial:default"
ORC_SVCS_NETWORK_IPFILTER="svc:/network/ipfilter:default"
ORC_SVCS_NETWORK_IPMIEVD="svc:/network/ipmievd:default"
ORC_SVCS_NETWORK_IPSEC_IKE="svc:/network/ipsec/ike:default"
ORC_SVCS_NETWORK_IPSEC_IPSECALGS="svc:/network/ipsec/ipsecalgs:default"
ORC_SVCS_NETWORK_IPSEC_MANUAL_KEY="svc:/network/ipsec/manual-key:default"
ORC_SVCS_NETWORK_IPSEC_POLICY="svc:/network/ipsec/policy:default"
ORC_SVCS_NETWORK_IPV4_FORWARDING="svc:/network/ipv4-forwarding:default"
ORC_SVCS_NETWORK_IPV6_FORWARDING="svc:/network/ipv6-forwarding:default"
ORC_SVCS_NETWORK_ISCSI_INITIATOR="svc:/network/iscsi/initiator:default"
ORC_SVCS_NETWORK_LDAP_CLIENT="svc:/network/ldap/client:default"
ORC_SVCS_NETWORK_EKLOGIN="svc:/network/login:eklogin"
ORC_SVCS_NETWORK_KLOGIN="svc:/network/login:klogin"
ORC_SVCS_NETWORK_RLOGIN="svc:/network/login:rlogin"
ORC_SVCS_NETWORK_LOOPBACK="svc:/network/loopback:default"
ORC_SVCS_NETWORK_NFS_CBD="svc:/network/nfs/cbd:default"
ORC_SVCS_NETWORK_NFS_CLIENT="svc:/network/nfs/client:default"
ORC_SVCS_NETWORK_NFS_MAPID="svc:/network/nfs/mapid:default"
ORC_SVCS_NETWORK_NFS_NLOCKMGR="svc:/network/nfs/nlockmgr:default"
ORC_SVCS_NETWORK_NFS_RQUOTA="svc:/network/nfs/rquota:default"
ORC_SVCS_NETWORK_NFS_SERVER="svc:/network/nfs/server:default"
ORC_SVCS_NETWORK_NFS_STATUS="svc:/network/nfs/status:default"
ORC_SVCS_NETWORK_NIS_CLIENT="svc:/network/nis/client:default"
ORC_SVCS_NETWORK_NIS_PASSWD="svc:/network/nis/passwd:default"
ORC_SVCS_NETWORK_NIS_SERVER="svc:/network/nis/server:default"
ORC_SVCS_NETWORK_NIS_UPDATE="svc:/network/nis/update:default"
ORC_SVCS_NETWORK_NIS_XFR="svc:/network/nis/xfr:default"
ORC_SVCS_NETWORK_NTP4="svc:/network/ntp4:default"
ORC_SVCS_NETWORK_NTP="svc:/network/ntp:default"
ORC_SVCS_NETWORK_PFIL="svc:/network/pfil:default"
ORC_SVCS_NETWORK_PHYSICAL="svc:/network/physical:default"
ORC_SVCS_NETWORK_RARP="svc:/network/rarp:default"
ORC_SVCS_NETWORK_REXEC="svc:/network/rexec:default"
ORC_SVCS_NETWORK_ROUTING_BGP="svc:/network/routing/bgp:quagga"
ORC_SVCS_NETWORK_ROUTING_LEGACY_ROUTING_IP4="svc:/network/routing/legacy-routing:ipv4"
ORC_SVCS_NETWORK_ROUTING_LEGACY_ROUTING_IP6="svc:/network/routing/legacy-routing:ipv6"
ORC_SVCS_NETWORK_ROUTING_NDP="svc:/network/routing/ndp:default"
ORC_SVCS_NETWORK_ROUTING_OSPF6="svc:/network/routing/ospf6:quagga"
ORC_SVCS_NETWORK_ROUTING_OSPF="svc:/network/routing/ospf:quagga"
ORC_SVCS_NETWORK_ROUTING_RDISC="svc:/network/routing/rdisc:default"
ORC_SVCS_NETWORK_ROUTING_RIP="svc:/network/routing/rip:quagga"
ORC_SVCS_NETWORK_ROUTING_RIPNG="svc:/network/routing/ripng:default"
ORC_SVCS_NETWORK_ROUTING_RIPNG_QUAGGA="svc:/network/routing/ripng:quagga"
ORC_SVCS_NETWORK_ROUTING_ROUTE="svc:/network/routing/route:default"
ORC_SVCS_NETWORK_ROUTING_SETUP="svc:/network/routing-setup:default"
ORC_SVCS_NETWORK_ROUTING_ZEBRA="svc:/network/routing/zebra:quagga"
ORC_SVCS_NETWORK_RPC_100235_1_RPC_TICOTSORD="svc:/network/rpc-100235_1/rpc_ticotsord:default"
ORC_SVCS_NETWORK_RPC_BIND="svc:/network/rpc/bind:default"
ORC_SVCS_NETWORK_RPC_BOOTPARAMS="svc:/network/rpc/bootparams:default"
ORC_SVCS_NETWORK_RPC_CDE_CALENDAR_MANAGER="svc:/network/rpc/cde-calendar-manager:default"
ORC_SVCS_NETWORK_RPC_CDE_TTDBSERVER="svc:/network/rpc/cde-ttdbserver:tcp"
ORC_SVCS_NETWORK_RPC_GSS="svc:/network/rpc/gss:default"
ORC_SVCS_NETWORK_RPC_KEYSERV="svc:/network/rpc/keyserv:default"
ORC_SVCS_NETWORK_RPC_MDCOMM="svc:/network/rpc/mdcomm:default"
ORC_SVCS_NETWORK_RPC_META="svc:/network/rpc/meta:default"
ORC_SVCS_NETWORK_RPC_METAMED="svc:/network/rpc/metamed:default"
ORC_SVCS_NETWORK_RPC_METAMH="svc:/network/rpc/metamh:default"
ORC_SVCS_NETWORK_RPC_NISPLUS="svc:/network/rpc/nisplus:default"
ORC_SVCS_NETWORK_RPC_OCFSERV="svc:/network/rpc/ocfserv:default"
ORC_SVCS_NETWORK_RPC_REX="svc:/network/rpc/rex:default"
ORC_SVCS_NETWORK_RPC_RSTAT="svc:/network/rpc/rstat:default"
ORC_SVCS_NETWORK_RPC_RUSERS="svc:/network/rpc/rusers:default"
ORC_SVCS_NETWORK_RPC_SMSERVER="svc:/network/rpc/smserver:default"
ORC_SVCS_NETWORK_RPC_SPRAY="svc:/network/rpc/spray:default"
ORC_SVCS_NETWORK_RPC_WALL="svc:/network/rpc/wall:default"
ORC_SVCS_NETWORK_SAMBA="svc:/network/samba:default"
ORC_SVCS_NETWORK_SECURITY_KADMIN="svc:/network/security/kadmin:default"
ORC_SVCS_NETWORK_SECURITY_KRB5KDC="svc:/network/security/krb5kdc:default"
ORC_SVCS_NETWORK_SECURITY_KRB5_PROP="svc:/network/security/krb5_prop:default"
ORC_SVCS_NETWORK_SECURITY_KTKT_WARN="svc:/network/security/ktkt_warn:default"
ORC_SVCS_NETWORK_SENDMAIL_CLIENT="svc:/network/sendmail-client:default"
ORC_SVCS_NETWORK_SERVICE="svc:/network/service:default"
ORC_SVCS_NETWORK_SHARES_GROUP="svc:/network/shares/group:default"
ORC_SVCS_NETWORK_DSHELL="svc:/network/shell:default"
ORC_SVCS_NETWORK_KSHELL="svc:/network/shell:kshell"
ORC_SVCS_NETWORK_SLP="svc:/network/slp:default"
ORC_SVCS_NETWORK_SMTP="svc:/network/smtp:sendmail"
ORC_SVCS_NETWORK_SSH="svc:/network/ssh:default"
ORC_SVCS_NETWORK_STDISCOVER="svc:/network/stdiscover:default"
ORC_SVCS_NETWORK_STLISTEN="svc:/network/stlisten:default"
ORC_SVCS_NETWORK_SWAT="svc:/network/swat:default"
ORC_SVCS_NETWORK_TALK="svc:/network/talk:default"
ORC_SVCS_NETWORK_TELNET="svc:/network/telnet:default"
ORC_SVCS_NETWORK_TIME_DGRAM="svc:/network/time:dgram"
ORC_SVCS_NETWORK_TIME_STREAM="svc:/network/time:stream"
ORC_SVCS_NETWORK_TNAME="svc:/network/tname:default"
ORC_SVCS_NETWORK_TNCTL="svc:/network/tnctl:default"
ORC_SVCS_NETWORK_TND="svc:/network/tnd:default"
ORC_SVCS_NETWORK_UUCP="svc:/network/uucp:default"
ORC_SVCS_NETWORK_WINBIND="svc:/network/winbind:default"
ORC_SVCS_NETWORK_WINS="svc:/network/wins:default"
ORC_SVCS_PLATFORM_I86PC_EEPROM="svc:/platform/i86pc/eeprom:default"
ORC_SVCS_PLATFORM_I86PC_KDMCONFIG="svc:/platform/i86pc/kdmconfig:default"
ORC_SVCS_SYSTEM_AUDITD="svc:/system/auditd:default"
ORC_SVCS_SYSTEM_BOOT_ARCHIVE="svc:/system/boot-archive:default"
ORC_SVCS_SYSTEM_BOOT_ARCHIVE_UPDATE="svc:/system/boot-archive-update:default"
ORC_SVCS_SYSTEM_BOOT_CONFIG="svc:/system/boot-config:default"
ORC_SVCS_SYSTEM_CONSADM="svc:/system/consadm:default"
ORC_SVCS_SYSTEM_CONSOLE_LOGIN="svc:/system/console-login:default"
ORC_SVCS_SYSTEM_COREADM="svc:/system/coreadm:default"
ORC_SVCS_SYSTEM_CRON="svc:/system/cron:default"
ORC_SVCS_SYSTEM_CRYPTOSVC="svc:/system/cryptosvc:default"
ORC_SVCS_SYSTEM_DEVICE_FC_FABRIC="svc:/system/device/fc-fabric:default"
ORC_SVCS_SYSTEM_DEVICE_LOCAL="svc:/system/device/local:default"
ORC_SVCS_SYSTEM_DEVICE_MPXIO_UPGRADE="svc:/system/device/mpxio-upgrade:default"
ORC_SVCS_SYSTEM_DUMPADM="svc:/system/dumpadm:default"
ORC_SVCS_SYSTEM_FILESYSTEM_AUTOFS="svc:/system/filesystem/autofs:default"
ORC_SVCS_SYSTEM_FILESYSTEM_LOCAL="svc:/system/filesystem/local:default"
ORC_SVCS_SYSTEM_FILESYSTEM_MINIMAL="svc:/system/filesystem/minimal:default"
ORC_SVCS_SYSTEM_FILESYSTEM_ROOT="svc:/system/filesystem/root:default"
ORC_SVCS_SYSTEM_FILESYSTEM_USR="svc:/system/filesystem/usr:default"
ORC_SVCS_SYSTEM_FILESYSTEM_VOLFS="svc:/system/filesystem/volfs:default"
ORC_SVCS_SYSTEM_FMD="svc:/system/fmd:default"
ORC_SVCS_SYSTEM_HOTPLUG="svc:/system/hotplug:default"
ORC_SVCS_SYSTEM_IDENTITY_DOMAIN="svc:/system/identity:domain"
ORC_SVCS_SYSTEM_IDENTITY_NODE="svc:/system/identity:node"
ORC_SVCS_SYSTEM_INSTALLUPDATES="svc:/system/installupdates:default"
ORC_SVCS_SYSTEM_ISCSITGT="svc:/system/iscsitgt:default"
ORC_SVCS_SYSTEM_KEYMAP="svc:/system/keymap:default"
ORC_SVCS_SYSTEM_LABELD="svc:/system/labeld:default"
ORC_SVCS_SYSTEM_MANIFEST_IMPORT="svc:/system/manifest-import:default"
ORC_SVCS_SYSTEM_MDMONITOR="svc:/system/mdmonitor:default"
ORC_SVCS_SYSTEM_METAINIT="svc:/system/metainit:default"
ORC_SVCS_SYSTEM_NAME_SERVICE_CACHE="svc:/system/name-service-cache:default"
ORC_SVCS_SYSTEM_PATCHCHK="svc:/system/patchchk:default"
ORC_SVCS_SYSTEM_PATCH_FINISH="svc:/system/patch-finish:delete"
ORC_SVCS_SYSTEM_PICL="svc:/system/picl:default"
ORC_SVCS_SYSTEM_PKGSERV="svc:/system/pkgserv:default"
ORC_SVCS_SYSTEM_POOLS="svc:/system/pools:default"
ORC_SVCS_SYSTEM_POOLS_DYNAMIC="svc:/system/pools/dynamic:default"
ORC_SVCS_SYSTEM_POSTRUN="svc:/system/postrun:default"
ORC_SVCS_SYSTEM_POWER="svc:/system/power:default"
ORC_SVCS_SYSTEM_PREPATCH="svc:/system/prepatch:default"
ORC_SVCS_SYSTEM_RCAP="svc:/system/rcap:default"
ORC_SVCS_SYSTEM_RESOURCE_MGMT="svc:/system/resource-mgmt:default"
ORC_SVCS_SYSTEM_RMTMPFILES="svc:/system/rmtmpfiles:default"
ORC_SVCS_SYSTEM_SAC="svc:/system/sac:default"
ORC_SVCS_SYSTEM_SAR="svc:/system/sar:default"
ORC_SVCS_SYSTEM_SCHEDULER="svc:/system/scheduler:default"
ORC_SVCS_SYSTEM_SVC_RESTARTER="svc:/system/svc/restarter:default"
ORC_SVCS_SYSTEM_SYSEVENT="svc:/system/sysevent:default"
ORC_SVCS_SYSTEM_SYSIDTOOL_NET="svc:/system/sysidtool:net"
ORC_SVCS_SYSTEM_SYSIDTOOL_SYSTEM="svc:/system/sysidtool:system"
ORC_SVCS_SYSTEM_SYSTEM_LOG="svc:/system/system-log:default"
ORC_SVCS_SYSTEM_TSOL_ZONES="svc:/system/tsol-zones:default"
ORC_SVCS_SYSTEM_UTMP="svc:/system/utmp:default"
ORC_SVCS_SYSTEM_WEBCONSOLE="svc:/system/webconsole:console"
ORC_SVCS_SYSTEM_ZONES="svc:/system/zones:default"
ORC_SVCS_SYSTEM_VCS="svc:/system/vcs:default"

# ***********************************************************************
#
#         Configuration Section and Global Variables
#
# ***********************************************************************

#********************
# Name of this script
#********************
SCRIPTNAME=`${BASENAME} ${0}`

#*****************************************************
# Timestamp used to identify files created by this run
#*****************************************************
TIMESTAMP=`${DATE} '+%Y-%m-%d-%H-%M-%S'`

#*************************************
# Default user, to execute this script, remembering that sudo may be used for the 
# Orchestrator user
#*************************************
readonly DEF_USER=root

#*************************************
# Get the architecture of the platform
#*************************************
readonly ARCH=`${UNAME} -p`


#*************************************
#Set the default architecture variable
#*************************************
readonly DEF_ARCH=i386

#*************************************
# Set the TEMP directory to /tmp
#*************************************
readonly TEMP="/tmp"

#**************************************
# Lockfile to stop script running twice
#**************************************
readonly LUG_LOCKFILE="/tmp/.eric_ossrc_upgrade_tasks.lock"

#**********************************************************
# If an interrupt is trapped, then this flag is set true
# and the script will abort when it completes current stage
#**********************************************************
INTERRUPT_FLAG="FALSE"

ORC_INTERNAL_ERROR="ORCHESTRATOR_INTERNAL_ERROR"

#**********************************************************
# Definition of literals section
#**********************************************************
ORC_PING_TIMEOUT=3

# ***********************************************************************
#
#                             Functions
#
# ***********************************************************************

### Function: orc_check_fs_exists
#
# Checks the specified fs exists, but does not check that it really is a mount point, as it
# is used with say both /export/GRAN/<slave> and /GRAN/<slave> where the later is mounted on the 
# former
#
# Arguments     : FS to check
#
# Return Values : 0 - Exists
#                 1 - Does not exist
#
#******************************
function orc_check_fs_exists
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    $DF -k $1  > /dev/null 2>&1
    RC=$?
    if [ $RC -eq 0 ]
    then
        # Also check you can do listing for when have mounts within mounts
        $LS $1 > /dev/null 2>&1
        RC=$?
        [ "${DEBUG}" ] && orc_log_script "Listing of $1 returns $RC"
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: return ($RC)"
    return $RC
}
    
### Function: orc_check_interrupt ###
#
# Check if an interrupt has been received and exit if so
#
# Arguments     : $1 - String denoting when proc was called
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#**********************************************************
function orc_check_interrupt()
{
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  if [ "${INTERRUPT_FLAG}" == "TRUE" ]
  then
      orc_log_script "WARNING: Interrupt Trapped.....Exiting"
      [ "${DEBUG}" ] && orc_log_script "End Function return(1)"
      return 1
  fi

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0
}

### Function: orc_create_logfile ###
#
# Create the log file
#
# Arguments     : None
#
# Return Values : None
#
#*******************************
function orc_create_logfile()
{
  local res=0
  local -i retVal
  #***********************************************
  # Replace multiple slashes with a singular slash
  #***********************************************
  LOGFILE=`${ECHO} ${LOGFILE} | ${SED} 's/\/[\/]*/\//g' |
                                ${SED} 's/[\/]*$//g'`

  #***********************************
  # Strip log directory from file name
  #***********************************
  LOGDIR=`${DIRNAME} ${LOGFILE}`

  #*******************
  # Check for log file
  #*******************
  if [ -f ${LOGFILE} ]
  then
      orc_log_script "Log file ${LOGFILE} already exists - it will be appended to"
  else
      #**************************************************
      # Check the log file is a fully qualified path name
      #**************************************************
      if [ ! `${ECHO} ${LOGFILE} | ${EGREP} '^[/]'` ]
      then
          ${ECHO} "${LOGFILE} is not a full pathname"
          exit 1
      fi

      #***************************************
      # Check that the path to the file exists
      #***************************************
      if [ ! -d "${LOGDIR}" ]
      then
          #********************************
          # Create the path to the log file
          #********************************
          ${MKDIR} -p ${LOGDIR} > /dev/null 2>&1
		  retVal=$?
          if [ ${retVal} -ne 0 ]
          then
              ${ECHO} "ERROR: Unable to create log directory ${LOGDIR}"
              exit 1
          fi
      fi

      orc_log_script "Log file is ${LOGFILE}"
  fi

  #******************************
  # Log a start of script message
  #******************************
  orc_log_script "Start of ${SCRIPTNAME}"
  res=$?
  return ${res}
}


### Function: orc_log_tag ###
#
# Logs Orchestrator Messages
#
# Arguments     : $1 - Message
#
# Return Values : none
#
#*****************************
function orc_log_tag()
{
  #******************
  # Timestamp message
  #******************
  if [[ -n "${1}" ]]
  then
      # L_ORCA_LOG_MESS="${1}"
      L_ORCA_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: ${1}"
  else
      L_ORCA_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: Error in Script ${0}"
  fi

  #********************************
  # Ouput to log file and/or screen
  #********************************
  if [ "${LOGFILE}" ]
  then
      ${ECHO} "${L_ORCA_LOG_MESS}" | ${TEE} -a ${LOGFILE}
  else
      ${ECHO} "${L_ORCA_LOG_MESS}"
  fi
  return 0
}

### Function: orc_log_script ###
#
# Logs Messages
#
# Arguments     : $1 - Message
#
# Return Values : none
#
#*****************************
function orc_log_script()
{
  #******************
  # Timestamp message
  #******************
  if [[ -n "${1}" ]]
  then
      if [ "${DEBUG}" ]
      then
        L_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: (${FUNCNAME[1]}) ${1}"
      else
        L_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: ${1}"
      fi
  else
      L_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: Error in Script ${0}"
  fi

  #********************************
  # Ouput to log file and/or screen
  #********************************
  if [ "${LOGFILE}" ]
  then
      ${ECHO} "${L_LOG_MESS}" | ${TEE} -a ${LOGFILE}
  else
      ${ECHO} "${L_LOG_MESS}"
  fi
  return 0
}


### Function: orc_cleanup_and_exit ###
#
# Clean Up and Exit
#
# Arguments     : $1 Exit code
#                 0 - Normal exit
#                 1 - Error condition
#                 4 - Do not remove pre-existing lockfile
# Arguments     : $2 ORC TAG
#                 $3 Success tag (optional)
#
# Return Values : none
#
#********************************************************
function orc_cleanup_and_exit()
{  

  local ERROR_STRING=""
  local MODULE_NAME=""
  
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
  
  orc_log_script "Cleaning up and exiting"

  OPTIND=1
  while getopts ":s:h:" ARG
  do
    case ${ARG} in
	  h)    MODULE_NAME="${OPTARG}"
			;;
      s)    ERROR_STRING="${OPTARG}"
            ;;
      *)    ${ECHO} "ERROR: Invalid option ${OPTARG} supplied, ignoring option and continue to cleanup and exit"
            ;;
    esac
  done
  
  shift $((OPTIND-1))
  
  L_EXIT_CODE=${1}
  L_ORC_TAG=${2}
  local L_MSG=""
  if [ $# -eq 3 ]
  then
      L_MSG=$3
  fi

  #*****************
  # Remove the traps
  #*****************
  trap - INT HUP QUIT TSTP
  trap - EXIT


  #*****************************************************
  # Delete the lockfile if it wasn't created by this run
  #*****************************************************
  if [ "${L_EXIT_CODE}" -ne 4 ]
  then
      ${RM} -f ${LUG_LOCKFILE} > /dev/null 2>&1
  fi

  
  #*****************************************************
  # Create a Hidden file Status File
  #*****************************************************
  
  if [ -n  "${MODULE_NAME}" ]
  then
     $TOUCH "$STATUS_DIR/.${MODULE_NAME}_status_file"
	 if [ "${L_EXIT_CODE}" -ne 0 ]
	 then
		echo "NOK" > "$STATUS_DIR/.${MODULE_NAME}_status_file"
	 else
		echo "OK" > "$STATUS_DIR/.${MODULE_NAME}_status_file"
        if [ "${MODULE_NAME}" = "admin_post_remake_cluster_tasks" ]
        then
            if orc_check_existence ${SUMFILE_WRITTEN_STATUS_FILE}
            then
                $RM  ${SUMFILE_WRITTEN_STATUS_FILE}
            fi
        fi
        
	 fi
  fi
  

  if [ "${L_EXIT_CODE}" -ne 0 ]
  then

      orc_log_script "---------------------------------------------------------------------------------------"
  
        #**********************
        # Summary of Errors
        #*********************

        if [ -n "$ERROR_STRING" ]
        then    
            OLD_IFS=$IFS
            IFS=$':'
            orc_log_script "----< Error Summary"
            for record in $ERROR_STRING
            do
                orc_header_3 "${record}"
            done
            orc_log_script "----< End Error Summary"
            IFS=$OLD_IFS
        fi 

		#########################################
		# Only present in "verification" modules
		#########################################
		if [ -n "$ERROR_STRING" ]
		then    
			orc_log_script "----< ${SCRIPTNAME} Completed with Errors"
		else
			orc_log_script "----< ${SCRIPTNAME} Exited with Error"
		fi
		
	 	orc_log_script "----< CHECK THE LOG ${LOGFILE}"
	   	orc_log_script "---------------------------------------------------------------------------------------"
        if [ "${LOGFILE}" ]
        then
		    orc_log_tag "${L_ORC_TAG}: ${SCRIPTNAME} module failed with error ${L_EXIT_CODE}.  Refer to logfile ${LOGFILE} for details"
        else
		    orc_log_tag "${L_ORC_TAG}: ${SCRIPTNAME} module failed with error ${L_EXIT_CODE}.  Refer to previous log messages for details"
        fi
      
  else
    if [ "${LOGFILE}" ]
    then
        orc_log_tag "${L_ORC_TAG}: ${SCRIPTNAME} module completed successfully. ${L_MSG} Logfile location: ${LOGFILE}"
    else
        orc_log_tag "${L_ORC_TAG}: ${SCRIPTNAME} module completed successfully. ${L_MSG}"
    fi

  fi
  
  [ "${DEBUG}" ] && orc_log_script "End Function: exit(${L_EXIT_CODE})"

  exit ${L_EXIT_CODE}
}



### Function: orc_create_lockfile ###
#
# Create the lockfile
#
# Arguments     : None
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#********************************
function orc_create_lockfile()
{
  [ "${DEBUG}" ] && orc_log_script "Start Function"
  
  orc_log_script "Creating lockfile"
  local -i retVal

  #*******************
  # Check for lockfile
  #*******************
  if [ -f ${LUG_LOCKFILE} ]
  then
      orc_log_script "ERROR: ${SCRIPTNAME} seems to be already running due to the existence of lockfile"
      orc_log_script "ERROR: ${LUG_LOCKFILE}"
      orc_log_script "ERROR: If this is not the case then manually remove the lockfile."
      [ "${DEBUG}" ] && orc_log_script "End Function: return(4)"
      return 4
  else
      #********************
      # Create the lockfile
      #********************
      ${TOUCH} ${LUG_LOCKFILE}
	  retVal=$?
      if [ ${retVal} -ne 0 ]
      then
          orc_log_script "ERROR: Unable to create lockfile ${LUG_LOCKFILE}"
          [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
          return 1
      fi
  fi

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0
}

### Function: orc_check_id ###
#
# Check that the effective id of the user is correct
# This function is required to handle the Orchestrator User and sudo
#
# Arguments     : User ID name
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#***************************************************
function orc_check_id()
{
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
  orc_log_script "Checking user id"

  L_CHECK_ID=`${ID}  | ${AWK} -F\( '{print $2}' | ${AWK} -F\) '{print $1}'`
  if [ "${L_CHECK_ID}" != "${1}" ]
  then
      orc_log_script "ERROR: You MUST be ${1} to execute script ${0}"
      [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
      return 1
  fi

  [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"

  return 0
}


### Function: orc_check_arch ###
#
# Check that the effective id of the user is correct
# This function is required to handle the Orchestrator User and sudo
#
# Arguments     : Architecture must be i386
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#***************************************************
function orc_check_arch()
{
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -ne "1" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  orc_log_script "Checking the machine architecture (${1})"
  
  L_CHECK_ARCH=`${UNAME} -p`
  
  if [ "${L_CHECK_ARCH}" != "${1}" ]
  then
      orc_log_script "ERROR: The machine architecture MUST be ${1} to execute script ${0}"
      
	  [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
      
	  return 1
  fi

  [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"

  return 0
  
}

### Function: orc_display_parameters ###
#
#   Display the liveupgrade parameters
#
# Arguments     : $1 - screen or log_and_screen
#
# Return Values : 0 - Complete
#
#*************************************
function orc_display_parameters()
{
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  #********************************************************
  # Set the command which is used to display the parameters
  #********************************************************
  if [ ${1} == "screen" ]
  then
      ${CLEAR}
      ${ECHO}
      L_COMMAND=${ECHO}
  else
      L_COMMAND="log_script"
  fi

  [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"

  return 0
}

######################################################################
#
#  Orchestrator Common Test Functions with built-in support for lists
#  where appropriate.
#
######################################################################
#    test FILE operators:
#
#       test -a FILE          True if file exists.
#       test -b FILE          True if file is block special.
#       test -c FILE          True if file is character special.
#       test -d FILE          True if file is a directory.
#       test -e FILE          True if file exists.
#       test -f FILE          True if file exists and is a regular file.
#       test -g FILE          True if file is set-group-id.
#       test -h FILE          True if file is a symbolic link.
#       test -L FILE          True if file is a symbolic link.
#       test -k FILE          True if file has its `sticky' bit set.
#       test -p FILE          True if file is a named pipe.
#       test -r FILE          True if file is readable by you.
#       test -s FILE          True if file exists and is not empty.
#       test -S FILE          True if file is a socket.
#       test -t FD            True if FD is opened on a terminal.
#       test -u FILE          True if the file is set-user-id.
#       test -w FILE          True if the file is writable by you.
#       test -x FILE          True if the file is executable by you.
#       test -O FILE          True if the file is effectively owned by you.
#       test -G FILE          True if the file is effectively owned by your group.
#       test -N FILE          True if the file has been modified since it was last read.
#		test FILE1 -nt FILE2  True if file1 is newer than file2 (according to modification date).
#		test FILE1 -ot FILE2  True if file1 is older than file2.
#		test FILE1 -ef FILE2  True if file1 is a hard link to file2.
#
#    test STRING operators:
#
#        test -z STRING           True if string is empty.
#        test -n STRING           True if string is not empty.
#        test STRING1 = STRING2   True if the strings are equal.
#        test STRING1 != STRING2  True if the strings are not equal.
#        test STRING1 < STRING2   True if STRING1 sorts before STRING2 lexicographically.
#        test STRING1 > STRING2   True if STRING1 sorts after STRING2 lexicographically.
#
#    test OTHER operators:
#
#        test -o OPTION           True if the shell option OPTION is enabled.
#        test ! EXPR              True if expr is false.
#        test EXPR1 -a EXPR2      True if both expr1 AND expr2 are true.
#        test EXPR1 -o EXPR2      True if either expr1 OR expr2 is true.
#
#        arg1 OP arg2             Arithmetic tests.  
#		                          OP is one of -eq, -ne, -lt, -le, -gt, or -ge.
#                                 Arithmetic binary operators return true if ARG1 is equal, not-equal,
#                                 less-than, less-than-or-equal, greater-than, or greater-than-or-equal than ARG2.
#
######################################################################
######################################################################

######################################################################
#@ DESCRIPTION: check the existence of a file or directory, if an item in the list does not exist return error
#@ USAGE: orc_check_existence() LIST
#@ RETURNS 0 if all items in the list exist, else 1
######################################################################
function orc_check_existence 
{

  # several operators test the state of a file. A filee??s existence can be tested with -e (or the nonstandard -a).
  # The type of file can be checked with -f for a regular file, -d for a directory, and -h or -L for a symbolic
  # link. Other operators test for special types of files and for which permission bits are set.

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  local L_RES=0

  for checkitem in $*
  do
  
    # if an item in the list does not exist return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing (${checkitem}) for existence"

    test -e $checkitem || L_RES=1 

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"

  return $L_RES
}

######################################################################
#@ DESCRIPTION: check a LIST of files, if an item in the list is not a link or does not exist, return error
#@ USAGE: orc_check_for_link() LIST
#@ RETURNS 0 if all items in the list are links, else 1
######################################################################
function orc_check_for_link 
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  local L_RES=0

  for checkitem in $*
  do
  
    # if an item in the list is not a link return non-zero

    orc_log_script "Testing (${checkitem}) for link status"

    if ( ! test -L $checkitem )
	then
		L_RES=1
		orc_log_script "${checkitem} is not a link"
		[ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
		return $L_RES
	else
		orc_log_script "${checkitem} is a valid link"
	fi
	
  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"

  return $L_RES
}

######################################################################
#@ DESCRIPTION: check block existence, if an item in the list does not exist return error
#@ USAGE: orc_check_blockfile_existence() LIST
#@ RETURNS 0 if all items in the list exist, else 1
######################################################################
function orc_check_blockfile_existence 
{

# Block devices (also called block special files) usually behave a lot like ordinary files: 
# they are an array of bytes, and the value that is read at a given location is the value that was last written there. 
# Data from block device can be cached in memory and read back from cache; writes can be buffered. 
# Block devices are normally seekable (i.e. there is a notion of position inside the file which the application can change). 
# The name e?oblock devicee?O comes from the fact that the corresponding hardware typically reads and writes a whole block at a time (e.g. a sector on a hard disk).

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi
  
  for checkitem in $*
  do
  
    # if an item in the list does not exist return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing block file (${checkitem}) for existence"

    if ( ! test -b $checkitem )
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
        return 1 
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}

######################################################################
#@ DESCRIPTION: check character existence, if an item in the list does not exist return error
#@ USAGE: orc_check_chrfile_existence() LIST
#@ RETURNS 0 if all items in the list exist, else 1
######################################################################
function orc_check_chrfile_existence 
{

# Character devices (also called character special files) behave like pipes, serial ports, etc. 
# Writing or reading to them is an immediate action. What the kernel driver does with the data is its own business. 
# Writing a byte to a character device might cause it to be displayed on screen, output on a serial port, converted into a sound
# Reading a byte from a device might cause the serial port to wait for input, might return a random byte (/dev/urandom),
# The name e?ocharacter devicee?O comes from the fact that each character is handled individually.

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi
  
  for checkitem in $*
  do  

    # if an item in the list does not exist return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing character file (${checkitem}) for existence"

    if ( ! test -c $checkitem )
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}

######################################################################
#@ DESCRIPTION: check regular file existence, if an item in the list does not exist return error
#@ USAGE: orc_check_regfile_existence() LIST
#@ RETURNS 0 if all items in the list exist, else 1
######################################################################
function orc_check_regfile_existence 
{

# When a program reads or writes data from a file, the requests go to a kernel driver. 
# If the file is a regular file, the data is handled by a filesystem driver and it is 
# typically stored in zones on a disk or other storage media, and the data that is read 
# from a file is what was previously written in that place.

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for checkitem in $*
  do
  
    # if an item in the list does not exist return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing regular file (${checkitem}) for existence"

    if ( ! test -f $checkitem )
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}

######################################################################
#@ DESCRIPTION: check regular file existence, if an item in the list does not exist return error
#@ USAGE: orc_check_directory_existence() LIST
#@ RETURNS 0 if all items in the list exist, else 1
######################################################################
function orc_check_directory_existence 
{

# When a program reads or writes data from a file, the requests go to a kernel driver. 
# If the file is a regular file, the data is handled by a filesystem driver and it is 
# typically stored in zones on a disk or other storage media, and the data that is read 
# from a file is what was previously written in that place.

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for checkitem in $*
  do
  
    # if an item in the list does not exist return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing directory (${checkitem}) for existence"

    if ( ! test -d $checkitem )
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}


######################################################################
#@ DESCRIPTION: check if a LIST of services are valid
#@ USAGE: orc_check_is_service_valid() LIST
#@ RETURNS 0 if all services in the list are valid svcs services, else 1
######################################################################
function orc_check_is_service_valid 
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for checkitem in $*
  do
  
    # if a service in the checklist is valid return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing if service (${checkitem}) is valid"

    if ( ! $SVCS -x $checkitem > /dev/null 2>&1 )
    then
        orc_log_script "Service (${checkitem}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	else
        orc_log_script "Service (${checkitem}) is valid"
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all services in the list are enabled return zero
}

######################################################################
#@ DESCRIPTION: check if a LIST of services are "enabled"
#@ USAGE: orc_check_is_service_enabled() LIST
#@ RETURNS 0 if all services in the list are enabled, else 1
######################################################################
function orc_check_is_service_enabled 
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for checkitem in $*
  do

    if ( ! orc_check_is_service_valid $checkitem )
	then
        orc_log_script "Service (${checkitem}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	fi
  
    # if a service in the checklist is not enabled return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing if service (${checkitem}) is enabled"

    if ( ! $SVCS -x $checkitem | $AWK '/State:/ {if ($2 == "enabled") {exit 0} else {exit 1}}' )
    then
        orc_log_script "Service (${checkitem}) is not enabled"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	else
        orc_log_script "Service (${checkitem}) is enabled"
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all services in the list are enabled return zero
}


######################################################################
#@ DESCRIPTION: check if a LIST of services are "disabled"
#@ USAGE: orc_check_is_service_disabled() LIST
#@ RETURNS 0 if all services in the list are enabled, else 1
######################################################################
function orc_check_is_service_disabled 
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for checkitem in $*
  do
  
    if ( ! orc_check_is_service_valid $checkitem )
	then
        orc_log_script "Service (${checkitem}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	fi

    # if a service in the checklist is disabled return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing if service (${checkitem}) is disabled"

    if ( ! $SVCS -x $checkitem | $AWK '/State:/ {if ($2 == "disabled") {exit 0} else {exit 1}}' )
    then
        orc_log_script "Service (${checkitem}) is not disabled"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	else
        orc_log_script "Service (${checkitem}) is disabled"
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all services in the list are disabled return zero
}

######################################################################
#@ DESCRIPTION: check if a LIST of services are "disabled"
#@ USAGE: orc_check_is_service_disabled() LIST
#@ RETURNS 0 if all services in the list are enabled, else 1
######################################################################
function orc_check_is_service_online 
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
  
  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for checkitem in $*
  do
  
    if ( ! orc_check_is_service_valid $checkitem )
	then
        orc_log_script "Service (${checkitem}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	fi
  
    # if a service in the checklist is not enabled return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing if service (${checkitem}) is online"

    if ( ! $SVCS -x $checkitem | $AWK '/State:/ {if ($2 == "online") {exit 0} else {exit 1}}' )
    then
        orc_log_script "Service (${checkitem}) is not online"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
	else
        orc_log_script "Service (${checkitem}) is online"
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all services in the list are online return zero
}

######################################################################
#@ DESCRIPTION: check if a LIST of services are in "maintenance"
#@ USAGE: orc_check_is_service_in_maintenance() LIST
#@ RETURNS 0 if all services in the list are in "maintenance", else 1
######################################################################
function orc_check_is_service_in_maintenance 
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi
  
  for checkitem in $*
  do
  
    if ( ! orc_check_is_service_valid $checkitem )
	then
        orc_log_script "Service (${checkitem}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1 
	fi
    
    # if a service in the checklist is not in maintenance return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing if service (${checkitem}) is in maintenance"

    if ( ! $SVCS -x $checkitem | $AWK '/State:/ {if ($2 == "maintenance") {exit 0} else {exit 1}}' )
    then
        orc_log_script "Service (${checkitem}) is not in maintenance"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
	else
        orc_log_script "Service (${checkitem}) is in maintenance"
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all services in the list are in "maintenance" return zero
}

######################################################################
#@ DESCRIPTION: Touch new file, if the file already exists or cannot be created return error 
#@ USAGE: orc_touch_file_existence() LIST
#@ RETURNS 0 if all items in the list exist, else 1
######################################################################
function orc_touch_file
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for touchitem in $*
  do

    # if an item in the list exists return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing regular file (${touchitem}) for existence"

    if ( test -f $touchitem )
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    [ "${DEBUG}" ] && orc_log_script "Touching regular file (${touchitem})"

    if ( ${TOUCH} ${touchitem} )
    then
        [ "${DEBUG}" ] && orc_log_script "Touched regular file (${touchitem})"
    else
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}


######################################################################
#@ DESCRIPTION: Remove file(s), if the file does not already exist return error
#@ USAGE: orc_remove_file() LIST
#@ RETURNS 0 if all items in the list are removed, else 1
######################################################################
function orc_remove_file
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  for removeitem in $*
  do

    # if an item in the list exists return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing regular file (${removeitem}) for existence"

    if ( ! test -f $removeitem )
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    [ "${DEBUG}" ] && orc_log_script "Removing regular file (${removeitem})"

    if ( ${RM} ${removeitem} )
    then
        [ "${DEBUG}" ] && orc_log_script "Removed regular file (${removeitem})"
    else
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}

######################################################################
#@ DESCRIPTION: Check input is an integer, if not return error
#@ USAGE: orc_check_integer() LIST
#@ RETURNS 0 if all items in the list are integers, else 1
######################################################################
function orc_check_integer
{

  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -eq "0" ]
  then
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi
 
  for integeritem in $*
  do

    # if an item in the list is not an integer return non-zero

    [ "${DEBUG}" ] && orc_log_script "Testing (${integeritem}) "

    RE='^[0-9]+$'
    if ! [[ ${integeritem} =~ ${RE} ]] ; then
        [ "${DEBUG}" ] && orc_log_script "Testing integer (${integeritem}) failed"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

  done

  [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

  return 0 # if all items in the list exist return zero
}



######################################################################
#@ DESCRIPTION: check if a server is acting as an LDAP client
#@ USAGE: orc_check_is_ldap_client ()
#@ RETURNS 0 if conditions for LDAP client are satisfied, otherwise return 1
######################################################################
function orc_check_is_ldap_client  
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    $SVCS \*ldap/client\* >/dev/null 2>&1 
    LDAP_CLIENT_SVC=$?

    $LDAPCACHEMGR -g >/dev/null 2>&1;
    LDAP_CACHE_PRES=$?
    $LDAPCLIENT list >/dev/null 2>&1;
    LDAP_CLIENT_LIST_PRES=$?
		 
	if [ $LDAP_CLIENT_SVC -eq 0 ]  && [ $LDAP_CACHE_PRES -eq 0 ] && [ $LDAP_CLIENT_LIST_PRES -eq 0 ]; then
        orc_log_script "Target Server is an LDAP client"
        RES=0
    else
        orc_log_script "Target Server is not an LDAP client"
        RES=1
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"

	return $RES
}

##################################################################################
#@ DESCRIPTION: compare the kernel versions
#@ USAGE: orc_is_valid_ipv4_address
#@ INPUT: $1 is an IP address in DOTTED-QUAD format
#@ OUTPUT: 0 if $1 is a valid IP address, else 1 if $1 is not a valid IP address
##################################################################################


function orc_is_valid_ipv4_address() 
{
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

  NUM_FIXED_ARGS=$#

  if [ "$NUM_FIXED_ARGS" -ne "1" ]
  then
	
	orc_log_script "ORC Internal Error: $FUNCNAME called with empty arguments (${*})"  

    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

	orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR

  fi

  IP_ADDR=$1 # Save this for later, going to split the input string
  
  case $1 in
      # reject the following:
      # empty string
      # anything other than digits and dots
      # anything not ending in a digit
      "" | *[!0-9.]* | *[!0-9])
  orc_log_script "ERROR: ${1} is not a valid IP address"
  [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
  return 1
            ;;
  esac

  OLD_IFS=$IFS
  
  IFS=.

  # Place the IP address into the positional parameters;
  # after word splitting each element becomes a parameter
  # ${IP_ADDR} has the IP address
  set -- $1

  [ $# -eq 4 ] && ## must be four parameters

# each must be less than 256
# A default of 666 (which is invalid) is used if a parameter is empty
# All four parameters must pass the test

  [ ${1:-666} -le 255 ] && [ ${2:-666} -le 255 ] && [ ${3:-666} -le 255 ] && [ ${4:-666} -le 255 ]
  local RC=$?
  IFS=$OLD_IFS
  
  if [[ $RC -ne 0 ]]
  then
    orc_log_script "ERROR: ${IP_ADDR} is not a valid IP address"
    [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
    return 1
  else
    orc_log_script "${IP_ADDR} is a valid IP address"
    [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
    return 0
  fi
}
######################################################################
#@ DESCRIPTION: check ha system info
#@ USAGE: orc_ha_server_online ()
#@ RETURNS 0 if Server  in "RUNNING" state, otherwise return 1
######################################################################
function orc_ha_server_online  
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    RES=0
    THISHOST=`$UNAME -n`
    
    HOSTSTATE=$($HASYS -state ${THISHOST} 2>/dev/null)

    if [ "${HOSTSTATE}" == "RUNNING" ]; then
        orc_log_script "$THISHOST in Correct state ($HOSTSTATE)"
        RES=0
    else
        orc_log_script "$THISHOST in incorrect states ($HOSTSTATE)"
        RES=1
    fi
	
    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"

    return $RES
}
######################################################################
#@ DESCRIPTION: check state of Oss and Sybase services
#@ USAGE: orc_check_sybase_oss_roles ()
#@ RETURNS 0 if both Sybase and Oss  in "ONLINE" state, otherwise return 1
######################################################################
function orc_check_sybase_oss_roles  
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    RES=0
    THISHOST=`$UNAME -n`
    SYBASE_ROLE=n
    OSS_ROLE=n

    if [ "$(${HAGRP} -state Oss -sys ${THISHOST})" == "ONLINE" ] && [ "$(${HAGRP}  -state Ossfs -sys ${THISHOST})" == "ONLINE" ]; then
        OSS_ROLE=y
    fi

    if [ "$(${HAGRP} -state Sybase1 -sys ${THISHOST})" == "ONLINE" ] ; then
        SYBASE_ROLE=y
    fi

    if [ $OSS_ROLE = "y" ]  && [ $SYBASE_ROLE = "y" ]; then
        orc_log_script "Oss and Sybase groups are running on this node. "   
        RES=0
    elif [ $OSS_ROLE = "y" ]  && [ $SYBASE_ROLE = "n" ]; then
        orc_log_script "Oss groups are running on this node.  The Sybase group is NOT running on this node"   
        RES=1
    elif [ $OSS_ROLE = "n" ]  && [ $SYBASE_ROLE = "y" ]; then
        orc_log_script "Oss groups are NOT running on this node.  The Sybase group is running on this node"   
        RES=1
    elif [ $OSS_ROLE = "n" ]  && [ $SYBASE_ROLE = "n" ]; then
        orc_log_script "Oss and Sybase groups are NOT running on this node"   
        RES=1
    else
        orc_log_script "${THISHOST} is not running both the Oss groups."
        RES=1
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"

    return $RES

}
######################################################################
#@ DESCRIPTION: check that cluster is corrrectly split
#@ USAGE: orc_check_cluster_split_state ()
#@ This function checks the o/p of hasys -state - in a correctly split
#@ system only 1 system state should be returned
#@ This function checks the contents of the "/etc/llhosts file
#@ In a correctly split system only line should be in this file
#@ RETURNS 0 if both All checks are satisfied, otherwise return 1
######################################################################
function orc_check_cluster_split_state  
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    RES=0
    THISHOST=`$UNAME -n`
    PUBNIC1=""
    PUBNIC2=""
    MC_STARTLIST_PRESENT=n

    if [ -f $LLTHOSTS ]
    then
        #First sanity check - size of the o/p of "hasys -state"
        NUMLINES=`${HASYS} -state | ${GREP} -v "#System"  | wc -l`
        NUMLINES2=`${CAT} ${LLTHOSTS} |  wc -l`

        if [ $NUMLINES2 -eq 1 ] && [ $NUMLINES -eq 1 ] ; then

            if [ -f $MC_START_LIST_SMSSR ] && [ -f $CLUSTER_INI ]
            then
            #if split correctly implemented, the /etc/opt/ericsson/nms_cif_smssr/mc_start_list
            #should exist. This ensures that only critical mcs will start up after a reboot
            #If it's not there, it indicates that split cluster was not completed.
                MC_STARTLIST_PRESENT=y

                PUBNIC1=`awk -F= '$1 ~ /^pubNIC1$/{print $2}' $CLUSTER_INI`
                test -n "$PUBNIC1"
                PUBNIC1_FOUND=$?
                PUBNIC2=`awk -F= '$1 ~ /^pubNIC2$/{print $2}' $CLUSTER_INI`
                test -n "$PUBNIC2"
                PUBNIC2_FOUND=$?
            
                if [ $PUBNIC1_FOUND  -eq 0 ] && [ $PUBNIC2_FOUND  -eq 0 ]
                then
                    orc_log_script "pubNIC1 and pubNIC2 found in $CLUSTER_INI file"
                    $GREP "block in log on $PUBNIC1 all" $IPF_CONF > /dev/null 2>&1
                    PUBNIC1_BLOCK_IN_LOG=$?
                    $GREP "block in log on $PUBNIC2 all" $IPF_CONF > /dev/null 2>&1
                    PUBNIC2_BLOCK_IN_LOG=$?
                    $GREP "block out log on $PUBNIC1 all" $IPF_CONF > /dev/null 2>&1
                    PUBNIC1_BLOCK_OUT_LOG=$?
                    $GREP "block out log on $PUBNIC2 all" $IPF_CONF > /dev/null 2>&1
                    PUBNIC2_BLOCK_OUT_LOG=$?

                    if [ $PUBNIC1_BLOCK_IN_LOG -eq 0 ] && [ $PUBNIC1_BLOCK_IN_LOG -eq 0 ] && [ $PUBNIC2_BLOCK_OUT_LOG -eq 0 ] && [ $PUBNIC2_BLOCK_OUT_LOG -eq 0 ] ; then
                        orc_log_script "$PUBNIC1 and $PUBNIC2  in correct state in $IPF_CONF"
                        RES=0
                    else
                        orc_log_script "$PUBNIC1 and $PUBNIC2  not in blocked state in $IPF_CONF"
                        RES=1
                    fi
                else
                    orc_log_script "Can't identify pubNIC1 and pubNIC2 in $CLUSTER_INI file"
                    RES=1
                fi
            else
                orc_log_script "Unable to locate ${MC_START_LIST_SMSSR} file indicating incorrect cluster state for upgrade"
                RES=1
            fi
        else
            orc_log_script "Unexpected cluster state for upgrade"
            RES=1
        fi
    else
        orc_log_script "$LLTHOSTS not found. Appears not to be correct server type"
        L_RES=1
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"

    return $RES
}

##################################################################################
#@ DESCRIPTION: mounts remote file system 
#@ USAGE: orc_mount
#@ INPUT: $1 is the IP address of the remote server to mount from
#@ INPUT: $2 is the remote directory on server 
#@ INPUT: $3 is the local directory 
#@ OUTPUT: 0 if the mount was successful, 1 otherwise
##################################################################################
function orc_mount
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: orc_mount (${*})"
	local -i retVal

    #****************************
    # Check number of args passed
    #****************************
    NUM_FIXED_ARGS=$#
    
    if [ $NUM_FIXED_ARGS -ne 3 ] 
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
	
    REMOTE_SERVER_IP=$1
    REMOTE_DIR=$2
    LOCAL_MOUNT_POINT=$3
    
    #******************************
    # Try pinging the remote server
    #******************************
    if orc_check_remote_server_alive "${REMOTE_SERVER_IP}"
    then
        #**************************************
        # Try unmounting the local mount point
        #**************************************
        if ! orc_unmount "${LOCAL_MOUNT_POINT}"
        then
            orc_log_script "ERROR: Couldn't unmount local mount point directory: ${LOCAL_MOUNT_POINT}"
            [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
            return 1
        fi

        #************************************************
        # Checking for existing mount point directory
        #************************************************
        if ! orc_check_directory_existence "${LOCAL_MOUNT_POINT}" 
        then
		
            #*****************************************************************
            #Creating directory
            #*****************************************************************
            [ "${DEBUG}" ] && orc_log_script "Creating directory ${LOCAL_MOUNT_POINT}"
		
            ${MKDIR} -p "${LOCAL_MOUNT_POINT}" > /dev/null 2>>${LOGFILE}
			retVal=$?
            if [ ${retVal} -ne 0 ] 
            then
                orc_log_script "ERROR: Creating local mount point directory ${LOCAL_MOUNT_POINT} failed"
                [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
                return 1
            else
                [ "${DEBUG}" ] && orc_log_script "Local mount point directory ${LOCAL_MOUNT_POINT} created "
            fi
        fi

        #******************************************************************************
        #Create the mount point 
        #******************************************************************************
        local pid
        local count
        local max_count

        ${MOUNT} "${REMOTE_SERVER_IP}:${REMOTE_DIR}" "${LOCAL_MOUNT_POINT}" > /dev/null 2>>${LOGFILE} &
        
        #Save the process id from the mount command
        pid=$!
        disown
        count=0
        max_count=6
        
        #Give the mount command time to execute
        sleep 2
        
        #Keep checking if the mount process is still alive
        #If it is still alive after 60 seconds then it is killed to prevent a hanging mount
        while [ $count -lt $max_count ]; do
            if ! kill -0 $pid 2> /dev/null; then
                break
            fi
            sleep 10
            ((count=count + 1))
        done
    
        if [ $count -eq $max_count ]; then
            kill -9 $pid 2> /dev/null
        fi 
        
        #Check if the mount has been successful
        if ! orc_check_mount "${LOCAL_MOUNT_POINT}"
        then
            orc_log_script "ERROR: Mounting ${REMOTE_SERVER_IP}:${REMOTE_DIR} to ${LOCAL_MOUNT_POINT} failed"
            # Clean up and remove the mount point directory
            orc_remove_directory "${LOCAL_MOUNT_POINT}"
            [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
            return 1
        else
            [ "${DEBUG}" ] && orc_log_script "Mounting ${REMOTE_SERVER_IP}:${REMOTE_DIR} to ${LOCAL_MOUNT_POINT} was successful "
        fi
    else
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"
    return 0
}

##################################################################################
#@ DESCRIPTION: Unmounts the local mount point & removes the directory if it exists
#@ USAGE: orc_unmount
#@ INPUT: $1 is the Local mount point
#@ OUTPUT: 0 if the unmount was successful, 1 otherwise
##################################################################################
function orc_unmount
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
	
	local -i retVal
    #****************************
    # Check number of args passed
    #****************************
    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ] 
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
  
    LOCAL_MOUNT_POINT=$1
    #Unmounting remote file system
    [ "${DEBUG}" ] && orc_log_script "Unmounting local mount point"
 
    #***********************************************************
    # Try to unmount the mountpoint if it is already created
    #***********************************************************
    if orc_check_mount $LOCAL_MOUNT_POINT 
    then 
        ${UMOUNT} -f "${LOCAL_MOUNT_POINT}" > /dev/null 2>&1
		retVal=$?
        if [ ${retVal} -ne 0 ] 
        then
            orc_log_script "Error: Unmounting local mount point ${LOCAL_MOUNT_POINT} failed"
            [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
            return 1
        else
            [ "${DEBUG}" ] && orc_log_script "Unmount of remote file system from mount point ${LOCAL_MOUNT_POINT} was successful"
        fi
    fi

    #***********************************************************
    # Try to remove the mountpoint directory
    #************************************************************
    if ! orc_remove_directory $LOCAL_MOUNT_POINT 
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
	
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_unmount return 0"	
  
    return 0
}

##################################################################################
#@ DESCRIPTION: checks if a mount point exists 
#@ USAGE: orc_check_mount
#@ INPUT: $1 is the mount point directory to check
#@ OUTPUT: 0 if the mount exists, 1 otherwise
##################################################################################
function orc_check_mount
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
	
    local res=0
    #****************************
    # Check number of args passed
    #****************************
    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ] 
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
  
    LOCAL_MOUNT_POINT=$1
    
    if orc_check_directory_existence "${LOCAL_MOUNT_POINT}"
    then
    
        #Check if a mount point exists
        if $MOUNT | grep "^$LOCAL_MOUNT_POINT " >/dev/null 2>&1 
        then
            [ "${DEBUG}" ] && orc_log_script "Mount point: ${LOCAL_MOUNT_POINT} exists"
            res=0
        else
            [ "${DEBUG}" ] && orc_log_script "Mount point: ${LOCAL_MOUNT_POINT} does not exist"
            res=1
        fi
    else
        res=1
	fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_check_mount, result ${res} "
	
    return $res
}

##################################################################################
#@ DESCRIPTION: Removes a directory if it exists 
#@ USAGE: orc_remove_directory
#@ INPUT: $1 The directory to remove
#@ OUTPUT: 0 if the directory is successfully removed
##################################################################################
function orc_remove_directory
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
	
    local res=0
    #****************************
    # Check number of args passed
    #****************************
    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]; then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        return 1
    fi
	
    DIRECTORY_TO_REMOVE=$1
	
    #***********************************************************
    # Try to remove the directory
    #************************************************************
    if  orc_check_directory_existence "${DIRECTORY_TO_REMOVE}" 
    then
        ${RMDIR} "${DIRECTORY_TO_REMOVE}" > /dev/null 2>&1
		res=$?
        if [ ${res} -ne 0 ] 
        then
            orc_log_script "Error: Removal of directory ${DIRECTORY_TO_REMOVE} failed"
            res=1
        else
            [ "${DEBUG}" ] && orc_log_script "Removal of directory ${DIRECTORY_TO_REMOVE} was successful"
        fi
    else
        [ "${DEBUG}" ] && orc_log_script "Directory to remove: ${DIRECTORY_TO_REMOVE} didn't exist"
    fi
        
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_remove_directory, result ${res} "
	
    return $res

}

######################################################################
#@ DESCRIPTION: check between two alphanumeric revisions to see which is the latest
#@ USAGE: orc_check_latest_revision(rev1 rev2)
#@ RETURNS 0
######################################################################

function orc_check_latest_revision() 
{

    $RM -f ${TEMP}/foo.$$

    for ARG in $*; do

            echo $ARG | tr '[:lower:]' '[:upper:]' | \

            $SED '

            s/\([A-Z]\)\([^A-Z0-9]\)/\19999\2/

            s/[A-Z]$/&9999/

            s/\([A-Z]\)\([0-9]\)/\1%\2/g

            s/\([0-9]\)\([A-Z]\)/\1%\2/g' >> ${TEMP}/foo.$$

    done

    value=`nawk '

    function compare_fields(a, b) {

            # Special handling for alphabetic fields. Compare the

            # length of the fields first to catch Z,AA,AB,etc.

            if (match(a,"[A-Z]") || match(b,"[A-Z]")) {

                    if (length(a) > length(b)) {

                            newest=$0

                            return 1

                    }

            else if (length(a) < length(b)) return 1

    }




    if (a > b) {

            newest=$0

            return 1

    }

    else if (a < b) return 1

    else return 0
    }

    {

    newest_len=split(newest, newest_fields, "[^A-Z0-9]")

    current_len=split($0, current_fields, "[^A-Z0-9]")


    if (current_len > newest_len) len=current_len


    # Compare 2nd position fields then 1st.

      if (compare_fields(current_fields[2], newest_fields[2])) next

      if (compare_fields(current_fields[1], newest_fields[1])) next


    # Compare the remaining fields in order

      for (i=3; i <= len; i++) {

            if (compare_fields(current_fields[i], newest_fields[i])) next

      }

    }

    END {

    if (broken == 0) print newest

    else print "broken"

    }' ${TEMP}/foo.$$ | $SED 's/%//g; s/9999//'`


      $RM -f ${TEMP}/foo.$$

      [ "$value" = "broken" ] && return 1 || echo $value

    return 0

}

##################################################################################
#@ DESCRIPTION: PINGs a remove server to check if it is alive
#@ USAGE: orc_check_remote_server_alive
#@ INPUT: $1 The IP address of the remote server to ping
#@ OUTPUT: 0 if the ping is successful, 1 otherwise
##################################################################################

function orc_check_remote_server_alive
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
	
    local res=0
	local -i retVal
    
    # Check number of args passed
    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]; then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
	
    REMOTE_SERVER_IP_ADDRESS=$1

    #Ping using the given IP address and set failure result if the ping fails
    $PING "${REMOTE_SERVER_IP_ADDRESS}" "${ORC_PING_TIMEOUT}" >/dev/null 2>&1
    retVal=$?
    if [ ${retVal} -ne 0 ] 
    then
        [ "${DEBUG}" ] && orc_log_script "Could not ping server ${REMOTE_SERVER_IP_ADDRESS}...Trying portping.pl ${PORTPING_PL} if available"

        if [ -n "${PORTPING_PL}" ] && [ -x "${PORTPING_PL}" ] && [ -f "${PORTPING_PL}" ]
        then
            ${PORTPING_PL} ${REMOTE_SERVER_IP_ADDRESS} ${SSH_PORT}  >/dev/null 2>&1
            retVal=$?
            if [ ${retVal} -eq 0 ]
            then
                [ "${DEBUG}" ] && orc_log_script "Successful portping for server ${REMOTE_SERVER_IP_ADDRESS} on port ${SSH_PORT}"
            else
                [ "${DEBUG}" ] && orc_log_script "Unsuccessful portping for server ${REMOTE_SERVER_IP_ADDRESS} on port ${SSH_PORT}"
                res=1
            fi
        else
            [ "${DEBUG}" ] && orc_log_script "Unable to use portping test as ${PORTPING_PL} is not available for execution"
            res=1
        fi
    else
        [ "${DEBUG}" ] && orc_log_script "Ping of server ${REMOTE_SERVER_IP_ADDRESS} was successful"
    fi
	
    [ "${DEBUG}" ] && orc_log_script "End Function: return (${res})"

    return $res

}
######################################################################
#@ DESCRIPTION: Single Node Check
#@ USAGE: Check if HA status is single node. This may be in the case
#@ of a Vapp
#@ This function checks the o/p of hasys -state - in a correctly split
#@ system only 1 system state should be returned
#@ This function checks the contents of the /etc/llthosts file
#@ In a correctly split system only line should be in this file
#@ RETURNS 0 if Singlr state confirmed, 1 otherwise.
######################################################################
function orc_ha_single_node_check
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=0
    local L_REM_PRIV="" #initialise
    local L_NUM_SYSTEMS=0 #initialise
    local L_NUM_GABTAB_SYSTEMS="" #initialise

    local L_THISHOST=`${HNAMECMD}`

    if [ -f $MAIN_CF ]
    then
        L_NUM_SYSTEMS=$($GREP -c "system " ${MAIN_CF})
        L_REM_PRIV=$(${AWK} '/-priv/ && $2 !~ /^'"${L_THISHOST}"'-/{print $2}' ${HOSTS})

    #   check for existence of $GABTAB file. Exit if not found
        if [ -f $GABTAB ]
        then
            L_NUM_GABTAB_SYSTEMS=`${GREP} "\-n1" ${GABTAB}`


            if [ "${L_REM_PRIV}" == "" ] && [ "${L_NUM_SYSTEMS}" -lt 2 ] && [ "${L_NUM_GABTAB_SYSTEMS}" != "" ]
            then
                [ "${DEBUG}" ] && orc_log_script "Server is part of a single node cluster"
                L_RES=0
            else
                [ "${DEBUG}" ] && orc_log_script "Server is part of a 2 node HA ADMIN cluster deployment"
                L_RES=1
            fi
        else
            orc_log_script "${GABTAB} file not found. Unable to determine HA status"
            L_RES=1
        fi
    else
        orc_log_script "$MAIN_CF not found. Appears not to be correct server type"
        L_RES=1
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: orc_ha_single_node_check, result ${L_RES} "

    return $L_RES
}

function orc_header_1()
{
  L_HEADER=$(${ECHO} "$*" | ${AWK} '{n1=length($0);n2=36-n1/2-n1%2;n3=36-n1/2;for(n=1;n<n2;n++)printf("=");printf("< %s >",$0);for(n=1;n<n3;n++)printf("=");printf("\n\n")}')
  
  orc_log_script "${L_HEADER}"
}

function orc_header_2()
{
  
  orc_log_script "===> ${1}"
}

function orc_header_3()
{
  
  orc_log_script "-> ${1}"
}

###########################################################################################################################
#@ DESCRIPTION: To check for a string in a log file, directory, or command output.
#@ USAGE: orc_egrep_for_string -f <file> | -d <directory> | -c <command> -s <string> [-e <exclude_list>] [-w <warn_list>]
#@ RETURNS: 0 string not found, 1 string found and will orc_cleanup_and_exit if not called correctly.
###########################################################################################################################
function orc_egrep_for_string() 
{    
    local ERRORS=""
    local WARNINGS=""
    local ExcludeList=""
    local WarnList=""
    local ErrString=""
    local FileName=""
    local DirName=""
    local CmdName=""
    local ErrString=""

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    unset OPTIND
    
    while getopts e:f:d:c:s:w: opt; do

        case ${opt} in

        f)      FileName=$OPTARG
                if [ ! -f ${FileName} ]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and ${FileName} not found or not a file"  
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
                ;;
        d)      DirName=$OPTARG
                if [ ! -d ${DirName} ]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and ${DirName} not found or not a directoy"  
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
                ;;
        c)      CmdName=$OPTARG
                if [ ! -e ${CmdName} ]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and ${CmdName} not found"
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
                ;;
        s)      ErrString=$OPTARG
                if [[ -z ${ErrString} ]]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and -s option used without a value"
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
                ;;
        e)      ExcludeList=${OPTARG}
                if [[ -z ${ExcludeList} ]]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and -e option used without a value"
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
                ;;
        w)      WarnList=${OPTARG}
                if [[ -z ${WarnList} ]]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and -w option used without a value"
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi                        
                ;;

        esac

    done


    if [[ ( -z ${FileName} )  &&  ( -z ${DirName} )  &&  ( -z ${CmdName} ) ]]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called and one of -f -d -c must be set"
        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi
    
    if [ -z "${ErrString}" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called and Error String is null"
        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi

	[[ -n ${FileName} ]] && orc_log_script "Checking file ${FileName} for strings containing \"${ErrString}\" "
	[[ -n ${DirName} ]] && orc_log_script "Checking ${DirName} files for strings containing \"${ErrString}\" "
	[[ -n ${CmdName} ]] && orc_log_script "Checking command ${CmdName} output for strings containing \"${ErrString}\" "

		
    if [[ -n "${ExcludeList}" ]];then
        [[ -n ${FileName} ]] && RESULTS1=$(${CAT} ${FileName} | ${EGREP} -i "${ErrString}" | ${EGREP} -v "${ExcludeList}")
        [[ -n ${DirName} ]] && RESULTS2=$(${EGREP} -i "${ErrString}" "${DirName}"/* | ${EGREP} -v "${ExcludeList}")
        [[ -n ${CmdName} ]] && RESULTS3=$(${CmdName} | ${EGREP} -i "${ErrString}" | ${EGREP} -v "${ExcludeList}")
    else
        [ "${DEBUG}" ] && orc_log_script "exclude list has no value"
        [[ -n ${FileName} ]] && RESULTS1=$(${CAT} ${FileName} | ${EGREP} -i "${ErrString}")
        [[ -n ${DirName} ]] && RESULTS2=$(${EGREP} -i "${ErrString}" "${DirName}"/*)
        [[ -n ${CmdName} ]] && RESULTS3=$(${CmdName} | ${EGREP} -i "${ErrString}")
    fi

    #RESULTS=`${ECHO} -e "${RESULTS1}\n${RESULTS2}\n${RESULTS3}"`
    RESULTS=`${ECHO} "${RESULTS1}\n${RESULTS2}\n${RESULTS3}"`
    
    [ "${DEBUG}" ] && orc_log_script "Results: ${RESULTS}"
    
    if [[ -z "${RESULTS}" ]]
    then
        [[ -n ${FileName} ]] && orc_log_script "Search string \"${ErrString}\" not found in file ${FileName}"
        [[ -n ${DirName} ]] && orc_log_script "Search string \"${ErrString}\" not found in directory ${DirName}"
        [[ -n ${CmdName} ]] && orc_log_script "Search string \"${ErrString}\" not found incommand ${CmdName}"
        
        [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
        
        return 0
    fi

    ###################################################
    # At this point we've found something, now build
    # and print the ERRORS and WARNINGS in Orc format
    ###################################################
    
    if [[ -n "${WarnList}" ]];then
        
        orc_log_script "Warning List is NOT empty"
        
        [ "${DEBUG}" ] && orc_log_script "Warning List:\n${WarnList}\n"
                
        ERRORS=$(${ECHO} "${RESULTS}"  | ${EGREP} -v "${WarnList}")
                
        if [[ -n "${ERRORS}" ]]
        then
            [ "${DEBUG}" ] && orc_log_script "Error List:\n$ERRORS\n"
            
            WARNINGS=`${ECHO} "${RESULTS}"  | ${EGREP} "${WarnList}"`
            
            if [[ -n "${WARNINGS}" ]]
            then

                [[ -n ${FileName} ]] && orc_log_script "Warnings found in file ${FileName}"
                [[ -n ${DirName} ]] && orc_log_script "Warnings found in directory ${DirName}"
                [[ -n ${CmdName} ]] && orc_log_script "Warnings found in command ${CmdName}"
                
                orc_header_2 "Start Warnings"
                
                OLD_IFS=$IFS
                IFS=$'\n'
                
                for record in $WARNINGS
                do
                    orc_header_3 "${record}"
                done
                
                IFS=$OLD_IFS
                
                orc_header_2 "End Warnings"
            fi
        fi
            
        if [ -n "${ERRORS}" ]
        then
            [[ -n ${FileName} ]] && orc_log_script "Errors found in file ${FileName}"
            [[ -n ${DirName} ]] && orc_log_script "Errors found in directory ${DirName}"
            [[ -n ${CmdName} ]] && orc_log_script "Errors found in command ${CmdName}"
            
            orc_header_2 "Start Errors"
            
            OLD_IFS=$IFS
            IFS=$'\n'
            
            for record in $ERRORS
            do
                orc_header_3 "${record}"
            done
            
            IFS=$OLD_IFS
            
            orc_header_2 "End Errors"
            
            [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
            
            return 1
        fi
    else
        orc_log_script "Warn List is empty."
        
        [[ -n ${FileName} ]] && orc_log_script "Errors found in file ${FileName}"
        [[ -n ${DirName} ]] && orc_log_script "Errors found in directory ${DirName}"
        [[ -n ${CmdName} ]] && orc_log_script "Errors found in command ${CmdName}"
        
        orc_header_2 "Start Errors"
        
        OLD_IFS=$IFS
        IFS=$'\n'
        
        for record in $RESULTS
        do
            orc_header_3 "${record}"
        done
        IFS=$OLD_IFS
        
        orc_header_2 "End Errors"
        
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        
        return 1
    fi
}

###########################################################################################################################
#@ DESCRIPTION: To check To see if a remote server can be "reached".
#@ USAGE: orc_check_remote_host servername
#@ RETURNS: 0 if we can ping and ssh to the server. Otherwise a 1 will be returned
#@ GLOBAL EXPORTS: ERRORS, WARNINGS
###########################################################################################################################
function orc_check_remote_host
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=0

    #****************************
    # Check number of args passed
    #****************************
    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

    local L_REMOTEHOST=$1

    #First try to ping the server
    if orc_check_remote_server_alive "${L_REMOTEHOST}"
    then
        [ "${DEBUG}" ] && orc_log_script  "Successfully pinged $L_REMOTEHOST. Attempting ssh.."
        if orc_check_remote_server_ssh_ok "${L_REMOTEHOST}"
        then
            [ "${DEBUG}" ] && orc_log_script  "Successfully connected to $L_REMOTEHOST via $SSH."
            L_RES=0
        else
            [ "${DEBUG}" ] && orc_log_script  "Could not connect to $L_REMOTEHOST via $SSH."
            L_RES=1
        fi
    else
        [ "${DEBUG}" ] && orc_log_script  "Could not ping $L_REMOTEHOST."
        L_RES=1
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: orc_check_remote_host, result ${L_RES} "

    return $L_RES
}

##################################################################################
#@ DESCRIPTION: Attempts to ssh to a server to check if it is alive
#@ USAGE: orc_check_remote_server_ssh_ok servername
#@ INPUT: $1 The IP address of the remote server to connect to
#@ OUTPUT: 0 if the ssh is successful, 1 otherwise
#@ NOTE: Only call this funtion if the server has successfully been pinged, otherwise ssh could hang
##################################################################################
function orc_check_remote_server_ssh_ok
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    local L_RES=0

    # Check number of: args passed
    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]; then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

    local L_REMOTEHOST=$1
    
    #initial cleanup
    if [ -f $SSH_RES_FILE ]
    then
        ${RM} -f ${SSH_RES_FILE} > /dev/null 2>&1
        $RM $SSH_RES_FILE
    fi
    
    # Can I login?
    ($SSH $SSH_OPTS $L_REMOTEHOST : >/dev/null 2>&1 ; echo $? > $SSH_RES_FILE ) &
    local L_PID=$!
    
    
    local L_CMD_TIMEOUT=10   # Number of seconds to wait for command
    local L_COUNT=0
    
    while true; do
        sleep 1
        if ! kill -0 $L_PID 2>/dev/null; then
            break  # background process has stopped
        fi
        if [ $L_COUNT -gt $L_CMD_TIMEOUT ]; then
            break  # timeout exceeded
        fi
        ((L_COUNT=L_COUNT+1))
    done
    
    if [ -f $SSH_RES_FILE ]; then
        local L_RC=$(<$SSH_RES_FILE)  # Get return code from file
        rm -f $SSH_RES_FILE
        : ${L_RC:=99}   # If L_RC empty, set it to 99
        if [ $L_RC -eq 0 ];then
            [ "${DEBUG}" ] && orc_log_script "$L_REMOTEHOST login OK."
            L_RES=0
        else
            [ "${DEBUG}" ] && orc_log_script "Cannot ssh-login to $L_REMOTEHOST. Error Code: [$L_RC]"
            L_RES=1
        fi
    else
        disown $L_PID  # Stops the terminate output coming to screen
        kill $L_PID 2>/dev/null
        [ "${DEBUG}" ] && orc_log_script "$SSH $L_REMOTEHOST command did not complete"
        L_RES=1
    fi    
    

    [ "${DEBUG}" ] && orc_log_script "End Function: return (${L_RES})"

    return $L_RES

}
##################################################################################
#@ DESCRIPTION: Attempts to definitively determin state of the cluster
#@ USAGE: orc_check_ha_cluster_status
#@ OUTPUT: 0 if the HA cluster is correctly split, 1 otherwise
##################################################################################
function orc_check_ha_cluster_status
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=255
    local L_THISHOST=`${HNAMECMD}`
    local L_REMOTE_HOST_REACHABLE=n
    local L_REMOTE_PRIV_HOST_REACHABLE=n
    local L_REM_PRIV=""
    local L_ON_ISOLATED_NODE=n
    local MC_STARTLIST_FILE_PRESENT=n
    local L_FAILOVER_STATE=n
    local L_NORMAL_HA_STATE=y
    local L_SPLIT_STATE=n
    local L_GEN_ERR_STATE=n

    if [ -f $LLTHOSTS ]
    then
        local NUMLINES_LLTHOSTS=`${CAT} ${LLTHOSTS} |  wc -l`

        if ( test -f "$MC_START_LIST_SMSSR" )
        then
            MC_STARTLIST_FILE_PRESENT=y
            [ "${DEBUG}" ] && orc_log_script "$MC_START_LIST_SMSSR found"
        fi

        #both $CLUSTER_INI snd $MAIN_CF need to be present
        if [ -f $CLUSTER_INI ] && [ -f $MAIN_CF ]
        then
            orc_get_remote_hostname ${L_THISHOST}
            orc_get_remote_private_hostname ${L_THISHOST}
            
            # if on isolated node -MAIN_CF won't define remote host - so don't try to retrieve OSS and Sybase
            if [ "$G_REMOTEHOST" != "" ]
            then
                orc_get_remote_oss_sybase_states ${G_REMOTEHOST}
                orc_log_script "Remote OSS State  : $G_REM_OSS_STATE"
                orc_log_script "Remote Sybase1 State  : $G_REM_SYB_STATE"
                
            fi
            
            local L_LOC_CLUSTERID=$($GREP clusterid $CLUSTER_INI | $CUT -d "=" -f2)

            orc_get_local_oss_sybase_states ${L_THISHOST}

            # if on isolated node, remote host will not be defined in MAIN_CF - so don't try to retrieve OSS & Sybase
            if [ "$G_REMOTEHOST" != "" ]
            then
                orc_get_remote_oss_sybase_states ${G_REMOTEHOST}
            fi
            
            local L_LOCAL_HASYS_STATE=$($HASYS -state $L_THISHOST)
            local L_REMOTE_HASYS_STATE=""

            if [ "${DEBUG}" == "TRUE" ]
            then        
                orc_log_script "Local host Name: $L_THISHOST"
                orc_log_script "Remote host Name: $G_REMOTEHOST"
                orc_log_script "Local cluster ID: $L_LOC_CLUSTERID"
                orc_log_script "Remote Private ID: $G_REM_PRIV"
                orc_log_script "Local HASYS state: $L_LOCAL_HASYS_STATE"                
                orc_log_script "$MC_START_LIST_SMSSR present: [${MC_STARTLIST_FILE_PRESENT}]"
            fi
            orc_log_script "Local OSS State  : $G_LOCAL_OSS_STATE"
            orc_log_script "Local Sybase1 State  : $G_LOCAL_SYB_STATE"
            
            
            if [ "$G_REMOTEHOST" != "" ]
            then
                L_REMOTE_HASYS_STATE=$($HASYS -state $G_REMOTEHOST)
                [ "${DEBUG}" ] && orc_log_script "Remote HASYS state: $L_REMOTE_HASYS_STATE"
                if ! orc_check_remote_host "${G_REMOTEHOST}"
                then
                    [ "${DEBUG}" ] && orc_log_script " Cannot reach $G_REMOTEHOST"
                    L_REMOTE_HOST_REACHABLE=n
                else
                    [ "${DEBUG}" ] && orc_log_script " Can reach $G_REMOTEHOST via public interface. HA cluster not split"
                    L_REMOTE_HOST_REACHABLE=y
                fi
            else
                [ "${DEBUG}" ] && orc_log_script "Only 1 system identified in $MAIN_CF. On isolated node"
                L_ON_ISOLATED_NODE=y
            fi
            
            if [ "$L_REMOTE_HOST_REACHABLE" == "y" ]
            then            
                L_REMOTE_PRIV_HOST_REACHABLE=n
            else
                [ "${DEBUG}" ] && orc_log_script " Cannot reach ${G_REM_PRIV%%-*} via public interface. Trying ${G_REM_PRIV%%-*} via private interface"
                #now run additional tests
                #try and ping remote server via private interface    
                if ! orc_check_remote_host "${G_REM_PRIV}"
                then
                    [ "${DEBUG}" ] && orc_log_script " Cannot reach host: ${G_REM_PRIV%%-*} via private interface"
                    L_REMOTE_PRIV_HOST_REACHABLE=n
                else        
                    [ "${DEBUG}" ] && orc_log_script " Can reach ${G_REM_PRIV%%-*} via private interface. Retrieving Remote Cluster Id"
                    L_REMOTE_PRIV_HOST_REACHABLE=y
                    local L_CLUSTERID_REM=$($SSH $G_REM_PRIV "$GREP"' clusterid '"$CLUSTER_INI"'  | '"$CUT"' -d = -f2')
                    [ "${DEBUG}" ] && orc_log_script "Remote Cluster ID: $L_CLUSTERID_REM"
                fi
            fi
            
            #We now have enough information to make a call on whether this system is successfully split
            #First check state of local Oss and Sybase
            if [ "$G_LOCAL_OSS_STATE" != "ONLINE" -o "$G_LOCAL_SYB_STATE" != "ONLINE" ]
            then
                [ "${DEBUG}" ] && orc_log_script "Local Oss and Sybase1 states not as expected"
                L_GEN_ERR_STATE=y
            else
                L_GEN_ERR_STATE=n
                [ "${DEBUG}" ] && orc_log_script "Local Oss and Sybase1 states as expected"
            fi
            
            
            if [ "$G_LOCAL_OSS_STATE" != "$G_LOCAL_SYB_STATE" ] && [ "$NUMLINES_LLTHOSTS" -eq 2 ] && [ "$MC_STARTLIST_FILE_PRESENT" == "n" ] && [ "$L_REMOTE_HOST_REACHABLE" == "y" ] && [ "$L_LOC_CLUSTERID" == "$L_CLUSTERID_REM" ]
            then
                L_NORMAL_HA_STATE=y
                [ "${DEBUG}" ] && orc_log_script "Local Oss State and local Sybase1 don't match. $MC_START_LIST_SMSSR not present. $G_REMOTEHOST reachable via public interface. Normal HA state"
            else
                L_NORMAL_HA_STATE=n
                [ "${DEBUG}" ] && orc_log_script "Not normal HA State"
            fi

            if [ "$G_LOCAL_OSS_STATE" == "$G_LOCAL_SYB_STATE" ] && [ "$L_REMOTE_HOST_REACHABLE" == "y" ] 
            then
                [ "${DEBUG}" ] && orc_log_script "Local Oss State and local Sybase1 state match. $G_REMOTEHOST reachable via public interface. Failover state"
                L_FAILOVER_STATE=y
            else
                [ "${DEBUG}" ] && orc_log_script "Not failover state"
                L_FAILOVER_STATE=n
            fi
            
          
            #Check for split    
            if [ "$L_REMOTE_HOST_REACHABLE" == "n" -a "$L_FAILOVER_STATE" == "n" -a "$L_NORMAL_HA_STATE" == "n" -a "$L_REMOTE_PRIV_HOST_REACHABLE" == "y" ]
            then
                [ "${DEBUG}" ] && orc_log_script "HA cluster preliminary checks OK: Check for split status"
                
                if [ "$L_LOCAL_HASYS_STATE" == "RUNNING" ] &&  [ "$L_CLUSTERID_REM" != "$L_LOC_CLUSTERID" ]
                then
                    if [ "$L_REMOTE_HASYS_STATE" == "EXITED" ] || [ "$L_REMOTE_HASYS_STATE" == "UNKNOWN" ]
                    then
                        [ "${DEBUG}" ] && orc_log_script "On Live Node."
                        local L_ON_LIVE_NODE=y
                        L_RES=1
                    else
                        local L_ON_LIVE_NODE=n
                        if [ "$NUMLINES_LLTHOSTS" -eq 1 ] && [ "$MC_STARTLIST_FILE_PRESENT" == "y" ]
                        then
                            #checks for state of pubNIC1 and pubNIC2. Both must be blocked
                            orc_check_blocked_state
                            L_RES=$?
                        else
                            [ "${DEBUG}" ] && orc_log_script "$LLTHOSTS or MC_START_LIST_SMSSR in unexpected state"
                            L_RES=1
                        fi                    
                        
                        
                    fi
                else
                    L_RES=1
                fi
            else
                L_RES=1
            fi
        else
            [ "${DEBUG}" ] && orc_log_script "Both $CLUSTER_INI and $MAIN_CF required to check cluster status"
            L_RES=1
        fi        
        

        if [ "$L_RES" -eq 0 ]
        then
            if [ "$L_GEN_ERR_STATE" == "y" ]
            then
                [ "${DEBUG}" ] && orc_log_script "Cluster appears to be in a split state but Local Oss and Sybase1 NOT in expected state."
                L_RES=1
            else
                [ "${DEBUG}" ] && orc_log_script "Cluster appears to be in a split state and Local Oss and Sybase1 running."
            fi
        else
      
            orc_log_script "HA cluster state is NOT fully split"


        fi
    else
        orc_log_script "$LLTHOSTS not found. Appears not to be correct server type"
        L_RES=1
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return (${L_RES})"

    return $L_RES

}

### Function: orc_cleanup_and_exit_after_usg_msg ###
#
# Specific clean up and exit function for after usage message is
# printed.
# No message is printed at exit unless an error condition is present
#
# Arguments     : $1 Exit code
#                 0 - Normal exit
#                 1 - Error condition
#                 4 - Do not remove pre-existing lockfile
# Arguments     : $2 Orc log tag
#                      
# Return Values : none
#
#********************************************************
function orc_cleanup_and_exit_after_usg_msg()
{  
  [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
  
  local L_EXIT_CODE
  local L_ORC_TAG
  L_EXIT_CODE=${1}
  L_ORC_TAG=${2}
     
  #*****************
  # Remove the traps
  #*****************
  trap - INT HUP QUIT TSTP
  trap - EXIT

  #*****************************************************
  # Delete the lockfile if it wasn't created by this run
  #*****************************************************
  if [ "${L_EXIT_CODE}" -ne 4 ]
  then
      ${RM} -f ${LUG_LOCKFILE} > /dev/null 2>&1
  fi

  #Only print a message if it's an error condition and Logging is on, otherwise no messages are required
  if [ "${L_EXIT_CODE}" -eq 1 ]
  then
        if [ -f "${LOGFILE}" ];
        then
            $ECHO "${L_ORC_TAG}: ${SCRIPTNAME} module failed with error ${L_EXIT_CODE}. Refer to logfile ${LOGFILE} for details"
        else
            $ECHO "${L_ORC_TAG}: ${SCRIPTNAME} module failed with error ${L_EXIT_CODE}. Refer to previous log messages for details"
        fi
  fi
  
  [ "${DEBUG}" ] && orc_log_script "End Function: exit(${L_EXIT_CODE})"

  exit ${L_EXIT_CODE}
}

### Function: orc_check_bootenv_active_and_onreboot ###
#
# Checks there is a boot environment that is active and active_on_reboot.
# Sets variable BOOTENV to the active boot environment
#
# Arguments     : none
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_check_bootenv_active_and_onreboot
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    # From lustatus extract name, and active now and active on reboot columns
    # and find the one with yes yes in
    BOOTENV=`$LUSTATUS 2>/dev/null| $AWK '$3 ~ /yes/ && $4 ~ /yes/{print $1}'`
    if [ -z ${BOOTENV} ]
    then
        [ "${DEBUG}" ] && orc_log_script "Did not find bootenv that was active now and on reboot"
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1 
    fi
    [ "${DEBUG}" ] && orc_log_script "Found ${BOOTENV} bootenv that was active now and on reboot"
    [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"
    return 0
}

### Function: orc_check_process_running ###
#
# Checks there is a process running with given name
#
# Arguments     : Name of process
#
# Return Values : 0 - Running
#                 1 - Not running
#
#******************************
function orc_check_process_running
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    $PS -aef| $EGREP -v grep| $EGREP $1 > /dev/null 2>&1
    local RC=$?
    if [ $RC -ne 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script "Process $1 not running" 
    else
         [ "${DEBUG}" ] && orc_log_script "Process $1 running" 
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: return ($RC)"
    return $RC
}

### Function:  orc_enable_service ###
#
# Enable service
#
# Arguments     : service to enable
#
# Return Values : 0 - Successfull
#
#******************************
function  orc_enable_service
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    NUM_FIXED_ARGS=$#

    if [ "$NUM_FIXED_ARGS" -ne "1" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with wrong number of arguments (${*})"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1

    fi
    SERVICE=$1
    if ( ! orc_check_is_service_valid ${SERVICE} )
    then
        orc_log_script "Service (${SERVICE}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    $SVCADM enable ${SERVICE} > /dev/null 2>&1
    RC=$?
    if [ $RC -ne 0 ]
    then
        orc_log_script "Service ${SERVICE} enable failed ${RC}"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    orc_log_script "Service ${SERVICE} is enabled"
    [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
    return 0
}
### Function:  orc_wait_service_online ###
#
# Waits for service to come online, up to n attempts
#
# Arguments     : service to check is online
#               : number of attempts to check (optional). Default is 1
#               : interval between checks in seconds (optional). Default is 1          
#
# Return Values : 0 - Successfull
#
function orc_wait_service_online
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    NUM_FIXED_ARGS=$#

	if [ "$NUM_FIXED_ARGS" -ne "1" ] && [ "$NUM_FIXED_ARGS" -ne "3" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with wrong number of arguments (${*})"
        [ "${DEBUG}" ] && orc_log_script "End Function: (1)"
        return 1
    fi

    local SERVICE=$1
    local NUM_ATTEMPTS=${2:-1}
	local CHECK_INTERVAL=${3:-1}


    if ( ! orc_check_is_service_valid ${SERVICE} )
    then
        orc_log_script "Service (${SERVICE}) is not valid"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    COUNT=0
    while [ ${COUNT} -lt ${NUM_ATTEMPTS} ]
    do
        if ( orc_check_is_service_online ${SERVICE} )
        then
            orc_log_script "Service ${SERVICE} is online"
            [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
            return 0
        else
            ((COUNT++))
            [ "${DEBUG}" ] && orc_log_script "Pausing before another service check"
            sleep ${CHECK_INTERVAL}
        fi
    done
    orc_log_script "Service ${SERVICE} failed to be online"
    [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
    return 1
}
### Function: orc_check_vcs_system_running ###
#
# Checks that hastatus summary is running
#
# Arguments     : Host to check
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_check_vcs_system_running
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    # Get host to check from 1st argument
    NUM_FIXED_ARGS=$#
    if [ "$NUM_FIXED_ARGS" -ne "1" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with wrong number of arguments (${*})"
        [ "${DEBUG}" ] && orc_log_script "End Function: (1)"
        return 1
    fi

    L_HOST=$1
    # Check hasys -state
    if [ "$(${HASYS} -state ${L_HOST})" = "RUNNING" ]
    then
        orc_log_script "VCS system running"
    else
        orc_log_script "VCS system not currently running"
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"
    return 0
}
### Function: orc_check_vcs_group_online ###
#
# Checks that vcs group is online
#
# Arguments     : Group to check
#                  Host to check
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_check_vcs_group_online
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    # Get host to check from 1st argument
    NUM_FIXED_ARGS=$#
    if [ "$NUM_FIXED_ARGS" -ne "2" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with wrong number of arguments (${*})"
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi
    # Check group status
    L_SERVICE=$1
    L_HOST=$2
    local RC=1
    if [ "$(${HAGRP} -state ${L_SERVICE} -sys ${L_HOST})" = "ONLINE" ]
    then
        RC=0
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: return ($RC)"
    return ${RC}
}

###########################################################################################################################
#@ DESCRIPTION: Return the server type
#@ USAGE: 
#@ RETURNS: The type of the server
#@ GLOBAL EXPORTS: Server Type
###########################################################################################################################
function orc_get_server_type() {
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES="0"

    unset SERVER_TYPE

    if (orc_check_existence $USE_CONFIG)
    then
        SERVER_TYPE_FROM_FILE=$($CAT $USE_CONFIG | $AWK -F= '{print $2 }')

        [ "${DEBUG}" ] && orc_log_script "Server Type: ${SERVER_TYPE_FROM_FILE} parsed from ${USE_CONFIG} file"

        case ${SERVER_TYPE_FROM_FILE} in

              system)          SERVER_TYPE="ADMIN"
                               ;;
              ebas)            SERVER_TYPE="EBAS"
                               ;;
              smrs_slave)      SERVER_TYPE="NEDSS"
                               ;;
              peer)            SERVER_TYPE="PEER"
                               ;;
              appserv)         SERVER_TYPE="UAS"
                               ;;
              om_serv_master)  SERVER_TYPE="OM_SERVICES"
                               ;;
              om_serv_slave)   SERVER_TYPE="OM_SERVICES"
                               ;;
              infra_omsas)     SERVER_TYPE="OMSAS"
                               ;;
              mws)             SERVER_TYPE="MWS"
                               ;;
              *)               orc_log_script "Server Type From File: ${SERVER_TYPE_FROM_FILE} not recognised as a supported server type.." 
                               L_RES="1"
                               ;;
         esac

    elif (orc_check_existence $INST_TYPE)
    then
        SERVER_TYPE_FROM_FILE=$($CAT $INST_TYPE | $AWK '{print $1}') 
        [ "${DEBUG}" ] && orc_log_script "Server Type: \"${SERVER_TYPE_FROM_FILE}\" parsed from $INST_TYPE file"
        if [ "$SERVER_TYPE_FROM_FILE" = "ombs" ]
        then
            SERVER_TYPE="OMBS"
        else
            orc_log_script "Server Type: \"${SERVER_TYPE_FROM_FILE}\" not recognised as a supported server." 
            L_RES="1"
        fi
    elif ($PKGINFO ${ERIC_JUMP_PKG} > /dev/null 2>&1)
    then
        [ "${DEBUG}" ] && orc_log_script "Package ERICjump installed.  Identified server type as MWS."
        SERVER_TYPE="MWS"
    else
        L_RES="1"
        SERVER_TYPE=""
    fi
    
    export SERVER_TYPE

    [ "${DEBUG}" ] && orc_log_script "End Function: (${L_RES})"

    return $L_RES
}


function orc_confirm_server_type() {

        [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
        local L_RES="0"

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
        then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi

    SERVER_TYPE_FROM_USER=$1

    orc_get_server_type

    if test "${SERVER_TYPE_FROM_USER}" = "${SERVER_TYPE}"
    then
                L_RES="0"
        [ "${DEBUG}" ] && orc_log_script "Server Type match: ${SERVER_TYPE_FROM_USER}  = ${SERVER_TYPE}"
    else
        L_RES="1"
        orc_log_script "ERROR: Server Type ${SERVER_TYPE_FROM_USER} does not match the value ${SERVER_TYPE} parsed from the server"
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

    return $L_RES
}


###########################################################################################################################
#@ DESCRIPTION: Checks is isolated server is in a blocked state
#@ USAGE: orc_check_blocked_state
#@ RETURNS: 0 if Sever is correctly blocked, 1 otherwise.
###########################################################################################################################
function orc_check_blocked_state
{
 	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=255
    local L_NUM_INSTANCES=0
    local PUBNIC1=""
    local PUBNIC2=""
    local -i PUBNIC1_FOUND=255
    local -i PUBNIC2_FOUND=255
    local -i PUBNIC1_BLOCK_IN_LOG=255
    local -i PUBNIC2_BLOCK_IN_LOG=255
    
    #check existence of CLUSTER_INI and IPF_CONF
    if [ ! -f $CLUSTER_INI ] || [ ! -f $IPF_CONF ]
    then
        orc_log_script "Both $CLUSTER_INI and $IPF_CONF required to check blocked status"
        L_RES=1
    else
        [ "${DEBUG}" ] && orc_log_script "$CLUSTER_INI and  $IPF_CONF found"
        
        PUBNIC1=`awk -F= '$1 ~ /^pubNIC1$/{print $2; exit}' $CLUSTER_INI`
        test -n "$PUBNIC1"
        PUBNIC1_FOUND=$?
        PUBNIC2=`awk -F= '$1 ~ /^pubNIC2$/{print $2; exit}' $CLUSTER_INI`
        test -n "$PUBNIC2"
        PUBNIC2_FOUND=$?

        if [ $PUBNIC1_FOUND  -eq 0 ] && [ $PUBNIC2_FOUND  -eq 0 ]
        then
            [ "${DEBUG}" ] && orc_log_script "pubNIC1 and pubNIC2 found in $CLUSTER_INI file"
            $GREP "block in log on $PUBNIC1 all" $IPF_CONF > /dev/null 2>&1
            PUBNIC1_BLOCK_IN_LOG=$?
            $GREP "block in log on $PUBNIC2 all" $IPF_CONF > /dev/null 2>&1
            PUBNIC2_BLOCK_IN_LOG=$?
            $GREP "block out log on $PUBNIC1 all" $IPF_CONF > /dev/null 2>&1
            PUBNIC1_BLOCK_OUT_LOG=$?
            $GREP "block out log on $PUBNIC2 all" $IPF_CONF > /dev/null 2>&1
            PUBNIC2_BLOCK_OUT_LOG=$?

            if [ $PUBNIC1_BLOCK_IN_LOG -eq 0 ] && [ $PUBNIC2_BLOCK_IN_LOG -eq 0 ] && [ $PUBNIC1_BLOCK_OUT_LOG -eq 0 ] && [ $PUBNIC2_BLOCK_OUT_LOG -eq 0 ] ; then
                [ "${DEBUG}" ] && orc_log_script "$PUBNIC1 and $PUBNIC2  in correct state in $IPF_CONF"
                L_RES=0
            else
                [ "${DEBUG}" ] && orc_log_script "$PUBNIC1 and $PUBNIC2  not in blocked state in $IPF_CONF"
                L_RES=1
            fi
        else
            [ "${DEBUG}" ] && orc_log_script "Can't identify pubNIC1 and pubNIC2 in $CLUSTER_INI file"
            L_RES=2
        fi        
        
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

	
    return $L_RES
    
   
}
###########################################################################################################################
#@ DESCRIPTION: Return the rempote server name
#@ USAGE: orc_get_remote_hostname <thhis hostname>
#@ RETURNS: 
#@ GLOBAL EXPORTS: Remote server name
###########################################################################################################################
function orc_get_remote_hostname
{
 	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=0
    local L_THISHOST=""

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
	then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi
	
    local L_THISHOST=$1

    unset G_REMOTEHOST
    
    if [ -f $MAIN_CF ]
    then    
    G_REMOTEHOST=$($GREP system $MAIN_CF | $AWK '{print $2}' | $GREP -v ${L_THISHOST})
    else
        orc_log_script "$MAIN_CF not found. Appears not to be correct server type"
        L_RES=1
    fi
    
    
    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

	export G_REMOTEHOST
    
    return $L_RES
    
}
###########################################################################################################################
#@ DESCRIPTION: Return the rempote private server name
#@ USAGE: orc_get_remote_private_hostname <thhis hostname>
#@ RETURNS: 
#@ GLOBAL EXPORTS: Remote server name (private Interface)
###########################################################################################################################
function orc_get_remote_private_hostname
{
 	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=0
    local L_THISHOST=""

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
	then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi
	
    L_THISHOST=$1

    unset G_REM_PRIV
        
    G_REM_PRIV=$(${AWK} '/-priv/ && $2 !~ /^'"${L_THISHOST}"'-/{print $2}' ${HOSTS})
    
    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

	export G_REM_PRIV
    
    return $L_RES
    
}
###########################################################################################################################
#@ DESCRIPTION: Return the local Oss and Sybase roles
#@ USAGE: orc_get_local_oss_sybase_states <this hostname>
#@ RETURNS: 
#@ GLOBAL EXPORTS: Local Sybase and Oss roles
###########################################################################################################################
function orc_get_local_oss_sybase_states
{
 	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=0

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
	then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi
	
    local L_THISHOST=$1

    unset G_LOCAL_OSS_STATE
    unset G_LOCAL_SYB_STATE
    
    G_LOCAL_OSS_STATE=$($HAGRP -state Oss -sys $L_THISHOST)
    G_LOCAL_SYB_STATE=$($HAGRP -state Sybase1 -sys $L_THISHOST)
    
    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

	export G_LOCAL_OSS_STATE
	export G_LOCAL_SYB_STATE
    
    return $L_RES
    
}
###########################################################################################################################
#@ DESCRIPTION: Return the remote Oss and Sybase roles
#@ USAGE: orc_get_local_oss_sybase_states <this hostname>
#@ RETURNS: 
#@ GLOBAL EXPORTS: Remote Sybase and Oss roles
###########################################################################################################################
function orc_get_remote_oss_sybase_states
{
 	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=0

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
	then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi
	
    local L_THISHOST=$1

    unset G_REM_OSS_STATE
    unset G_REM_SYB_STATE
    
    G_REM_OSS_STATE=$($HAGRP -state Oss -sys $L_THISHOST)
    G_REM_SYB_STATE=$($HAGRP -state Sybase1 -sys $L_THISHOST)
    
    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

	export G_REM_OSS_STATE
	export G_REM_SYB_STATE
    
    return $L_RES
    
}


### Function: orc_check_share ###
#
# Checks the filesystem is listed in shares
#
# Arguments     : filesystem to check
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_check_share()
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    NUM_FIXED_ARGS=$#
    RC=0
    if [ "$NUM_FIXED_ARGS" -ne "1" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with wrong number of arguments"

        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi
    #***********************************************
    # OSS-49740 changed exact match to pattern match
    #***********************************************
    #SHARES=`$EXPORTFS 2>/dev/null|$EGREP "[ ]+$1[ ]+"`
    SHARES=`$EXPORTFS 2>/dev/null|$EGREP "[ ]+$1"`
    if [ -z "${SHARES}" ]
    then
        orc_log_script "$1 filesystem not currently shared"
        RC=1
    else
        orc_log_tag "$1 filesystem shared"
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return ($RC)"
    return $RC
}

### Function: orc_get_omservices_type ###
#
# Returns whether OM_SERVICES is MASTER or SLAVE. If successful will set
# variable OMSERV_TYPE
#
# Arguments     : None
#
# Return Values : 0 if got omservices type
#                 1 if failed to get omservices type
#
#******************************
function orc_get_omservices_type
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    if (orc_check_existence ${USE_CONFIG})
    then
        SERVER_TYPE_FROM_FILE=$($CAT ${USE_CONFIG} | $AWK -F= '{print $2 }')
        [ "${DEBUG}" ] && orc_log_script "Server Type: ${SERVER_TYPE_FROM_FILE} parsed from ${USE_CONFIG} file"

        case ${SERVER_TYPE_FROM_FILE} in

            om_serv_master) OMSERV_TYPE="MASTER"
                            RC=0
                            ;;
            om_serv_slave)  OMSERV_TYPE="SLAVE"
                            RC=0
                            ;;
            *)              RC=1
                            ;;
        esac
    else
        [ "${DEBUG}" ] && orc_log_script "Cannot find OM type as no ${USE_CONFIG}"
        RC=1
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return (${RC})"
    return ${RC}
}


### Function: orc_wait_for_server_reboot ###
#
# Arguments     : $1 = remote server
#               : $2 = shutdown file
#               : $3 = startup file
#
# Return Values : 0 if server has rebooted
#                 1 if cannot connect to server
#                 2 if server is going down
#               255 if server is in an indeterminate state (no shutdown or startup file)
#
#******************************
function orc_wait_for_server_reboot()
{
    local REMOTE_SERVER=""
    local SHUTDOWN_FILE=""
    local STARTUP_FILE=""
	local SSH_OPTIONS="-o LogLevel=quiet -o StrictHostKeyChecking=no -o PasswordAuthentication=no"
    local -i NUM_FIXED_ARGS=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

	unset OPTIND
	while getopts ":s:" ARG
	do
		case ${ARG} in
		s)    SSH_OPTIONS="${OPTARG}"
			;;
		*)    ${ECHO} "ERROR: Invalid option ${OPTARG} supplied, ignoring"
			;;
		esac
	done
  
	shift $((OPTIND-1))

    NUM_FIXED_ARGS=$#
	
    if [ $NUM_FIXED_ARGS -lt 3 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with too few arguments"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi

    if [ $NUM_FIXED_ARGS -gt 4 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with too many arguments"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi
	
    #****************************************
    # Handle the input arguments...
    #***************************************
    
    REMOTE_SERVER=$1
    SHUTDOWN_FILE=$2
    STARTUP_FILE=$3
    
    if [ -z "${REMOTE_SERVER}" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with empty \"remote server\" argument"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR    
    fi

    if [ -z "${SHUTDOWN_FILE}" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with empty \"shutdown file\" argument"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR    
    fi

    if [ -z "${STARTUP_FILE}" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with empty \"startup file\" argument"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR    
    fi
    
    #****************************************
    # Check to see if any SSH connectivity
    #***************************************

    if ( $(${SSH} ${SSH_OPTIONS} ${REMOTE_SERVER} '[ -d /tmp ]') )
    then
        #****************************************
        # Check to see if the server is going down
        #***************************************
        orc_log_script "SUCCESSFUL connection to server \"${REMOTE_SERVER}\" - checking status"

        if ( $(${SSH} ${SSH_OPTIONS} ${REMOTE_SERVER} "[ -f ${SHUTDOWN_FILE} ]") )
        then

            orc_log_script "Server \"${REMOTE_SERVER}\" - still going down"
            [ "${DEBUG}" ] && orc_log_script "End Function: return(2)"
            return 2

            #***************************************************************************
            # Check to see if server has special file to indicte successful reboot
            #***************************************************************************

        elif ( $(${SSH} ${SSH_OPTIONS} ${REMOTE_SERVER} "[ -f ${STARTUP_FILE}  ]") )
        then

            orc_log_script "SUCCESSFUL reboot of server \"${REMOTE_SERVER}\""
            [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
            return 0
        else
            #***************************************************************************
            # Unable to determine the state of the server
            #***************************************************************************

            orc_log_script "ERROR Indeterminate run state. Neither startup or shutdown file was found on server \"${REMOTE_SERVER}\""
            [ "${DEBUG}" ] && orc_log_script "End Function: return(255)"
            return 255
        fi
    else
        orc_log_script "UNSUCCESSFUL connection to server \"${REMOTE_SERVER}\""
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

}

### Function: orc_check_process_pid_running ###
#
# Checks there is a process running with given name and pid
#
# Arguments     : Name of process
#                 Expected pid
#
# Return Values : 0 - Running with expected pid
#                 1 - Not running
#                 2 - Running with wrong pid
#
#******************************
function orc_check_process_pid_running
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    NUM_FIXED_ARGS=$#
	local -i retVal

    if [ "$NUM_FIXED_ARGS" -ne "2" ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with wrong number of arguments (${*})"  
        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
	
	    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi

    local RC=0
    $PS -aef| $EGREP -v grep| $EGREP $1 > /dev/null 2>&1
    RC=$?
    if [ $RC -ne 0 ]
    then
        [ "${DEBUG}" ] &&  orc_log_script "Process $1 not running" 
        RC=1
    else
        [ "${DEBUG}" ] && orc_log_script "Process $1 running" 
        # Now check pid, by doing grep for processes with pid - make
        # parent pid empty so dont get lines with parent pid
        $PS -aef | $AWK '{ $3=""; print $0}' | $EGREP -v grep | $GREP -w $2 | $GREP $1 > /dev/null 2>&1
		retVal=$?
        if [ ${retVal} -eq 0 ]
        then
            [ "${DEBUG}" ] && orc_log_script "Process $1 running with pid $2" 
            RC=0
        else
            [ "${DEBUG}" ] && orc_log_script "Process $1 running on pid other than $2" 
            RC=2
        fi
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: return($RC)"
    return $RC

}


### Function: orc_spinner ###
#
# Call the script to start or stop a spinning
# line to show something is going on.
#
# Arguments:
#   $1 : [ start | stop ]
# Return Values:
#   none
function orc_spinner()
{
   SPINNERHOME=$(/bin/dirname $0)
    if [ -n "${SPINNER_SUBDIR}" ]; then
        SPINNERHOME="${SPINNERHOME}/${SPINNER_SUBDIR}"
    fi
    case $1 in
        start)
            if [ -f $SPINNERHOME/spinner.sh ]; then
                 sh $SPINNERHOME/spinner.sh &
                 SPINNER_PID=$!
            fi
        ;;

        stop)
            if [ -f $SPINNERHOME/spinner.sh  ]; then
                if [ ${SPINNER_PID} -ne 0 ]; then
                    sh $SPINNERHOME/spinner.sh ${SPINNER_PID}
                    SPINNER_PID=0
                fi
            fi
        ;;

        *)
        ;;
    esac

}
######################################################################
#@ DESCRIPTION: check state of Oss and Sybase services
#@ USAGE: orc_check_oss_roles ()
#@ RETURNS 0 if both Sybase and Oss  in "ONLINE" state, otherwise return 1
######################################################################
function orc_check_oss_roles
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local L_RES=255
    local L_THISHOST=`$UNAME -n`

    L_THISHOST=`$UNAME -n`

    if [ "$(${HAGRP} -state Oss -sys ${L_THISHOST})" == "ONLINE" ] && [ "$(${HAGRP}  -state Ossfs -sys ${L_THISHOST})" == "ONLINE" ]; then
        L_RES=0
        [ "${DEBUG}" ] && orc_log_script "OSS active on $L_THISHOST"
    else
        L_RES=1
        [ "${DEBUG}" ] && orc_log_script "OSS NOT active on $L_THISHOST"
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return($L_RES)"

    return $L_RES

}
######################################################################
#@ DESCRIPTION: Gets the admin server state
#@ USAGE: orc_get_admin_server_state ()
#@ RETURNS 0 if single node
#          1 if node to be upgraded
#          2 if node not to be upgraded
#          >2 error
######################################################################
function orc_get_admin_server_state
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local -i retVal
    local L_THISHOST=`${HNAMECMD}`
    orc_ha_single_node_check
	retVal=$?
    if [ ${retVal} -eq 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script "In single node state"
        return 0
    else 
        [ "${DEBUG}" ] && orc_log_script "Not in single node state"

        orc_get_local_oss_sybase_states ${L_THISHOST}

        local L_CLUSTERID_LOC=$($GREP clusterid $CLUSTER_INI | $CUT -d "=" -f2)

        orc_get_remote_hostname ${L_THISHOST}
        orc_get_remote_private_hostname ${L_THISHOST}

        local L_CLUSTERID_REM=""
        if orc_check_remote_host "${G_REMOTEHOST}"
        then
            L_CLUSTERID_REM=$($SSH  -o StrictHostKeyChecking=no -o loglevel=quiet  $G_REMOTEHOST "$GREP"' clusterid '"$CLUSTER_INI"'  | '"$CUT"' -d = -f2')
        elif orc_check_remote_host "${G_REM_PRIV}"
        then
            L_CLUSTERID_REM=$($SSH  -o StrictHostKeyChecking=no -o loglevel=quiet $G_REM_PRIV "$GREP"' clusterid '"$CLUSTER_INI"'  | '"$CUT"' -d = -f2')
        else
            [ "${DEBUG}" ] && orc_log_script "Failed to connect to remote host"
            return 3
        fi

        local NUMLINES_LLTHOSTS=0
        local MC_START_PRESENT=1
        if [ -f $LLTHOSTS ]
        then
            local NUMLINES_LLTHOSTS=`${CAT} ${LLTHOSTS} |  wc -l`
            if ( test -f "$MC_START_LIST_SMSSR" )
            then
                MC_START_PRESENT=0
            fi
        else
            [ "${DEBUG}" ] && orc_log_script "No LLThosts entry"
            return 8
        fi

        if [ "${L_CLUSTERID_LOC}" = "${L_CLUSTERID_REM}" ] &&
           [ ${MC_START_PRESENT} -eq 1 ] &&
           [ ${NUMLINES_LLTHOSTS} -eq 2 ]
        then
            if [ "$G_LOCAL_SYB_STATE" = "ONLINE" ] &&
               [ "$G_LOCAL_OSS_STATE" != "ONLINE" ]
            then
                [ "${DEBUG}" ] && orc_log_script "Cluster id match and upgrade node"
                return 1
            elif [ "$G_LOCAL_SYB_STATE" != "ONLINE" ] &&
               [ "$G_LOCAL_OSS_STATE" = "ONLINE" ]
            then
                [ "${DEBUG}" ] && orc_log_script "Cluster id match and non-upgrade node"
                return 2
            else
                [ "${DEBUG}" ] && orc_log_script "Only one of Oss or Sybase expected to be online"
                return 4
            fi
        elif [ "${L_CLUSTERID_LOC}" != "${L_CLUSTERID_REM}" ]
        then
            if [ "$G_LOCAL_SYB_STATE" = "ONLINE" ] &&
               [ "$G_LOCAL_OSS_STATE" = "ONLINE" ]
            then 
                if [ ${NUMLINES_LLTHOSTS} -eq 1 ] &&
                   [ ${MC_START_PRESENT} -eq 0 ] 
                then
                    [ "${DEBUG}" ] && orc_log_script "Cluster id differ and non-upgrade node"
                    return 1
                elif [ ${NUMLINES_LLTHOSTS} -eq 2 ] &&
                     [ ${MC_START_PRESENT} -eq 1 ] 
                then
                    [ "${DEBUG}" ] && orc_log_script "Cluster id differ and non-upgrade node"
                    return 2
                else
                    [ "${DEBUG}" ] && orc_log_script "Cluster ids differ, Oss and Sybase online, but unexecpted mc_start_list or llthosts values"
                    return 7
                fi
            else
                [ "${DEBUG}" ] && orc_log_script "Cluster ids differ but Oss and Sybase not both online"
                return 6
            fi
        else
            [ "${DEBUG}" ] && orc_log_script "Same cluster id but failed other checks"
            return 5
        
        fi
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return(100)"

    return 100

}

### Function: orc_log_file ###
#
# Logs Messages
# Should be used if reading input
# from file line by line and then
# writing output to screen or file
# Ignores blank lines
#
# Arguments     : $1 - Message
#
# Return Values : none
#
#*****************************
function orc_log_file()
{
  #******************
  # Timestamp message
  #******************
  if [[ -n "${1}" ]]
  then
      if [ "${DEBUG}" ]
      then
        L_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: (${FUNCNAME[1]}) ${1}"
      else
        L_LOG_MESS=" `${DATE} '+%Y-%m-%d-%H-%M-%S'`:: ${1}"
      fi
    #********************************
    # Ouput to log file and/or screen
    #********************************
    if [ "${LOGFILE}" ]
    then
        ${ECHO} "${L_LOG_MESS}" | ${TEE} -a ${LOGFILE}
    else
        ${ECHO} "${L_LOG_MESS}"
    fi
    ${ECHO}
  fi
}
######################################################################
# FUNCTION orc_check_status_file
#
# Gets the status (OK/NOK) reported in status file passed as arguement
#
# Input Parameters
# Status File
#
#
# Return codes:
# 0        Status OK
# 1        Status NOK
# 2        Status file not present
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
######################################################################
function orc_check_status_file
{
    local -i NUM_ARGS=0
    local -i RES=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    NUM_ARGS=$#

    if [ $NUM_ARGS -ne 1 ]
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

    STATUS_FILE=$1

    if orc_check_existence $STATUS_FILE
    then
        STATUS=$($CAT $STATUS_FILE |  $AWK '{print $1}')
        if [ "$STATUS" != 'OK' ]
        then
            orc_log_script "status reported from previous Orchestrator module is [NOK]"
            RES=1
        else
            orc_log_script "status reported from previous Orchestrator module is [OK]"
        fi
    else
        orc_log_script "ERROR: status file is not present, no record of previous Orchestrator module being executed"
        RES=2
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"

    return $RES
}

##########################################################################################
#@ DESCRIPTION: Wait for oss ossfs and sybase1 services to come up
#@ USAGE: orc_wait_for_sybase_oss_roles
#@ RETURNS 0 if all three roles come "ONLINE" before $TIMEOUT expires, otherwise return 1
##########################################################################################
function orc_wait_for_sybase_oss_roles
{
    test -n "${DEBUG}" && orc_log_script "Start Function: (${*})"

    local -i RES=0
    local THISHOST=`$UNAME -n`
    local -i TIMEOUT=1200
    local SYBASE1="Sybase1"
    local OSSFS="Ossfs"
    local OSS="Oss"
    
    #Check vcs is running
    if orc_wait_vcs_system_running "${THISHOST}" "${TIMEOUT}"
    then 
        orc_log_script "Waiting for ${SYBASE1}, ${OSSFS}, and ${OSS} services to come online. This could take several minutes."
        if ! orc_wait_vcs_service_online "${SYBASE1}" "${THISHOST}" "${TIMEOUT}"
        then
            RES=1
        fi
        if ! orc_wait_vcs_service_online "${OSSFS}" "${THISHOST}" "${TIMEOUT}"
        then
            RES=1
        fi
        if ! orc_wait_vcs_service_online "${OSS}" "${THISHOST}" "${TIMEOUT}"
        then
            RES=1
        fi  
    else
        orc_log_script "Could not wait for Sybase1, Oss and Ossfs to come online, VCS system is not running "
        RES=1
    fi
        
    test -n "${DEBUG}" && orc_log_script "End Function: return($RES)"

    return $RES

}

##########################################################################################
#@ DESCRIPTION: Uses the hagrp command to wait for a VCS service to come online
#@ USAGE: orc_wait_vcs_service_online
#@ param: $1 Group/service to wait for e.g. Sybase1, Oss, Ossfs
#@ param: $2 Host/system
#@ param: $3 timeout. Time to wait for service to come online
#@ RETURNS 0 if all group comes "ONLINE" before $TIMEOUT expires, otherwise return 1
##########################################################################################
function orc_wait_vcs_service_online
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    
    local -i NUM_ARGS=0
    local -i RES=0
    local HOST=""
    local -i TIMEOUT=0
    local SERVCE_GROUP=""

    NUM_ARGS=$#

    if [ $NUM_ARGS -ne 3 ]
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    
    SERVICE_GROUP=$1
    HOST=$2
    TIMEOUT=$3
    
    orc_log_script  "Waiting for service: ${SERVICE_GROUP} to come online."
    ${HAGRP} -wait ${SERVICE_GROUP} State ONLINE -sys ${HOST} -time ${TIMEOUT} >/dev/null 2&>1
    RES=$?
    if [ $RES -eq 0 ] 
    then
        orc_log_script "${SERVICE_GROUP} service is online."
    else
        orc_log_script "Error occurred (result=${RES}) while waiting for ${SERVICE_GROUP} service to come online."
        RES=1
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"
    return $RES
}

##########################################################################################
#@ DESCRIPTION: Uses the hasys command to wait for until VCS system is running on a 
#@ DESCRIPTION: particular host
#@ USAGE: orc_wait_vcs_system_running
#@ param: $1 Host/system
#@ param: $2 timeout. Time to wait for system to come online
#@ RETURNS 0 if all system comes online before timeout expires, 1 otherwise
##########################################################################################
function orc_wait_vcs_system_running
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    
    local -i NUM_ARGS=0
    local -i RES=0
    local HOST=""
    local -i TIMEOUT=0
    local VCS_STARTED=""
    local i NUM_ATTEMPTS=0
    local i SLEEP_INTERVAL=10
    local i COUNT=0
    
    NUM_ARGS=$#

    if [ $NUM_ARGS -ne 2 ]
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    
    HOST=$1
    TIMEOUT=$2
    
    if [ $TIMEOUT -gt $SLEEP_INTERVAL ]
    then
        NUM_ATTEMPTS=$((TIMEOUT/SLEEP_INTERVAL))
    else
        NUM_ATTEMPTS=1
    fi
    
    [ "${DEBUG}" ] && orc_log_script "Max number of times to check that VCS has started is: ${NUM_ATTEMPTS}"
    
    #Check & wait until the HAD - core VCS process has started
    #We can't issue ha commands successfully until this process has started
    until [ $($PGREP had | $WC -l) -ge 2 ] || [ $COUNT -ge $NUM_ATTEMPTS ]
    do
        [ "${DEBUG}" ] && orc_log_script "Waiting 10 seconds for VCS to start"
        sleep ${SLEEP_INTERVAL}
        ((COUNT++))
    done
    
    #If VCS system is not running then wait for it to come up
    if ! orc_check_vcs_system_running "${HOST}"
    then
        orc_log_script  "Waiting for VCS system to come online: "
        if ${HASYS} -wait ${HOST} SysState RUNNING -time ${TIMEOUT} >/dev/null 2&>1
        then
            orc_log_script "VCS system is running."
        else
            orc_log_script "Error occurred while waiting for VCS system to come online"
            RES=1
        fi
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"
    return $RES
}

######################################################################
# FUNCTION orc_check_previous_run
#
# Gets the status (OK/NOK) reported in status file passed as arguement
#
# Input Parameters
# Status File
#
#
# Return codes:
# 0        was a previous run
# 1        no previous run
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
######################################################################
function orc_check_previous_run
{
    local -i NUM_ARGS=0
    local -i RES=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    NUM_ARGS=$#

    if [ $NUM_ARGS -ne 1 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with invalid number of arguments, must be equal to zero"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi
	
    STATUS_FILE="$STATUS_DIR/.$1_status_file"

    if orc_check_existence $STATUS_FILE
    then
        STATUS=$($CAT $STATUS_FILE |  $AWK '{print $1}')
        orc_log_script "Status reported from previous run of $0 is \"$STATUS\"" 
		[ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
		return 0
    else 
        orc_log_script "Current module $0 has not been run before" 
		[ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
		return 1
    fi
}

######################################################################
# FUNCTION orc_remove_wrapper
#
# Removes the /orcha/.orc directory on a remote host.
#
# Input Parameters: None
#
# Return codes:
# 0        successful
# 1        failed
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
######################################################################
function orc_remove_wrapper()
{
    local -i NUM_FIXED_ARGS=$#
    local -i L_RES=0
    
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    ###############################
    # Requires "server hostname"
    ###############################
    
    if [ $NUM_FIXED_ARGS -ne 1 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with invalid number of arguments, must be equal to 2"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi
    
	local REMOTEHOST=$1
	
    [ "${DEBUG}" ] && orc_log_script "Executing $SSH $SSH_OPTS $1 \"rm -fr ${RAPPERDIR}\" command"  
		
    $SSH $SSH_OPTS $REMOTEHOST "rm -fr ${RAPPERDIR}" > /dev/null 2>&1

    L_RES=$?
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
    
   return $L_RES
}

######################################################################
# FUNCTION orc_exec_wrapper_command
#
# Executes a sudo "command" on a remote host.
#
# Input Parameters: None
#
# Return codes:
# 0        successful
# 1        failed
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
######################################################################
function orc_exec_wrapper_command()
{
    local -i NUM_FIXED_ARGS=$#
    local -i L_RES=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    ##############################################################################
    # Requires "server hostname" and "command" arguments
    ##############################################################################
    
    if [ $NUM_FIXED_ARGS -ne 2 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with invalid number of arguments, must be equal to 2"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi
    
	if [ "${DEBUG}" = "TRUE" ]
	then
		orc_log_script "Executing $SSH $SSH_OPTS $1 $SUDO $ORCRAPPER -d \"${2}\" command"  
		$SSH $SSH_OPTS $1 "$SUDO $ORCRAPPER -d \"${2}\""
	else
		$SSH $SSH_OPTS $1 "$SUDO $ORCRAPPER \"${2}\""
	fi

    L_RES=$?
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
    
   return $L_RES  
}

######################################################################
# FUNCTION orc_distribute_wrapper
#
# Distributes the orc lib and wrapper to the .orc directory
#
# Input Parameters: None
#
# Return codes:
# 0        successful
# 1        failed
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
######################################################################
function orc_distribute_wrapper
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    NUM_ARGS=$#

    if [ $NUM_ARGS -ne 1 ]
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 3
    fi

    local REMOTEHOST=$1
	local -i retVal
	
	#############################################
	# remove any existing /orcha/.orc directory #
	#############################################	
	# NOT CONCERNED WITH THE RETURN CODE        #
	#############################################

	orc_remove_wrapper $REMOTEHOST
	
	############################################
	# create a new /orcha/.orc directory
	############################################
	[ "${DEBUG}" ] && orc_log_script "Executing $SSH $SSH_OPTS $REMOTEHOST \"$MKDIR ${RAPPERDIR}\" command"  
		
	$SSH $SSH_OPTS $REMOTEHOST "$MKDIR ${RAPPERDIR}"
	retVal=$?
	if [ $retVal -ne 0 ]
	then
		if [ $retVal -eq 255 ]
		then
			[ "${DEBUG}" ] && orc_log_script "SSH error creating \"${RAPPERDIR}\" directory"
			orc_log_script "Check SSH key setup and, if required, run 'setup_orcha_user.bsh' to create the SSH keys for the orcha user on server $REMOTEHOST"
		else
			[ "${DEBUG}" ] && orc_log_script "Failed to create \"${RAPPERDIR}\" directory"
		fi
		[ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
		return 1		
	else
		[ "${DEBUG}" ] && orc_log_script "Successfully created \"${RAPPERDIR}\" directory"
	fi
	
	###############################################################
	# copy master orc_common_functions.lib to /orcha/.orc directory
	###############################################################
	[ "${DEBUG}" ] && orc_log_script "Executing $SCP $ORCLIB ${REMOTEHOST}:${RAPPERDIR}/ command"  

    $SCP $ORCLIB ${REMOTEHOST}:${RAPPERDIR}/ > /dev/null 2>&1
	retVal=$?
    if [ ${retVal} -eq 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script "Successfully copied \"$ORCLIB\" to \"$REMOTEHOST\""
    else
        [ "${DEBUG}" ] && orc_log_script "Failed to copy \"$ORCLIB\" to \"$REMOTEHOST\""
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

	###############################################################
	# copy orc_wrapper.bsh to the /orcha/.orc directory
	###############################################################
	[ "${DEBUG}" ] && orc_log_script "Executing $SCP $ORCWRAPPER ${REMOTEHOST}:${RAPPERDIR}/ command"  

    $SCP $ORCWRAPPER ${REMOTEHOST}:${RAPPERDIR}/ > /dev/null 2>&1
	retVal=$?
    if [ ${retVal} -eq 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script "Successfully copied \"$ORCWRAPPER\" to \"$REMOTEHOST\""
    else
        [ "${DEBUG}" ] && orc_log_script "Failed to copy \"$ORCWRAPPER\" to \"$REMOTEHOST\""
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: return(0)"

    return 0
}

######################################################################
# FUNCTION orc_write_mc_status_list
#
# Writes output of smtool list to named file
#
# Input Parameters: File to write to
#
# Return codes:
# 0        successful
# 1        failed
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
######################################################################
function orc_write_mc_status_list
{
    local -i NUM_FIXED_ARGS=$#
    local -i L_RES=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    ##############################################################################
    # Requires "filename" arguments
    ##############################################################################
    
    if [ $NUM_FIXED_ARGS -ne 1 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with invalid number of arguments, must be equal to 1"  

        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

    if [ -d $1 ]
    then
        orc_log_script "$1 is a directory, a file must be specified"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

    local L_DIR=`dirname $1`
    if [ ! -w ${L_DIR} ]
    then
        orc_log_script "Module does not have write permission to create $1"
        [ "${DEBUG}" ] && orc_log_script "End Function: return(1)"
        return 1
    fi

    $SU - nmsadm -c "$SMTOOL -list > $1 " > /dev/null 2>&1
    L_RES=$?
    if [ $L_RES -eq 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script "Successfully wrote MC status list"
    else
        [ "${DEBUG}" ] && orc_log_script "Failed to write MC status list"
    fi
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
    
   return $L_RES  
}

### Function: orc_wait_for_inprogress_MC_complete ###
#
# Waits until MCs that are in action to finish
#
# Arguments     : none
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_wait_for_inprogress_MC_complete
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    orc_log_script "Waiting for in-progress MCs to complete..."

    orc_spinner start

    # Check all services for in progress states
    local _smtool_print_="/tmp/orc_smtool_print_out"
    local L_CONTINUECHECK=0
    local L_INDEX=0
    # Sometimes can find no in progress for very short time, so keep count of
    # consecutive oks - and only exit if get 3 in a row
    local L_OKCOUNT=0
    while [ ${L_CONTINUECHECK} -eq 0 ]
    do
        $SU - nmsadm -c "${SMTOOL} -list"  > ${_smtool_print_}
        local RC=$?
        if [ $RC -ne 0 ]
        then
            orc_spinner stop
            orc_log_script "Failed to get MC status list [NOK]"
            [ "${DEBUG}" ] && orc_log_script "MC status returned $RC"
            [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
            return 1
        fi
        local L_INPROGRESS=$(${EGREP} -i "initializing\.\.\.|retrying\.\.\.|terminating\.\.\." ${_smtool_print_})
        if [ -z "${L_INPROGRESS}" ]
        then
            [ "${DEBUG}" ] && orc_log_script "No MCs in an in-progress state"
            let "L_OKINDEX = L_OKINDEX + 1"
            # Have seen some smtool lists report no in progress when there
            # are events queued, so only stop if get ok 3 times in row
            if [ ${L_OKINDEX} -lt 3 ]
            then
                sleep 2
            else
                L_CONTINUECHECK=1
            fi
        else
            L_OKINDEX=0
            [ "${DEBUG}" ] && orc_log_script "Found MCs in an in-progress state, so will retry later..."
            let "L_INDEX = L_INDEX + 1"
            if [ ${L_INDEX} -lt 360 ]
            then
                sleep 10
            else
                orc_spinner stop
                orc_log_script "Failed to wait for in-progress MCs to finish [NO
K]"
                [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
                return 1
            fi
        fi
    done
    orc_spinner stop
    orc_log_script "In-progress MCs completed [OK]"
    [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"
    return 0
}


### Function: orc_online_subset_mc
#
# Checks that all MCS in specified file are online. It onlines any found to be
# in offline state, and cold restarts any in failed state or unlicensed state
#
# Arguments     : Filename - containing list of MCs
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_online_subset_mc() {
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    local -i retVal
    local L_QUIET="n"
    unset OPTIND

    while getopts ":q" opt; do

        case ${opt} in

        q)      L_QUIET="y"
                ;;
        *)      ;;
        esac
    done

    shift $((OPTIND-1))

    if [ $# -ne 1 ]
    then
        orc_log_script  "ERROR: Invalid input '${@}' Unexpected number of arguments"
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi

    # Wait until any MCs that are being started/stopped have finished
    orc_wait_for_inprogress_MC_complete
	retVal=$?
    if [ ${retVal} -ne 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi

    local _temp_mc_list_=/tmp/orc_mc_start_list
    local _temp_mc_list_temp=/tmp/orc_mc_start_list_temp
    local _smtool_print_=/tmp/orc_smtool_print_out

    local _start_list=$1

    if [ ! -s ${_start_list} ]
    then
        orc_log_script "Failed to find ${_start_list} [NOK]"
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi

    # Remove MAF from start list for SPARC
    if [[ $ARCH_TYPE = "i386" ]]; then
        ${CP} ${_start_list} ${_temp_mc_list_}
    else        
        ${CP} ${_start_list} ${_temp_mc_list_temp}

        ${CAT} ${_temp_mc_list_temp} | ${GREP} -v MAF > ${_temp_mc_list_}

        ${RM} ${_temp_mc_list_temp}
    fi
	$SU - nmsadm -c "${SMTOOL} -list"  | ${EGREP} -i "failed|unlicensed|offline|initializing\.\.\.|retrying\.\.\.|terminating\.\.\.|stopped|restart scheduled|no ssr|started"  > ${_smtool_print_}
    retVal=$?	
    if [ ${retVal} -ne 0 ]
    then
        orc_log_script "Failed to get MC status list [NOK]"
        ${RM} ${_temp_mc_list_}
        ${RM} ${_smtool_print_}
        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
        return 1
    fi
    local L_ALLOK=0   # If 1, then got state we can attempt to restart
    local L_FAILED=0  # If 1, had state we don't know how to handle
    local L_ONLINEDMCS=""
    local L_RESTARTEDMCS=""

    # For each MC that is offline, online it, and cold-restart any in failed
    # state
    for L_MC in `cat ${_temp_mc_list_}`
    do
        local _mc_status_=`$GREP -w ${L_MC} ${_smtool_print_} | $NAWK '{print $2}'`
        if [[ ${_mc_status_} = "started" ]]
        then
            #Already started so no need to do anything
            [ "${L_QUIET}" = "n" ] && orc_log_script "${L_MC} is online [OK]"
        elif [[ ${_mc_status_} = "offline" ]]
        then
            orc_log_script "${L_MC} is offline, so attempting to online"
            $SU - nmsadm -c "${SMTOOL} -online ${L_MC} " > /dev/null 2>&1
            L_ALLOK=1
            L_ONLINEDMCS="${L_ONLINEDMCS} ${L_MC}"
        elif [[ ${_mc_status_} = "failed" ]] ||
             [[ ${_mc_status_} = "unlicensed" ]] 
        then
            orc_log_script "${L_MC} is ${_mc_status_}, so attempting to coldrestart"
            $SU - nmsadm -c "${SMTOOL} -coldrestart ${L_MC} -reason=other -reasontext="upgrade"" > /dev/null 2>&1
            L_ALLOK=1
            L_ONLINEDMCS="${L_ONLINEDMCS} ${L_MC}"
        else
            if [ "${_mc_status_}" = "" ]
            then
                orc_log_script "${L_MC} not found [NOK]"
            else
                orc_log_script "${L_MC} is in state ${_mc_status_} [NOK]"
            fi
            L_ALLOK=1
            L_FAILED=1
        fi
    done

    # If any of the MCs is not in online state...
    if [ ${L_ALLOK} -ne 0 ]
    then
        if [ ${L_FAILED} -eq 1 ]
        then
            # Got a state we didn't know what to do, so fail
            ${RM} ${_temp_mc_list_}
            ${RM} ${_smtool_print_}
            [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
            return 1
        fi
        orc_log_script "Some MCs were not online, waiting for online commands to complete"
        # We had to restart or online MCs, so wait and get new list
        sleep 20
        $SU - nmsadm -c "${SMTOOL} -list" > ${_smtool_print_}
		retVal=$?
        if [ ${retVal} -ne 0 ]
        then
            orc_log_script "Failed to get MC status list [NOK]"
            ${RM} ${_temp_mc_list_}
            ${RM} ${_smtool_print_}
            [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
            return 1
        fi
        L_ALLOK=0
        # Now check no in progress MCs 
        local L_TRYAGAIN=0
        L_COUNT=0
        while [ $L_TRYAGAIN -eq 0 ]
        do
            # Repeat test if in retrying... state
            L_TRYAGAIN=1
            local L_INPROGRESS=$(${EGREP} -i "initializing\.\.\.|retrying\.\.\.|terminating\.\.\." ${_smtool_print_})
            if [ -z "${L_INPROGRESS}" ]
            then
                [ "${DEBUG}" ] && orc_log_script "No MCs in an in-progress state"
            else
                L_TRYAGAIN=0
                if [ ${L_COUNT} -lt 60 ]
                then
                    orc_log_script "MCs in retrying or initializing state, so wait and repeat list..."
                    sleep 10
                    $SU - nmsadm -c "${SMTOOL} -list" | ${EGREP} -i "failed|unlicensed|offline|initializing\.\.\.|retrying\.\.\.|terminating\.\.\.|stopped|restart scheduled|no ssr|started" > ${_smtool_print_}
                    ((L_COUNT=L_COUNT+1))
                else 
                    L_TRYAGAIN=1
                fi
            fi
        done
        # Now check all onlined MCs are now online, this can take a while
        # so we will loop until all online or reached max loops
        local L_NUMLOOPS=${#L_ONLINEDMCS[@]}
        let "L_NUMLOOPS = L_NUMLOOPS * 3"
        local L_CONTINUECHECK=0
        local L_INDEX=0
        while [ ${L_CONTINUECHECK} -eq 0 ]
        do
            local tmp_mc=()
            for L_MC in ${L_ONLINEDMCS}
            do
                local _mc_status_=`$GREP -w ${L_MC} ${_smtool_print_} | $NAWK '{ print $2}'`
                if [[ ${_mc_status_} = "started" ]]
                then
                    orc_log_script "${L_MC} is online [OK]"
                else
                    tmp_mc+=(${L_MC})
                fi
            done
            L_ONLINEDMCS=( "${tmp_mc[@]}" )
            if [ ${#L_ONLINEDMCS[@]} -eq 0 ]
            then
                L_CONTINUECHECK=1
            else
                let "L_INDEX = L_INDEX + 1"
                if [ ${L_INDEX} -lt ${L_NUMLOOPS} ]
                then
                    [ "${DEBUG}" ] && orc_log_script "MCs not online, will retry check in 20secs..."
                    sleep 20
                    $SU - nmsadm -c "${SMTOOL} -list" | ${EGREP} -i "failed|unlicensed|offline|initializing\.\.\.|retrying\.\.\.|terminating\.\.\.|stopped|restart scheduled|no ssr|started" > ${_smtool_print_}
					retVal=$?
                    if [ ${retVal} -ne 0 ]
                    then
                        orc_log_script "Failed to get MC status list [NOK]"
                        ${RM} ${_temp_mc_list_}
                        ${RM} ${_smtool_print_}
                        [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
                        return 1
                    fi
                else
                    L_CONTINUECHECK=1
                fi
            fi
        done
        # Have finished our max wait time, so NOK any not in success state
        for L_MC in ${L_ONLINEDMCS}
        do
            local _mc_status_=`$GREP -w ${L_MC} ${_smtool_print_} | $NAWK '{print $2}'`
            if [[ ${_mc_status_} != "started" ]]
            then
                orc_log_script "${L_MC} is in state  ${_mc_status_} [NOK]"
                L_FAILED=1
            fi
        done
        if [ ${L_FAILED} -eq 1 ]
        then
            ${RM} ${_temp_mc_list_}
            ${RM} ${_smtool_print_}
            [ "${DEBUG}" ] && orc_log_script "End Function: return (1)"
            return 1
        fi
    fi
    ${RM} ${_temp_mc_list_}
    ${RM} ${_smtool_print_}
    [ "${DEBUG}" ] && orc_log_script "End Function: return (0)"
    return 0
}

### Function: orc_online_all_mc
#
# Checks that all all MCS are online. It onlines any found to be in
# offline state, and cold restarts any in failed state
#
# Arguments     : None
#
# Return Values : 0 - Successfull
#                 1 - Unsuccessfull
#
#******************************
function orc_online_all_mc() {

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    # Get all MCs
    local _temp_all_mc_list='/tmp/orc_mc_all_list'
    $SU - nmsadm -c "${SMTOOL} -list" | ${EGREP} -i "failed|unlicensed|offline|initializing\.\.\.|retrying\.\.\.|terminating\.\.\.|stopped|restart scheduled|no ssr|started" | $NAWK '{print $1}' > ${_temp_all_mc_list}
    local RC=${PIPESTATUS[0]}
    if [ $RC -eq 0 ]
    then
        orc_online_subset_mc ${_temp_all_mc_list}
        local RC=$?
        if [ $RC -ne 0 ]
        then
            orc_log_script "All MCs not online [NOK]"
        fi
    else
        orc_log_script "Failed to get list of MCs [NOK]"
    fi
    # Remove temporary file
    $RM ${_temp_all_mc_list}

    [ "${DEBUG}" ] && orc_log_script "End Function: return (${RC})"
    return ${RC}
}

### Function: orc_compare_files ###
#
# Compare files
#
# Arguments     : optional mode and two mandatory parameters.
#
# Return Values : 0 - If no error occurs, and there are no differences.
#                 1 - There are differences between the files.
#                -1 - If files don't exist
#
#********************************
function orc_compare_files
{
	declare -i total_mismatch=0
	declare -i mode=1
	local -i retVal

	[ "${DEBUG}" ] && orc_log_script "Start Function ${*}"

    unset OPTIND
    
    while getopts :m: opt; do
        case ${opt} in
        m)      orc_check_integer $OPTARG
		        retVal=$?
                if [ ${retVal} -ne 0 ]
                then
                    orc_log_script "ORC Internal Error: $FUNCNAME called and ${OPTARG} is not an integer"  
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
				mode=$OPTARG
                if [ $mode -ge 1 -a $mode -le 3 ]
                then
					[ $mode -eq 1 ] && orc_log_script "$FUNCNAME will show missing entries only"
					[ $mode -eq 2 ] && orc_log_script "$FUNCNAME will show matching entries only"
					[ $mode -eq 3 ] && orc_log_script "$FUNCNAME will show both matching and missing entries"
				else
                    orc_log_script "ORC Internal Error: $FUNCNAME called and ${mode} is not in a valid range (1-3)"  
                    [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
                    orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
                fi
                ;;
        esac
    done
	
	shift $((OPTIND-1))
	
	NUM_FIXED_ARGS=$#

	if [ $NUM_FIXED_ARGS -ne 2 ]
	then
		orc_log_script "ORC Internal Error: $FUNCNAME called with invalid arguments (${*})"  

		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi

	COMP_FILE_1=$1
	COMP_FILE_2=$2

	#*******************
	# Check existence
	#*******************
	orc_check_existence "$COMP_FILE_1"
    retVal=$?
	if [ ${retVal} -eq 1 ]
	then
		orc_log_script "ERROR: $COMP_FILE_1 does not exist"
		[ "${DEBUG}" ] && orc_log_script "End Function: return(-1)"
		return -1
	fi

	orc_check_existence "$COMP_FILE_2"
    retVal=$?
	if [ ${retVal} -eq 1 ]
	then
		orc_log_script "ERROR: $COMP_FILE_2 does not exist"
		[ "${DEBUG}" ] && orc_log_script "End Function: return(-1)"
		return -1
	fi
	
	declare -i total_f_1=$($WC -l $COMP_FILE_1 | $AWK '{print $1}')
	orc_log_script "There are $total_f_1 lines in file: $COMP_FILE_1"

	declare -i total_f_2=$($WC -l $COMP_FILE_2 | $AWK '{print $1}')
	orc_log_script "There are $total_f_2 lines in file: $COMP_FILE_2"
	
	#######################
	# run a quick diff
	#######################
	$DIFF $COMP_FILE_1 $COMP_FILE_2 > /dev/null 2>&1
    retVal=$?
	if [ ${retVal} -eq 0 ]
	then
		orc_log_script "There are no differences between $COMP_FILE_1 and $COMP_FILE_2"
		[ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
		return 0
	fi
	
	while read f_line_1
	do
		while read f_line_2
		do
			if [ "${f_line_1}" != "$f_line_2" ]
			then
				total_mismatch=$total_mismatch+1
			else
				$ECHO "\t$f_line_1" >> /tmp/matching-1.txt			
			fi
		done < $COMP_FILE_2	
		if [ $total_mismatch -eq $total_f_2 ]
		then
			$ECHO "\t$f_line_1" >> /tmp/missing-1.txt
		fi		
		total_mismatch=0
	done < $COMP_FILE_1	

	total_mismatch=0
	while read f_line_2
	do
		while read f_line_1
		do
			if [ "${f_line_2}" != "$f_line_1" ]
			then
				total_mismatch=$total_mismatch+1
			else
				$ECHO "\t$f_line_2" >> /tmp/matching-2.txt			
			fi
		done < $COMP_FILE_1	
		if [ $total_mismatch -eq $total_f_1 ]
		then
			$ECHO "\t$f_line_2" >> /tmp/missing-2.txt
		fi
		total_mismatch=0
	done < $COMP_FILE_2	

	if [ -f /tmp/matching-1.txt ]
	then
		if [ $mode -eq 2 -o $mode -eq 3 ]
		then
			orc_log_script "Found the following matching line(s) from file $COMP_FILE_1 in file $COMP_FILE_2"
			$CAT /tmp/matching-1.txt
			$ECHO
		fi
		$RM -f /tmp/matching-1.txt
	fi
	
	total_mismatch=0
	if [ -f /tmp/missing-1.txt ]
	then
		if [ $mode -eq 1 -o $mode -eq 3 ]
		then
			orc_log_script "The following line(s) from file $COMP_FILE_1 are missing from file $COMP_FILE_2"
			$CAT /tmp/missing-1.txt
			$ECHO
			total_mismatch=$total_mismatch+1
		fi
		$RM -f /tmp/missing-1.txt
	else
		orc_log_script "There are no lines in file $COMP_FILE_1 missing from file $COMP_FILE_2"
	fi

	if [ -f /tmp/matching-2.txt ]
	then
		if [ $mode -eq 2 -o $mode -eq 3 ]
		then
			orc_log_script "Found the following matching line(s) from file $COMP_FILE_2 in file $COMP_FILE_1"
			$CAT /tmp/matching-2.txt
			$ECHO
		fi
		$RM -f /tmp/matching-2.txt
	fi
	
	if [ -f /tmp/missing-2.txt ]
	then
		if [ $mode -eq 1 -o $mode -eq 3 ]
		then
			orc_log_script "The following line(s) from file $COMP_FILE_2 are missing from file $COMP_FILE_1"
			$CAT /tmp/missing-2.txt
			$ECHO
			total_mismatch=$total_mismatch+1
		fi
		$RM -f /tmp/missing-2.txt
	else
		orc_log_script "There are no lines in file $COMP_FILE_2 missing from file $COMP_FILE_1"
	fi
	
	#############################
	# Record the differences    #
	#############################
	if [ $total_mismatch -eq 0 ]
	then
		RES=0
	else
		RES=1
	fi
	
	[ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"

	return $RES
}

###########################################################################################################################
#@ DESCRIPTION: Checks if ARP is disabled on the public IP interface
#@ USAGE: orc_check_arp_disabled
#@ RETURNS: 0 if ARP disabled, 1 if not and 255 if we cannot determine the ARP state.
###########################################################################################################################
function orc_check_arp_disabled
{
 	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local -i L_RES=255
    local PUBNIC1_ARP=""
    local PUBNIC2_ARP=""
    local -i PUBNIC1_FOUND=255
    local -i PUBNIC2_FOUND=255
    
    #check existence of CLUSTER_INI
    if ! orc_check_existence $CLUSTER_INI
    then
        orc_log_script "$CLUSTER_INI required to check ARP status"
        L_RES=255
    else
        [ "${DEBUG}" ] && orc_log_script "$CLUSTER_INI"
        
        PUBNIC1=`awk -F= '$1 ~ /^pubNIC1$/{print $2; exit}' $CLUSTER_INI`
        test -n "$PUBNIC1"
        PUBNIC1_FOUND=$?
        PUBNIC2=`awk -F= '$1 ~ /^pubNIC2$/{print $2; exit}' $CLUSTER_INI`
        test -n "$PUBNIC2"
        PUBNIC2_FOUND=$?

        if [ $PUBNIC1_FOUND  -eq 0 ] && [ $PUBNIC2_FOUND  -eq 0 ]
        then
            [ "${DEBUG}" ] && orc_log_script "pubNIC1 and pubNIC2 found in $CLUSTER_INI file"
            
            PUBNIC1_ARP=$($IFCONFIG "${PUBNIC1}" | $GREP -i "NOARP")
            L_RES=$? 
            if [ $L_RES -eq 0 ] && [ -n "${PUBNIC1_ARP}" ]
            then
                [ "${DEBUG}" ] && orc_log_script "ARP is disabled on ${PUBNIC1}"
                
                PUBNIC2_ARP=$($IFCONFIG "${PUBNIC2}" | $GREP -i "NOARP")
                L_RES=$? 
                if [ $L_RES -eq 0 ] && [ -n "${PUBNIC2_ARP}" ]
                then
                    [ "${DEBUG}" ] && orc_log_script "ARP is disabled on ${PUBNIC2}"
                elif [ $L_RES -eq 1 ]
                then
                    [ "${DEBUG}" ] && orc_log_script "ARP is enabled on ${PUBNIC2}"
                    L_RES=1
                else
                    orc_log_script "Command to check if ARP is disabled on ${PUBNIC2} failed"
                    L_RES=255
                fi
            elif [ $L_RES -eq 1 ]
            then
                [ "${DEBUG}" ] && orc_log_script "ARP is enabled on ${PUBNIC1}"
                L_RES=1
            else
                orc_log_script "Command to check if ARP is disabled on ${PUBNIC1} failed"
                L_RES=255
            fi
 
        else
            orc_log_script "ERROR: Couldn't find pubNIC1 or pubNIC2 in $CLUSTER_INI"
            L_RES=255
        fi
    fi
    [ "${DEBUG}" ] && orc_log_script "End Function: ${L_RES}"

    return $L_RES
    
}


###############################################################################
# orc_contains_element
# Function to find if an array contains an element
# array=("something to search for" "a string" "test2000")
# orc_contains_element "a string" "${array[@]}"
#
# echo $?
# 0
#
###############################################################################

function orc_contains_element () {
  local e
  for e in "${@:2}"; do [[ "$e" == "$1" ]] && return 0; done
  return 1
}

######################################################################
# orc_check_if_remote_server_is_peer
#
# Confirms if a remote server is a Peer server
#
# Input Parameters
# $1     Server IP to check
#
# Return codes:
# 0             Peer
# 1             Not Peer
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
#####################################################################

function orc_check_if_remote_server_is_peer(){

	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
	local SERVER=$1
	local type
	local -i RC

	declare SSH_OPTS="-o PubkeyAuthentication=yes \
	-o KbdInteractiveAuthentication=no \
	-o PasswordAuthentication=no \
	-o ChallengeResponseAuthentication=no \
	-o LogLevel=quiet \
	-o StrictHostKeyChecking=no \
	-o HostbasedAuthentication=no \
	-o PreferredAuthentications=publickey"
	
	orc_check_remote_server_ssh_ok "${SERVER}"
	RC=$?
    if [ ${RC} -eq 0 ]
    then
		 type=$($SSH $SSH_OPTS root@$SERVER cat /ericsson/config/ericsson_use_config | awk -F= '{print $2}')
		 if [ "$type" == "peer" ]
		 then
			orc_log_script "${SERVER} confirmed as peer [OK]"
			RC=0
		 else
			orc_log_script "${SERVER} is not a peer server [NOK]"
			RC=1
		 fi
	else
        orc_log_script "Failed to connect to ${SERVER} to confirm if peer node [NOK]"
        RC=1
	[ "${DEBUG}" ] && orc_log_script "End Function: return(${RC})"
    fi 
    return $RC
}


######################################################################
# orc_reboot_remote_peer_servers
#
# Confirms if a remote server is a Peer server
#
# Input Parameters
# $@     List of servers to reboot
#
# Return codes:
# 0             Peer
# 1             Not Peer
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
#####################################################################

function orc_reboot_remote_peer_servers(){
[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local SERVER_LIST=$@
	local RC=0
	local -i retVal

declare ORC_DUMMY_TEST='test -d /tmp'

###############################################################################
# Options to be used with public key based session on remote server:
###############################################################################
declare SSH_OPTS="-o PubkeyAuthentication=yes \
-o KbdInteractiveAuthentication=no \
-o PasswordAuthentication=no \
-o ChallengeResponseAuthentication=no \
-o LogLevel=quiet \
-o StrictHostKeyChecking=no \
-o HostbasedAuthentication=no \
-o PreferredAuthentications=publickey"

S98PEERRC3TEXT='#!/bin/bash \n
case $1 in \n
start) \n
touch /tmp/.eric_server_starting_up \n
;; \n
stop) \n
;; \n
esac'
if [ -f /tmp/S98peerstartfile ]
then
orc_remove_file /tmp/S98peerstartfile
fi
$ECHO $S98PEERRC3TEXT >> /tmp/S98peerstartfile

    for L_HOST in ${SERVER_LIST}; do
        
        ####################################
        # check for root SSH keys
        ####################################

        $SSH $SSH_OPTS root@$L_HOST "${ORC_DUMMY_TEST}"
		RC=$?

        if [ $RC -eq 0 ]
        then
		    orc_check_if_remote_server_is_peer $L_HOST
			RC=$?
            if [ $RC -eq 0 ]
            then
                orc_log_script "Confirmed ${L_HOST} as a Peer"
            else
                orc_log_script "${L_HOST} is not a Peer.. exiting"
				#improve this logic as it could exit in the middle of a list..ie reboot some and then fail if wrong server type is given
                return 1 
            fi 
            $SSH $SSH_OPTS root@$L_HOST "touch /tmp/.eric_server_going_down"
            scp $SSH_OPTS /tmp/S98peerstartfile root@$L_HOST:/etc/rc3.d >/dev/null 2>&1
            retVal=$?			
            if [ ${retVal} -eq 0 ]
            then
                $SSH $SSH_OPTS root@$L_HOST "chmod 755 /etc/rc3.d/S98peerstartfile"
                $SSH $SSH_OPTS root@$L_HOST "init 6 >/dev/null 2>&1"
				retVal=$?
				if [ ${retVal} -eq 0 ]
				then
					orc_log_script "Rebooting ${L_HOST}......."
				fi
            fi
        else
        orc_log_script "No root SSH keys for remote host @$L_HOST"
        fi
    done

    orc_remove_file "/tmp/S98peerstartfile"
	
	local -i BOOTED_COUNT=0
	local -a BOOTED_LIST=()
	#need a timeout
	while [ "${#SERVER_LIST[@]}" -ne "$BOOTED_COUNT" ]
    do
        for L_HOST in ${SERVER_LIST}; do
		   if orc_contains_element "$L_HOST" "${BOOTED_LIST[@]}"
		   then
		       : #skip
		   else
			   orc_wait_for_server_reboot $L_HOST "/tmp/.eric_server_going_down" "/tmp/.eric_server_starting_up"
			   RS=$?
				if [ $RS -eq 0 ]
				then
					$SSH $SSH_OPTS root@$L_HOST "$RM -f /tmp/.eric_server_starting_up; $RM -f /etc/rc3.d/S98peerstartfile" > /dev/null 2>&1
					BOOTED_LIST+=($L_HOST)
					BOOTED_COUNT=$((BOOTED_COUNT+1))
				else
					:
				fi
			fi
        sleep 30 
       done 
    done	
	
	[ "${DEBUG}" ] && orc_log_script "End Function: return(0)"
	return 0
}

######################################################################
# orc_reboot_remote_server
#
#
#####################################################################

function orc_reboot_remote_server(){

   [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
   local INPUT_LIST=$@
   local SERVER
   local TYPE
   local RC=0
   local SSHRC=0
   local -i BOOTED_COUNT=0
   local -a SERVERLIST=()
   local -a BOOTING_LIST=()
   local -a BOOTED_LIST=()
   local START_TIME
   local DURATION
   local TIMEOUT=200 # 10 mins
   local -i retVal


 S98PEERRC3TEXT='#!/bin/bash \n
 case $1 in \n
 start) \n
 touch /tmp/.eric_server_starting_up \n
 ;; \n
 stop) \n
 ;; \n
 esac'
 

    #create the rc3 script which will be copied to the target server on reboot
    if [ -f /tmp/S98peerstartfile ]
    then
        orc_remove_file /tmp/S98peerstartfile
    fi
    $ECHO $S98PEERRC3TEXT >> /tmp/S98peerstartfile
  
   # Do Server Type checking (also checks SSH is working by default)
   for record in ${INPUT_LIST};do
       SERVER=$(echo ${record} | awk -F= '{ print $1 }')
       SERVERLIST+=( "$SERVER" )
       TYPE=$(echo ${record} | awk -F= '{ print $2 }')
       orc_log_script "Checking if ${SERVER} is of type $TYPE"
       orc_check_remote_server_type ${SERVER} "${TYPE}"
	   retVal=$?
       # RC=1 if any of the remote server type checks fails
       if [ ${retVal} -eq 0 -a $RC -eq 0 ]
       then
           RC=0
       else
           RC=2
       fi
    done


   #If all Server Type checking passes
   if  [ $RC -eq 0 ]
   then
       orc_log_script "Type checking of all servers was successfull"

       for SERVER in ${SERVERLIST}; do
           $SSH $SSH_OPTS root@$SERVER "touch /tmp/.eric_server_going_down"
           SSHRC=$?
           if [ "${SSHRC}" -ne 0 ]
          then
              [ "${DEBUG}" ] && orc_log_script "Could not create /tmp/.eric_server_going_down file on ${SERVER}"
              break
           fi
           $SCP $SSH_OPTS /tmp/S98peerstartfile root@$SERVER:/etc/rc3.d >/dev/null 2>&1
           SSHRC=$?
           if [ "${SSHRC}" -ne 0 ]
           then
              [ "${DEBUG}" ] && orc_log_script "Could not SCP /tmp/S98peerstartfile file to ${SERVER}"
              break
           fi
           $SSH $SSH_OPTS root@$SERVER "chmod 755 /etc/rc3.d/S98peerstartfile"
           SSHRC=$?
           if [ "${SSHRC}" -ne 0 ]
           then
              [ "${DEBUG}" ] && orc_log_script "Could not chmod /etc/rc3.d/S98peerstartfile on ${SERVER}"
              break
           fi
           #If we get this far we can safely say the server will be rebooted
           $SSH $SSH_OPTS root@$SERVER "init 6 >/dev/null 2>&1"
           SSHRC=$?
           if [ "${SSHRC}" -eq 0 ]
           then
               #BOOTING_LIST is a subset of the SERVERLIST that has executed a successful init 6
               BOOTING_LIST+=($SERVER)
               orc_log_script "Rebooting ${SERVER}......."
           fi
       done

       

       START_TIME=$SECONDS
       DURATION=$(( SECONDS - START_TIME ))

       #loop for checking if all the servers are back up ( keep trying this for 10 mins )
       #xyxy 
        while [ "${#BOOTING_LIST[@]}" -ne "${BOOTED_COUNT}" -a  "${DURATION}" -le "${TIMEOUT}" ] 
        do
        for SERVER in ${BOOTING_LIST}; do
           if orc_contains_element "$SERVER" "${BOOTED_LIST[@]}"
           then
               : # $SERVER is back up
           else
               orc_wait_for_server_reboot $SERVER "/tmp/.eric_server_going_down" "/tmp/.eric_server_starting_up"
               RC=$?
                if [ $RC -eq 0 ]
                then
                    $SSH $SSH_OPTS root@$SERVER "$RM -f /tmp/.eric_server_starting_up; $RM -f /etc/rc3.d/S98peerstartfile" > /dev/null 2>&1

                    BOOTED_LIST+=($SERVER)
                    BOOTED_COUNT=$((BOOTED_COUNT+1))
                fi
            fi
            # This condition stops the sleep if all servers have already been rebooted at this point
            if [ "${#BOOTING_LIST[@]}" -ne "$BOOTED_COUNT" ]
            then
                orc_spinner start
                orc_log_script "Waiting for 60 Seconds before checking if ${SERVER} is back up"
                sleep 60
                orc_spinner stop
                DURATION=$(( SECONDS - START_TIME ))
            fi
            done
        done
        # now report what servers were rebooted\not rebooted when the timeout expired
        if [ "$DURATION" -gt "$TIMEOUT" ]
        then
        orc_log_script "Function Timed Out"
            for serv in ${SERVERLIST};do
                if orc_contains_element "$serv" "${BOOTED_LIST[@]}"
                then
                    orc_log_script "${serv} was booted successfully"
                else
                    orc_log_script "${serv} was not booted successfully"
                fi
            done
            RC=255
        else
            for serv in ${SERVERLIST};do
                if orc_contains_element "$serv" "${BOOTED_LIST[@]}"
                then
                    orc_log_script "${serv} was booted successfully"
                else
                    orc_log_script "${serv} was not booted successfully. Init 6 was not executed"
                    RC=100
                fi
            done
            if [ "$RC" -eq 0 ]
            then
                orc_log_script "All servers were rebooted successfully"
            else
                orc_log_script "Not all servers were rebooted successfully"
            fi
        fi
   else
        orc_log_script "ERROR: Type checking of one or more servers failed"
        RC=2
   fi

   [ "${DEBUG}" ] && orc_log_script "End Function: (${RC})"

   return $RC
}


######################################################################
# FUNCTION orc_check_remote_server_type
# 
# Confirms the server type of the remote server over ssh
# 'ADMIN' 'EBAS' 'NEDSS' 'PEER' 'UAS' 'OM_SERVICES' 'OMSAS'
# are permissable types to check for
# 
# Input Parameters
# $1 Server
# $2 Server Type
#
# Return codes:
# 0        Server Type Confirmed
# 1        Server Type could not be confirms
#
#
# Output globals set by this function
# None
######################################################################

######################################################################
# FUNCTION orc_check_remote_server_type
# 
# Confirms the server type of the remote server over ssh
# 'ADMIN' 'EBAS' 'NEDSS' 'PEER' 'UAS' 'OM_SERVICES' 'OMSAS'
# are permissable types to check for
# 
# Input Parameters
# $1 Server
# $2 Server Type
#
# Return codes:
# 0        Server Type Confirmed
# 1        Server Type could not be confirms
#
#
# Output globals set by this function
# None
######################################################################

function orc_check_remote_server_type () {

	[ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

	local SERVER=$1
	local TYPE=$2
	local PARSED_SERVER_TYPE
	local -i RC
	local -1 retVal
	RC=0
    declare -a SERVERTYPES=('ADMIN' 'EBAS' 'NEDSS' 'PEER' 'UAS' 'OM_SERVICES' 'OMSAS' 'MWS')
    if orc_contains_element ${TYPE} "${SERVERTYPES[@]}"
	then
		[ "${DEBUG}" ] && orc_log_script "${TYPE} is a recognised server type"
		RC=0
		orc_check_remote_server_ssh_ok "${SERVER}"
		retVal=$?
		if [ ${retVal} -eq 0 ]
		then
			if [ "${TYPE}" == "MWS" ]
			then
				#local res=$($PKGINFO ${ERIC_JUMP_PKG} > /dev/null 2>&1)
				local res=$($SSH $SSH_OPTS root@$SERVER /usr/bin/pkginfo ERICjump > /dev/null 2>&1)
				if [ "$res" -eq "0"]
				then
					orc_log_script "SUCCESSFUL: Confirmed ${SERVER} as ${TYPE} server"
					RC=0
				else
					orc_log_script "UNSUCCESSFUL:  Could not confirm ${SERVER} as ${TYPE} serveR"
					RC=1
				fi	
			elif [ "${TYPE}" == "OMBS" ]
		    then	
				stype=$($SSH $SSH_OPTS root@$SERVER cat /ericsson/config/inst_type | awk '{print $1')
				[ "${DEBUG}" ] && orc_log_script " ${stype} value parsed from remote server /ericsson/config/inst_type"
				if [ "${stype}" == "ombs"]
				then
					orc_log_script "SUCCESSFUL: Confirmed ${SERVER} as ${TYPE} server"
					RC=0
				else
					orc_log_script "UNSUCCESSFUL: Could not confirm ${SERVER} as ${TYPE} server using ${stype} value"
					RC=1
				fi
			else
				stype=$($SSH $SSH_OPTS root@$SERVER cat /ericsson/config/ericsson_use_config | awk -F= '{print $2}')
				[ "${DEBUG}" ]  && orc_log_script " ${stype} value parsed from remote server /ericsson/config/ericsson_use_config"
			
				  case $stype in
				  system) PARSED_SERVER_TYPE="ADMIN"
						 ;;			  
				  ebas)  PARSED_SERVER_TYPE="EBAS"
						 ;;
				  smrs_slave) PARSED_SERVER_TYPE="NEDSS"
						 ;;
				  peer)  PARSED_SERVER_TYPE="PEER"
						 ;;
				  appserv) PARSED_SERVER_TYPE="UAS"
						 ;;
				  om_serv_master) PARSED_SERVER_TYPE="OM_SERVICES"
						 ;;
				  om_serv_slave)   PARSED_SERVER_TYPE="OM_SERVICES"
						 ;;
				  infra_omsas)  PARSED_SERVER_TYPE="OMSAS"
						 ;;
				  *) PARSED_SERVER_TYPE="UNKNOWN"
					 RC=1
						 ;;
				  esac
				  
				  if [  "${TYPE}" == "${PARSED_SERVER_TYPE}" ]
				  then
					  orc_log_script "SUCCESSFUL: Confirmed ${SERVER} as ${TYPE} server"
					  RC=0
				  else
					  orc_log_script "UNSUCCESSFUL: Could not confirm ${SERVER} as ${TYPE} server using ${stype} value"
					  RC=1
				  fi
			fi
	    else
			orc_log_script "Failed to connect to ${SERVER} to confirm server type"
			RC=1
		fi
	 else
		 [ "${DEBUG}" ] && orc_log_script "${TYPE} is not a recognised server type"
		 RC=1
	fi
	
	[ "${DEBUG}" ] && orc_log_script "End Function: (${RC})"

	return $RC		
}

##########################################################################################################################
#@ DESCRIPTION: Checks if a VCS resource exists
#@ USAGE: orc_check_vcs_resource_exists
#@ param: $1 Resource name
#@ param: $2 Host
#@ RETURNS: 0 if resource exists, 1 if not and 255 if we cannot determine.
###########################################################################################################################
function orc_check_vcs_resource_exists
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
    local HOST=""
    local RESOURCE_NAME=""
    local HARES_OUTPUT="/tmp/hares_tmp_output"

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 2 ]
    then
        orc_log_script "ORC Internal Error: $FUNCNAME called with invalid arguments (${*})"  

        [ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"

        orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
    fi

    RESOURCE_NAME=$1
    HOST=$2
    
    if $HARES -state "${RESOURCE_NAME}" -sys "${HOST}" > $HARES_OUTPUT 2>&1
    then
        [ "${DEBUG}" ] && orc_log_script "Resource ${RESOURCE_NAME} exists"
        RES=0
    else 
        if $GREP "Resource does not exist" $HARES_OUTPUT > /dev/null 2>&1
        then 
            [ "${DEBUG}" ] && orc_log_script "Resource ${RESOURCE_NAME} doesn't exist"
            RES=1
        else
            orc_log_script "ERROR: Couldn't determine if ${RESOURCE_NAME} exists"
            RES=255
        fi
    fi
    
    #Remove temporary output file
    orc_remove_file $HARES_OUTPUT
    
    [ "${DEBUG}" ] && orc_log_script "End Function: return($RES)"
    return $RES
}

######################################################################
# FUNCTION orc_check_service_status
#@ USAGE: orc_check_service_status <service name>
# Input Parameters
# none
#
# Return codes:
# 0        valid
# 1        invalid
#
######################################################################
function orc_check_service_status
{
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    local RC=0
    local L_SERVICENAME=""
    local SERVICE_DETAILS=""

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 1 ]
    then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi

    L_SERVICENAME=$1

    #Check service status
    SERVICE_DETAILS=`${SMTOOL} -list $L_SERVICENAME`
    local RET_VAL=$?

    if [ $RET_VAL -eq 0 ]
    then
        [ "${DEBUG}" ] && orc_log_script " $L_SERVICENAME reference found: ${SERVICE_DETAILS} "

        local SERVICE_STATUS=` ${ECHO} ${SERVICE_DETAILS} | ${AWK} '{print $2}'`

        [ "${DEBUG}" ] && orc_log_script "SERVICE_STATUS: $SERVICE_STATUS"

        if [ ${SERVICE_STATUS} == "started" ]
        then
            [ "${DEBUG}" ] && orc_log_script "$L_SERVICENAME started"
        else
            [ "${DEBUG}" ] && orc_log_script "$L_SERVICENAME not started. Status: ${SERVICE_STATUS}"
            RC=1
        fi

    else
        [ "${DEBUG}" ] && orc_log_script "NO $L_SERVICENAME reference found: ${SERVICE_DETAILS} "
        RC=1
    fi

    [ "${DEBUG}" ] && orc_log_script "End Function: return(${RC})"
    return $RC

}



######################################################################
# FUNCTION orc_create_ldap_proxy_password
#@ USAGE: orc_create_ldap_proxy_password <account> <password>
# Input Parameters: account and password combination
# none
#
# Return codes:
# 0        valid
# 1        invalid
#
######################################################################
function orc_create_ldap_proxy_password
{
    local RC=0
    local L_THISPASS=""

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 2 ]
    then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
        return 1
    fi

    L_THISACCOUNT=$1
    L_THISPASS=$2

    myOP=$( ${PWADMIN} -create LDAP NORMAL ${L_THISACCOUNT} -pw  ${L_THISPASS} 2>&1 )
    RC=${PIPESTATUS[0]}

    if [ "${myOP}" != "" ]
    then

        if [ -f ${LOGFILE} ]
        then
            $ECHO "${myOP}" >> "${LOGFILE}"
        fi
    fi

    if [ $RC -ne 0 ]
    then
        orc_log_script  "ERROR: ${PWADMIN} -create  failed: See Logfile for details"
    else
        orc_log_script  "INFO: ${PWADMIN} -create  Worked!!"
    fi


    [ "${DEBUG}" ] && orc_log_script "End Function: return(${RC})"
    return $RC

}

### Function: orc_check_tss_started ###
#
# Check if the TSSAuthorityMC is started
#
# Arguments     : None
#
# Return Values : 0 - Yes it has started
#                 1 - No it has not started
#
#****************************
function orc_check_tss_started
{
    local -i L_RES=0
	
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

    #############
	# OSS-55528 #
	#############
	#$SMTOOL list | $AWK '/TSSAuthorityMC/ {if ($2 = "started") { exit 0; } else { exit 1;} }'
	TSSstatus=$(su - nmsadm ${SMTOOL} list | ${GREP} -v grep | ${GREP} TSSAuthorityMC | ${AWK} '{print $2}')
	if [ "${TSSstatus}" = "started" ]
    then
	    L_RES=0
	else
	    L_RES=1
	fi

	[ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
	
	return $L_RES
}

### Function: orc_create_ldap_client ###
#
# Create account name with password
#
# Arguments     : $1 = account name
#                 $2 = password
#
# Return Values : 0 - OK
#                 1 - NOK
#
#****************************
function orc_create_ldap_client
{
    local -i L_RES=0
	
    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"
	NUM_FIXED_ARGS=$#

	if [ "$NUM_FIXED_ARGS" -ne "2" ]
	then
		orc_log_script "ORC Internal Error: $FUNCNAME called with incorrect arguments (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi		

	if [ -z "$1" ]; then
		orc_log_script "ORC Internal Error: $FUNCNAME called with empty account name argument (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi

	if [ -z "$2" ]; then
		orc_log_script "ORC Internal Error: $FUNCNAME called with empty password argument (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi
	
	$PWADMIN -create LDAP NORMAL $1 -pw $2
		
	L_RES=$?
	
	[ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
	
	return $L_RES
}

### Function: orc_update_ldap_client ###
#
# Update account name with password
#
# Arguments     : $1 = account name
#                 $2 = password
#
# Return Values : 0 - OK
#                 1 - NOK
#
#****************************
function orc_update_ldap_client
{
    local -i L_RES=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

	NUM_FIXED_ARGS=$#

	if [ "$NUM_FIXED_ARGS" -ne "2" ]
	then
		orc_log_script "ORC Internal Error: $FUNCNAME called with incorrect arguments (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi		

	if [ -z "$1" ]; then
		orc_log_script "ORC Internal Error: $FUNCNAME called with empty account name argument (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi

	if [ -z "$2" ]; then
		orc_log_script "ORC Internal Error: $FUNCNAME called with empty password argument (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi
	
	$PWADMIN -changePw LDAP NORMAL $1 -pw $2
		
	L_RES=$?
	
	[ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
	
	return $L_RES
}

### Function: orc_delete_ldap_client ###
#
# Delete LDAP client account
#
# Arguments     : LDAP client name
#
# Return Values : 0 - OK
#                 1 - NOK
#
#****************************
function orc_delete_ldap_client
{
    local -i L_RES=0

    [ "${DEBUG}" ] && orc_log_script "Start Function: (${*})"

	NUM_FIXED_ARGS=$#

	if [ "$NUM_FIXED_ARGS" -ne "1" ]
	then
		orc_log_script "ORC Internal Error: $FUNCNAME called with incorrect arguments (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi	

	if [ -z "$1" ]; then
		orc_log_script "ORC Internal Error: $FUNCNAME called with empty account name argument (${*})"  
		[ "${DEBUG}" ] && orc_log_script "End Function: orc_cleanup_and_exit(1)"
		orc_cleanup_and_exit 1 $ORC_INTERNAL_ERROR
	fi
	
	$PWADMIN -delete LDAP NORMAL $1
		
	L_RES=$?
	
	[ "${DEBUG}" ] && orc_log_script "End Function: return(${L_RES})"
	
	return $L_RES
}
######################################################################
# FUNCTION orc_update_ldap_proxy_password
#@ USAGE: orc_update_ldap_proxy_password <account> <password>
# Input Parameters: account and password combination
# none
#
# Return codes:
# 0        valid
# 1        invalid
#
######################################################################
function orc_update_ldap_proxy_password
{
    local RC=0
    local L_THISPASS=""

    NUM_FIXED_ARGS=$#

    if [ $NUM_FIXED_ARGS -ne 2 ]
    then
        orc_log_script  "ERROR: Invalid input ${@} Unexpected number of arguments"
		orc_log_script "USAGE: orc_update_ldap_proxy_password <account> <password>"
        return 1
    fi

    L_THISACCOUNT=$1
    L_THISPASS=$2

    myOP=$( ${PWADMIN} -changePw LDAP NORMAL ${L_THISACCOUNT} -pw  ${L_THISPASS} 2>&1 )

    RC=${PIPESTATUS[0]}

    if [ "${myOP}" != "" ]
    then

        if [ -f ${LOGFILE} ]
        then
            $ECHO "${myOP}" >> "${LOGFILE}"
        fi
    fi

    if [ $RC -ne 0 ]
    then
        orc_log_script  "ERROR: ${PWADMIN} -changePw  failed: See Logfile for details"
    else
        orc_log_script  "INFO: ${PWADMIN} -changePw  Worked!!"
    fi


    [ "${DEBUG}" ] && orc_log_script "End Function: return(${RC})"
    return $RC

}

#######################################################################################
# END ORC_COMMON FUNTIONS ORC_COMMON FUNTIONS ORC_COMMON FUNTIONS ORC_COMMON FUNTIONS
#######################################################################################
PORTPING_PL="/ericsson/ocs/bin/port_ping.pl"







