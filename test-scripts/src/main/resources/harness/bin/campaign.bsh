#!/bin/bash
#################################################################################
#
#
#       COPYRIGHT (C) ERICSSON RADIO SYSTEMS AB, Sweden
#
#       The copyright to the document(s) herein is the property of
#       Ericsson Radio Systems AB, Sweden.
#
#       The document(s) may be used and/or copied only with the written
#       permission from Ericsson Radio Systems AB or in accordance with
#       the terms and conditions stipulated in the agreement/contract
#       under which the document(s) have been supplied.
#
#################################################################################

# Infrastructure Test Campaign Script  

# Revision History
# 17/09/2013	v1.0	edavmax 

usage() {

${CAT} << EOF

Usage:  ${SCRIPTNAME} [-j <CI_jobnum>] [-h] 
		[-i "<CP_ID>"] 
		[-n <envfile>]
		[-f]

Run a test campaign.

-h	Print help.

-j <CI_jobnum>	
	When run from the CI server, the CI job number must be supplied.
	The number is used to label the harness report for CI collection.
	This option is not necessary for a local job, local job numbers
	are generated by the harness.


-i "<CP_ID>"
	Specifies the campaign to run by ID.

-f 
	continue to run the campaign even if the previous element (test case or test suite) failed.
	The default behaviour is to abort the campaign after the first element failure.
	

-n <envfile>
	specify env file containing environmental variables such as hardware details etc. These
 	variables can be accessed by the test cases. Env file path is relative to test harness root


EOF

	return 0

}

check_option_usage() {

	# -i and -n options are compulsory
	if [ ${option_i} -eq 0 ]; then
		printf "ERROR: Campaign ID must be specified\n"
		exit 1
	fi

	if [ $option_n -eq 1 ]; then
		if [ ! -s $ENVFILE ]; then
			printf "ERROR - specified env file \"$ENVFILE\" does not exist or is empty\n"
			exit 1
		fi
		export ENVFILE
	else
		printf "ERROR: env file must be specified\n"
		exit 1
	fi
	
	return 0
	
}
	
init_job_outputs() {

	# Create CI and LOCAL result dirs 
	ret=$(${MKDIR} -p ${RESULTS_ROOT}/ci; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${RESULTS_ROOT}/ci] failed; error [${ret}]\n"
		exit 1
	fi

	ret=$(${MKDIR} -p ${RESULTS_ROOT}/local; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${RESULTS_ROOT}/local] failed; error [${ret}]\n"
		exit 1
	fi

	# Create CI and LOCAL report dirs
	ret=$(${MKDIR} -p ${REPORTS_ROOT}/ci; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${REPORTS_ROOT}/ci] failed; error [${ret}]\n"
		exit 1
	fi
	
	ret=$(${MKDIR} -p ${REPORTS_ROOT}/local; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${REPORTS_ROOT}/local] failed; error [${ret}]\n"
		exit 1
	fi
	
	# If a CI job, supplied CI job number must be unique
	if [[ ${JOB_SCOPE} = "ci" ]]; then
		# Job number must not already exist
		if [[ -d ${RESULTS_ROOT}/ci/${AT_JOB} ]]; then
			printf "ERROR: CI job number [${AT_JOB}] already exists.\n"
			exit 1
		fi
	fi
	
	# If not a CI job, create a local job on the target server e.g for test automation callback development
	if [[ ${JOB_SCOPE} != "ci" ]]; then
		JOB_SCOPE=local
		# Get the next local job number
		AT_JOB=$[$(${LS} ${RESULTS_ROOT}/local | ${SORT} -rn | ${HEAD} -1) + 1]
		if ! expr ${AT_JOB} + 1 >/dev/null 2>&1; then
			printf "ERROR: Invalid local job number calculation [${AT_JOB}]. Job number must be an integer.\n"
			exit 1
		fi
		export AT_JOB
	fi
	
	# Set result and report paths for this job
	AT_RESULTS_DIR=${RESULTS_ROOT}/${JOB_SCOPE}/${AT_JOB}
	AT_REPORT_TXT=${AT_RESULTS_DIR}/campaign_results_job_${AT_JOB}.txt
	AT_SUMMARY=${AT_RESULTS_DIR}/campaign_summary_job_${AT_JOB}.txt
	AT_REPORT_HTML=${AT_RESULTS_DIR}/index.html
	AT_STATS_HTML=${AT_RESULTS_DIR}/stats.html
	
	AT_REPORT_DIR=${REPORTS_ROOT}/${JOB_SCOPE}
	AT_REPORT_ARCHIVE=${AT_REPORT_DIR}/${AT_JOB}_report.tar
	${RM} -f ${AT_REPORT_HTML}
	${RM} -f ${AT_REPORT_ARCHIVE}
	${RM} -f ${AT_REPORT_HTML}
	${RM} -f ${AT_STATS_HTML}
	
	AT_FA_STATS=${AT_RESULTS_DIR}/campaign_stats_fa_job_${AT_JOB}.txt
	AT_UC_STATS=${AT_RESULTS_DIR}/campaign_stats_uc_job_${AT_JOB}.txt
	
	# Create result dir for this job
	ret=$(${MKDIR} -p ${AT_RESULTS_DIR}; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${AT_RESULTS_DIR}] failed; error [${ret}]\n"
		exit 1
	fi
	
	# Create report dir for this job
	ret=$(${MKDIR} -p ${AT_REPORT_DIR}; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${AT_REPORT_DIR}] failed; error [${ret}]\n"
		exit 1
	fi
	
	# Remove any report that exists with this job number
	
	return 0
	
}
	
log_result() {

	local cp_id=$1
	local cp_result=$2
	local cp_remark=$3
	local datetime=$(date "+%Y-%m-%d %H:%M:%S")
	local count=0
	
	# Save CP stop time
	cp_stop_time=$(${PERL} -e 'print time."\n"')
	cp_duration=$(echo "scale=2; (${cp_stop_time}-${cp_start_time})" | ${BC})

	# print summary
	. $CP_RESULT_FILE
	while [ $count -lt ${#SPEC_CP_OBJ_IDS[@]} ]; do
	   	stage=$( expr $count + 1 )
		eval ele=\$CP_STAGE${stage}_ELEMENT
		eval slogan="\$CP_STAGE${stage}_SLOGAN"
		eval remark="\$CP_STAGE${stage}_REMARK"
		printf "STAGE:%2d %-10s %-30s %20s\n" $stage $ele "$slogan" "$remark" 
		let count+=1
	done
	
${CAT} >>${CP_RESULT_FILE} << EOF
# END DateTime: ${datetime}
	
CP_DURATION=${cp_duration} # seconds
CP_REMARK="${cp_remark}"
CP_RESULT="${cp_result}"
EOF
	
${CAT} >&3 << EOF
${datetime} DURATION: [${cp_duration}] seconds
${datetime} REMARK: [${cp_remark}]
${datetime} RESULT: [${cp_result}] 
${datetime} CONSOLE OUTPUT: [${CP_CONSOLE_FILE}] 
${datetime} END CP [${SPEC_CP_ID}] [${cp_result}]
	
EOF
	
	return 0
	
}

#
# Print out status of campaign stage
#
	
log_stage() {

	local stage=$1
	local ret=$2
	local element=$3
	local slogan=$4
	local remark=$5
	local datetime=$(date "+%Y-%m-%d %H:%M:%S")

	[ -z "$slogan" ] && slogan=$element

	printf "CP_STAGE${stage}_RETCODE=${ret}\n" >> ${CP_RESULT_FILE}
	printf "CP_STAGE${stage}_ELEMENT=${element}\n" >> ${CP_RESULT_FILE}
	printf "CP_STAGE${stage}_SLOGAN=${slogan}\n" >> ${CP_RESULT_FILE}
	printf "CP_STAGE${stage}_REMARK=${remark}\n" >> ${CP_RESULT_FILE}
	
	
	return 0

}

init_CP() {

	local cp_id=$1
	local cp_spec=$2
	local cp_result_dir
	local datetime=$(date "+%Y-%m-%d %H:%M:%S")
	
	init_cp_spec
	
	if ! . ${cp_spec}; then
		printf "ERROR: Failed to source campaign spec [${cp_spec}]\n"
		return 1
	fi
	
	# Validate TC ID
	if [[ ${cp_id} != ${SPEC_CP_ID} ]]; then
		printf "ERROR: CP_ID [${cp_id}] not same as ID [${SPEC_CP_ID}] in campaign spec file [${cp_spec}]\n"
		return 1
	fi

	# check the same number of elements in objects and hosts arrays
	if [ ${#SPEC_CP_OBJ_IDS[@]} -eq 0 ]; then
		printf "ERROR: CP_ID [${cp_id}] : zero elements in object id or hosts arrays\n"
		return 1
	fi

	CP_RESULT_DIR=${AT_RESULTS_DIR}/${SPEC_CP_NAME}
	CP_RESULT_FILE=${CP_RESULT_DIR}/${cp_id}_result.bsh
	CP_CONSOLE_FILE=${CP_RESULT_DIR}/${cp_id}_console.txt
	export CP_CONSOLE_FILE
	
	# Create results hierarchy if necesary
	if [[ ! -d ${CP_RESULT_DIR} ]]; then
		ret=$(${MKDIR} -p ${CP_RESULT_DIR}; echo $?)
		if [[ ${ret} -ne 0 ]]; then
			printf "ERROR: [${MKDIR} -p ${CP_RESULT_DIR}] failed; error [${ret}]\n"
			exit 1
		fi
	fi
	
	${RM} -f ${CP_CONSOLE_FILE}
	${RM} -f ${CP_RESULT_FILE}
	${TOUCH} ${CP_CONSOLE_FILE}
	
	# Save CP start time
	cp_start_time=$(${PERL} -e 'print time."\n"')

	# build test harness
	build_test_harness || return 1
	
	# Start the result file
	printf "#!/bin/bash\n" > ${CP_RESULT_FILE}
	printf "AT_JOB=${AT_JOB}\n" >> ${CP_RESULT_FILE}
	${GREP} "^SPEC_CP" ${cp_spec} >> ${CP_RESULT_FILE}
	printf "\n# BEGIN DateTime: ${datetime}\n" >> ${CP_RESULT_FILE}
	
	return 0
	
}

#
# Set env variables
#

set_env_vars() {
	local l_stage=$1
	local l_stage_vars=$( env | egrep "^CP_STG${l_stage}" )
	for var in $l_stage_vars; do
		varname=$( echo $var | awk -F= '{print $1}' )
		varval=$( echo $var | awk -F= '{print $2}' )
		req_varname=${varname#CP_STG${l_stage}_}
		eval export $req_varname=$varval
	done
}

set_env_vars_opt2() {
	local l_ele=$1
	local l_count=0 
	local l_varname_varname
	local l_value_varname

	local l_array_size_varname=EXPORT${l_ele}_VARNAMES[@]

	while [ $l_count -lt $( eval echo \${#${l_array_size_varname}} ) ]; do
		l_varname_varname=EXPORT${l_ele}_VARNAMES[$l_count]
		l_value_varname=EXPORT${l_ele}_VALUES[$l_count]
#eval echo \${$l_value_varname}
		eval export \${$l_varname_varname}=\"\${$l_value_varname}\"
		let l_count+=1
	done




}
	
#
# Run campaign elements
#

timeouter() {

	timeout=$1
	command=$2
	
	declare -i cmd_pid
	declare -i retry=1
	declare -i sleep_pid
	declare -i sleep_ppid
	declare -i cmd_status
	
	eval "(${command}) &"
	cmd_pid=$!
	
	# Sleep in subshell that kills command after sleep
	( sleep ${timeout} && kill -TERM ${cmd_pid} ) &
	sleep_ppid=$!
	while [[ ${retry} -le 3 ]]; do 
		sleep_pid=$(ps -ef | ${AWK} '($3 ~ "'"^${sleep_ppid}$"'") { print $2; }')
		#echo "sleep: ${sleep_pid}"
		[[ ${sleep_pid} -ne 0 ]] && break
		sleep 1
		retry=$[${retry}+1]
	done
	
	wait ${cmd_pid} 
	cmd_status=$?
	[[ ${cmd_status} -eq 143 ]] && return 143
	
	disown ${sleep_ppid} >/dev/null 2>&1
	kill -9 ${sleep_ppid} >/dev/null 2>&1
	
	if [[ ${sleep_pid} -ne 0 ]]; then
		disown ${sleep_pid} >/dev/null 2>&1
		kill -9 ${sleep_pid} >/dev/null 2>&1
	fi
	
	return ${cmd_status}

}

run_CP() {

	local cp_id=$1
	local cp_unique
	local cp_path
	declare -i ret
	declare -i cp_tee_pid
	local remark=
	local datetime
	local code
	
	# Locate CP, check for unique CP_ID 
	cp_unique=$(${FIND} ${CP_ROOT} -type d -name "${cp_id}" | ${WC} -l)
	cp_unique=$(echo ${cp_unique})
	
	case ${cp_unique} in
	
	0)	printf "ERROR: Failed to locate a campaign with CP_ID [${cp_id}]\n"
		exit 1
		;;
	
	1)	cp_path=$(${FIND} ${CP_ROOT} -type d -name "${cp_id}")
		cp_spec=${cp_path}/${cp_id}_spec.bsh
		;;
	
	*)	printf "ERROR: CP_ID [${cp_id}] is not unique.\n"
		${FIND} ${CP_ROOT} -type d -name "${cp_id}"
		exit 1
		;;
	esac
	
	# Save stdout, stderr descriptors 
	exec 3>&1 4>&2
	
	# Check CP spec exists
	if [[ ! -f ${cp_spec} ]]; then
		printf "ERROR: Failed to locate campaign spec [${cp_spec}]\n"
		exit 1
	fi
	
	# Source the test spec file and set CP result paths
	init_CP ${cp_id} ${cp_spec} || return 1
	
	# From this point on a CP is considered valid and appears in the report
	
	datetime=$(date "+%Y-%m-%d %H:%M:%S")
${CAT} << EOF
${datetime} BEGIN CP [${SPEC_CP_ID}]
${datetime} DESC: [${SPEC_CP_DESC}]
${datetime} SPEC FILE: [${cp_spec}]
EOF
	
	# Create pipe for campaign
	cp_tee_fifo=${cp_path}/${cp_id}.fifo
	if [[ ! -e ${cp_tee_fifo} ]]; then
		ret=$(mkfifo ${cp_tee_fifo}; echo $?)
		if [[ ${ret} -ne 0 ]]; then
			log_result ${cp_id} ${CODE_NOT_RUN} "Harness error"
			exit 1
		fi
	fi
	
	# Change to CP directory
	cd ${cp_path}
	
	# Start CP tee in background, tee reads from pipe and writes to both CP console file and screen
	
	# Save stdout, stderr descriptors 
	exec 3>&1 4>&2
	
	${TEE} -a ${CP_CONSOLE_FILE} < ${cp_tee_fifo} >&3 &
	
	# Save CP tee PID
	cp_tee_pid=$!
	
	# Redirect stdout, stderr to CP console pipe
	exec > ${cp_tee_fifo} 2>&1
	
	
	# Run the campaign
	let l_count=0
	SKIP_STG_USE_PREVIOUS_RESULTS=0
	while [ $l_count -lt ${#SPEC_CP_OBJ_IDS[@]} ]; do
		stage=$( expr $l_count + 1)
		skip_stage=FALSE
		suite_args=
		tc_args=
		cmd_args=
		unset G_HARNESS_HOST
		unset G_HARNESS_HOST_ROOTPW
		case "${SPEC_CP_OBJ_IDS[$l_count]}" in
			TS*)
				# Get TS NAME from TS ID
				ts_id=${SPEC_CP_OBJ_IDS[$l_count]#TS}
				if [ -s $TS_ROOT/$ts_id/${ts_id}_spec.bsh ]; then 
					ts_name=$( grep "^SPEC_TS_NAME=" $TS_ROOT/$ts_id/${ts_id}_spec.bsh | awk -F= '{ print $2 }' )
				else
					handle_cp_error "unable to find test suite with id \"$ts_id\"\n" || return 1
				fi
				if [ -n "$ts_name" ]; then
					slogan=$ts_name
					cmd_args="-S -s \"$ts_name\""
				else
					handle_cp_error "unable to find test suite name corresponding to id \"$ts_id\"\n" || return 1
				fi
				;;
			TC*)
				tc_id=${SPEC_CP_OBJ_IDS[$l_count]#TC}
				tc_path=$(${FIND} ${FA_ROOT} -type d -name "${tc_id}")
				
				# get TC slogan from TC ID
				if [ -s $tc_path/${tc_id}_spec.bsh ]; then 
					tc_slogan=$( grep "^SPEC_TC_SLOGAN=" $tc_path/${tc_id}_spec.bsh | awk -F= '{ print $2 }' )
				else
					handle_cp_error "unable to find test case with id \"$tc_id\"\n" || return 1
				fi
				if [ -n "$tc_slogan" ]; then
					slogan=$tc_slogan
					cmd_args="-S -i \"$tc_id\""
				else
					handle_cp_error "unable to find test case slogan corresponding to id \"$tc_id\"\n" || return 1
				fi
				;;
			UC*)
				uc_name=${SPEC_CP_OBJ_IDS[$l_count]#UC}
				uc_path=$(${FIND} ${FA_ROOT} -type d -name "${uc_name}")
				if [  -d "$uc_path"  ]; then 
					cmd_args="-S -u $uc_name"
				else
					handle_cp_error "usecase \"$uc_name\" does not exist on file system. Check name and check UC has associated automated TCs" || return 1
				fi
				;;
			*)
				handle_cp_error "skipping unrecognised campaign element \"${SPEC_CP_OBJ_IDS[$l_count]}\"\n" || return 1
				;;
		esac
		if echo "$CP_SKIP_STAGES" | grep -w $stage > /dev/null; then
			skip_stage=TRUE
			echo "STAGE ${stage} SKIP"
			bashBanner "STG${stage} SKIP"
			if [ "$SKIP_STG_USE_PREVIOUS_RESULTS" -eq 1 ]; then
				num_cp_result_dirs=$( ls -lrt $RESULTS_ROOT/$JOB_SCOPE | wc -l  )
				if [ "$num_cp_result_dirs" -lt 2 ]; then
					echo "Warning - appears campaign not run before on this host - not possible to re-use stage results"
				else
					set -x
					if [ -z "$WORKSPACE" ]; then
						prev_cp_report_dir=$( ls -lrt $RESULTS_ROOT/$JOB_SCOPE  | tail -2 | head -1 | awk '{  print $9 }')
						prev_cp_report_path=$RESULTS_ROOT/$JOB_SCOPE/$prev_cp_report_dir
					else
						prev_build_id=$( ls -lrt $WORKSPACE | tail -2 | head -1 | awk '{  print $9 }' )
						prev_cp_report_path=$WORKSPACE/$prev_build_id/results/$prev_build_id
					fi

					if [ -d $prev_cp_report_path/$SPEC_CP_NAME/${SPEC_CP_OBJ_IDS[$l_count]}_${stage} ]; then
						echo "stage $stage is skipped so using results from previous run" 
						cp -rp $prev_cp_report_path/$SPEC_CP_NAME/${SPEC_CP_OBJ_IDS[$l_count]}_${stage} $CP_RESULT_DIR || {
							handle_cp_error "failed to copy previous run stage $stage results" || return 1
						}
					else
						handle_cp_error "failed to copy previous run stage $stage results" || return 1
					fi
					set +x
					if [ -s $prev_cp_report_path/$SPEC_CP_NAME/${CP_ID}_result.bsh ]; then
						remark=$( grep CP_STAGE${stage}_REMARK $prev_cp_report_path/$SPEC_CP_NAME/${CP_ID}_result.bsh  | awk -F= '{print $2}' )
						ret=$( grep CP_STAGE${stage}_RETCODE $prev_cp_report_path/$SPEC_CP_NAME/${CP_ID}_result.bsh | awk -F= '{print $2}' )
					else
						echo "Warning - Unable to find previous stage run results file" 
					 	remark=UNKNOWN
						cmd_ret=99
					fi
					
				fi
			else
				remark=SKIPPED
				cmd_ret=99
			fi
			
		else
			echo "STAGE: $stage"	
			bashBanner "STAGE${stage}"
			set_env_vars $stage 
			if [ -z "$G_HARNESS_HOST" ]; then
				echo "harness host not specified for stage $stage - assuming localhost" 
				export G_HARNESS_HOST=localhost
			fi
			if [ "$G_HARNESS_HOST" != localhost ]; then
				resolve_harness_host || { 
					handle_cp_error "Error resolving harness host \"$G_HARNESS_HOST\"" || return 1
				}
				get_harness_host_rootpw || {
					handle_cp_error "Error getting root passwd for harness host \"$G_HARNESS_HOST\"" || return 1
				}
			fi
			echo "Harness host for stage $stage: $G_HARNESS_HOST"
			if [ "$G_HARNESS_HOST" = localhost ]; then
				cmd="$LOCAL_AT_HARNESS_SCRIPT $cmd_args -n $ENVFILE -S"
			else
				ssh_varlist=
				for var in CI_FQ_SHIPMENT CI_OMFQ_SHIPMENT CI_TYPE CI_TEAM USER_VAR1 USER_VAR2; do
                			ssh_varlist="$ssh_varlist $var=$( eval echo \$$var)"
        			done
	
				copy_test_harness_remote $G_HARNESS_HOST $G_HARNESS_HOST_ROOTPW || {
					handle_cp_error "unable to copy test harness to target host" || return 1
				}
					
				remote_envfile=${REMOTE_TAF_LOCATION}/${ENVFILE##$AT_ROOT}
				cmd="$EXPECT $AT_BIN/ssh_setup2.sh ssh \"root@$G_HARNESS_HOST $ssh_varlist $REMOTE_AT_HARNESS_SCRIPT $cmd_args -n $remote_envfile -S\" $G_HARNESS_HOST_ROOTPW"
			fi
			echo "Running command $cmd"
			timeouter ${SPEC_CP_TIMEOUT} "${cmd}"
			cmd_ret=$?
	
			if [[ ${cmd_ret} -ne 0 ]]; then
				remark="FAILURE"
                                let AT_NUM_FAILED_STAGES+=1
				[[ ${cmd_ret} -eq 143 ]] && remark="FAILURE due to timeout"
			else
				remark="SUCCESS"
			fi
			# copy stage results/reports to campaign directory
			echo "Copying results and reports for stage $stage"
			latest_report_file=$( sed 's///g' $CP_CONSOLE_FILE |  grep "Report archive:" | tail -1 | awk -F: '{ print $2 }' | sed 's/[ ]*//g' )
			latest_report_file=${latest_report_file}.gz
			if [ -z $latest_report_file ]; then
				handle_cp_error "unable to determine stage $stage report file $latest_report_file" || return 1
			fi 
			echo "Report file for stage $stage: $latest_report_file"
			if [ "$G_HARNESS_HOST" != localhost ]; then
				latest_report_filen=$( basename $latest_report_file )
				$EXPECT $AT_BIN/ssh_setup2.sh scp "-rp root@$G_HARNESS_HOST:$latest_report_file $CP_RESULT_DIR" $G_HARNESS_HOST_ROOTPW > /dev/null 2>&1 || {
					handle_cp_error "failed to copy stage $stage report file on host $G_HARNESS_HOST to campaign report dir" || return 1
				}
				latest_report_file=$CP_RESULT_DIR/$latest_report_filen
			fi
				
			if [ ! -f $latest_report_file ]; then
				handle_cp_error "unable to locate stage $stage report file $latest_report_file" || return 1
			fi 
			latest_report_dir=$( echo $( basename $latest_report_file ) | awk -F_ '{ print $1 }' ) 
			pushd . > /dev/null
			cd $CP_RESULT_DIR
			gunzip -c $latest_report_file | tar xvf - > /dev/null || {
				handle_cp_error "failed to unpack $ATCOMINF_REPORTS_ROOT/$JOB_SCOPE/$latest_report_file" || return 1
				return 1
			}
			mv -f $latest_report_dir ${SPEC_CP_OBJ_IDS[$l_count]}_stage${stage} || {
				handle_cp_error "failed to copy stage $stage results to campaign dir" || return 1
				return 1
			} 
			popd > /dev/null
			if [[ $cmd_ret -ne 0 && "$SPEC_CP_CONTINUEONFAILURE" -eq 0 ]]; then
				handle_cp_error "stage $stage failed - aborting campaign"
				return 1
			fi
		fi
		log_stage $stage $cmd_ret ${SPEC_CP_OBJ_IDS[$l_count]} "$slogan" "$remark"
		let l_count+=1
	done
	
	if [[ ${AT_NUM_FAILED_STAGES} -eq 0 ]]; then
		# All campaign elements passed - Campaign passed
		overall_remark="SUCCESS"
	else
		overall_remark="FAILURE - one or more campaign stages failed"
	fi
	
	log_result ${cp_id} ${code} "${overall_remark}" 
	
	# Redirect stdout, stderr to screen and close duplicates
	exec 1>&3 2>&4 3>&- 4>&-
	
	# Wait for tee to exit
	wait ${cp_tee_pid}
	
	# Remove CP tee pipe
	${RM} -f ${cp_tee_fifo}
	
	# Change to harness bin dir
	cd ${AT_BIN}
	
	
}

handle_cp_error() {
	errortxt=$1
	echo "Error - campaign element ${SPEC_CP_OBJ_IDS[$l_count]} - $errortxt"
	remark="FAILURE"
	[ -z "$cmd_ret" ] && cmd_ret=1
	let AT_NUM_FAILED_STAGES+=1
	log_stage $stage $cmd_ret ${SPEC_CP_OBJ_IDS[$l_count]} "$slogan" "$remark"
	if [ "$SPEC_CP_CONTINUEONFAILURE" -eq 0 ]; then
		echo "Aborting campaign since SPEC_CP_CONTINUEONFAILURE=0"
		let l_count+=1
		while [ $l_count -lt ${#SPEC_CP_OBJ_IDS[@]} ]; do
			stage=$( expr $l_count + 1)
			remark=SKIPPED
			log_stage $stage 99 ${SPEC_CP_OBJ_IDS[$l_count]} "$slogan" "$remark"
			let l_count+=1
		done
		return 1
	else
		let l_count+=1
		continue
	fi


}


#
# Function to create test harness tarball
#

build_test_harness() {
	local l_count=0
	TMP_HARNESS_TAR_DIR=$AT_RESULTS_DIR
	HARNESS_TARFILE=$TMP_HARNESS_TAR_DIR/$HARNESS_TARFILENAME
	HARNESS_TGZFILE=$TMP_HARNESS_TAR_DIR/${HARNESS_TARFILENAME}.gz

        printf "Building test harness tar file $HARNESS_TGZFILE\n"
	if [ ! -d ${TMP_HARNESS_TAR_DIR} ]; then
        	mkdir -p ${TMP_HARNESS_TAR_DIR} || {
                	printf "Error -  failed to create directory ${TMP_HARNESS_TAR_DIR}\n"
                	return 1
        	}
	fi
        # if the build script returns false or tarfile does not exist then report error and exit.
        pushd . > /dev/null
        cd $AT_ROOT
        tar cvf $HARNESS_TARFILE . > /dev/null &&
        gzip -f $HARNESS_TARFILE
        ret=$?
        popd . > /dev/null
        if [[ $ret -ne 0 || ! -s ${HARNESS_TGZFILE} ]]; then
		echo "Error - failed to create ${HARNESS_TGZFILE}"
		return 1
        fi
        return 0
}

#
# Function to resolve harness host expressed as CI_SERVER_HOSTNAME[N] or
# to actual hostname 
#

resolve_harness_host() {
	if [ -z "$G_HARNESS_HOST" ]; then
		echo "Error - G_HARNESS_HOST variable is blank or not set"
		return 1
	fi

        if [[ "$G_HARNESS_HOST" =~ CI_SERVER_HOSTNAME\[[0-9]+\] ]]; then
                hostname=$(eval echo \${$G_HARNESS_HOST})
                [ -z "$hostname" ] && {
                        echo "Error - $G_HARNESS_HOST does not resolve to host in env file"
                        return 1
                }
                local l_count=0
                while [ $l_count -lt ${#CI_SERVER_IP[@]} ]; do
                        if [ "$hostname" = "${CI_SERVER_HOSTNAME[$l_count]}" ]; then
                                G_HARNESS_HOST=${CI_SERVER_IP[$l_count]}
                                break
                        fi
                let l_count+=1
                done
        fi
}

# function to get root pw of harness host

get_harness_host_rootpw() {
        local l_count=0
        G_HARNESS_HOST_ROOTPW=""
        while [ $l_count -lt ${#CI_SERVER_IP[@]} ]; do
                if [ "${CI_SERVER_IP[$l_count]}" = "$G_HARNESS_HOST" ]; then
                        G_HARNESS_HOST_ROOTPW=${CI_SERVER_ROOTPW[$l_count]}
                        break
                fi
                let l_count+=1
        done
        [ -z "$G_HARNESS_HOST_ROOTPW" ] && {
                return 1
        }
        return 0

}


#
# Copy test harness to remove server
#
copy_test_harness_remote() {
	local l_remote_ip=$1
	local l_remote_rootpw=$2
	if [ -z "$l_remote_ip" ]; then
		echo "Error - $FUNCNAME - remote ip not specified"
		return 1
	fi
	if [ -z "$l_remote_rootpw" ]; then
		echo "Error - $FUNCNAME - remote root passwd not specified"
		return 1
	fi
	if [ ! -s "$HARNESS_TGZFILE" ]; then
		echo "Error - test harness tgz file $HARNESS_TGZFILE does not exist"
		return 1
	fi
	#$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$l_remote_ip test -d /var/tmp/platform_taf" $l_remote_rootpw > /dev/null 2>&1
		echo "Installing test harness on remote server $l_remote_ip"
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$l_remote_ip /bin/rm -f /var/tmp/$HARNESS_TGZFILENAME" $l_remote_rootpw > /dev/null 2>&1
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$l_remote_ip /bin/rm -rf /var/tmp/platform_taf" $l_remote_rootpw > /dev/null 2>&1
		$EXPECT $AT_BIN/ssh_setup2.sh scp "$HARNESS_TGZFILE root@$l_remote_ip:/var/tmp" $l_remote_rootpw > /dev/null 2>&1 || {
			echo "Error - failed to copy $HARNESS_TGZFILE to $l_remote_ip:/var/tmp"
			return 1
		}
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$l_remote_ip mkdir -p /var/tmp/platform_taf" $l_remote_rootpw > /dev/null 2>&1 || {
			echo "Error - failed to create dir /var/tmp/platform_taf on remote server $l_remote_ip"
			return 1
		}

		# Work out Tar Command to use 
		echo "Determine OS Type of Remote Server"
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$l_remote_ip uname > /tmp/ostype.$$" $l_remote_rootpw /dev/null 2>&1
		$EXPECT $AT_BIN/ssh_setup2.sh scp "root@$l_remote_ip:/tmp/ostype.$$ /var/tmp/" $l_remote_rootpw > /dev/null 2>&1 || {
                        echo "Error - failed to copy  temp file ostype.$$  from $l_remote_ip:/tmp"
                        return 1

                }
		REMOTE_OS=`cat /var/tmp/ostype.$$`
		echo "++ $REMOTE_OS ++ ostype.$$"
		if [ "${REMOTE_OS}" = "SunOS" ] ; then
           		TAR_COMMAND="/usr/sfw/bin/gtar xvf - "
        	else
           		TAR_COMMAND="tar xvf - "
		fi


		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$l_remote_ip cd /var/tmp/platform_taf && gunzip -c /var/tmp/$HARNESS_TGZFILENAME | $TAR_COMMAND " $l_remote_rootpw > /dev/null 2>&1 || {
			echo "Error - failed to unpack test harness tar file on server $l_remote_ip"
			return 1
		}
	


}


#
# cleanup before scripts exits
#
cleanupOnExit () {
	if [ -f $HARNESS_TGZFILE ];then
		/bin/rm -f $HARNESS_TGZFILE
	fi

}

	
	
# MAIN

SCRIPTNAME=$(/bin/basename $0)
AT_BIN=$(cd $(/usr/bin/dirname $0); pwd)
HARN_ROOT=$(/usr/bin/dirname ${AT_BIN})
AT_LIB=${HARN_ROOT}/lib
AT_ETC=${HARN_ROOT}/etc
AT_ROOT=$(/usr/bin/dirname ${HARN_ROOT})
FA_ROOT=${AT_ROOT}/FA
TS_ROOT=${AT_ROOT}/suites
CP_ROOT=${AT_ROOT}/campaigns
HARNESS_TARFILENAME=platform_test_harness.tar
HARNESS_TGZFILENAME=${HARNESS_TARFILENAME}.gz
if [ $(uname) = "Linux" ]; then
        EXPECT=/usr/bin/expect
else
        EXPECT=/app/expect/5.40.1/bin/expect
fi


# Environment variables 
export AT_ROOT AT_BIN AT_LIB AT_ETC 

# Cleanup when script exits
trap 'cleanupOnExit' EXIT HUP INT QUIT TERM


# Source config file
. ${AT_ETC}/campaign_ini.bsh

if [  -n "${WORKSPACE}" ]; then 
	# Results root directory
        if [ -z ${BUILD_ID} ]; then
                echo "ERROR:$BASH_SOURCE BUILD_ID Not set";
                exit 1  
        fi
        #RESULTS_ROOT=$(dirname ${WORKSPACE})/builds/${BUILD_ID}/results
        RESULTS_ROOT=${WORKSPACE}/${BUILD_ID}/results
	ATCOMINF_RESULTS_ROOT=$RESULTS_ROOT
        # Reports root directory
        #REPORTS_ROOT=$(dirname ${WORKSPACE})/builds/${BUILD_ID}/reports
        REPORTS_ROOT=${WORKSPACE}/${BUILD_ID}/reports
	ATCOMINF_REPORTS_ROOT=$REPORTS_ROOT
fi



# Source function library
. ${AT_LIB}/campaign.lib

# Globals
REMOTE_TAF_LOCATION=/var/tmp/platform_taf
AT_HARNESS_SCRIPT=atcominf.bsh
LOCAL_AT_HARNESS_SCRIPT=$AT_BIN/$AT_HARNESS_SCRIPT
REMOTE_AT_HARNESS_SCRIPT=$REMOTE_TAF_LOCATION/harness/bin/$AT_HARNESS_SCRIPT
AT_NUM_FAILED_STAGES=0

# Save command line and PID for report
AT_COMMAND="$0 $*"
AT_PID=$$

option_i=0
option_n=0
option_f=0
option_j=0

while getopts "hi:j:n:" opt; do

	case ${opt} in

	h)      # Print help and exit OK
		usage
		exit 0
		;;

	
	i)      # Single test case as argument
		option_i=1
		CP_ID=(${OPTARG})
		;;

	j)	# CI job number provided
		option_j=1
		# Must be integer
		if ! expr ${OPTARG} + 1 >/dev/null 2>&1; then
			printf "ERROR: Invalid CI job number [${OPTARG}]. Job number must be an integer.\n"
			exit 1
		fi
		AT_JOB=${OPTARG}
		export AT_JOB
		JOB_SCOPE=ci
		;;


	n)
		option_n=1
		ENVFILE=${OPTARG}
		;;
	

	?)	# Hint to run usage
		printf "Run \"${SCRIPTNAME} -h\" for help\n"
		exit 1
		;;
	esac
done

# Should be no extra stuff on the command line
shift $((${OPTIND} - 1))
if [ "$#" -ne 0 ]; then
        usage
        exit 1
fi

check_option_usage

. $ENVFILE

cd ${AT_BIN}


# Create the output directories for this job
init_job_outputs

run_CP $CP_ID 

write_report_txt &&  
write_reports_html && 
write_singlereport_html &&
# Tar file of results for CI collection 
[ -f $HARNESS_TGZFILE ] && /bin/rm -f $HARNESS_TGZFILE
write_report_archive || {
	echo "Error occured in reporting phase"
	exit 1
}

exit ${AT_NUM_FAILED_STAGES}
