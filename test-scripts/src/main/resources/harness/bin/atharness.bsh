#!/bin/bash
#################################################################################
#
#
#       COPYRIGHT (C) ERICSSON RADIO SYSTEMS AB, Sweden
#
#       The copyright to the document(s) herein is the property of
#       Ericsson Radio Systems AB, Sweden.
#
#       The document(s) may be used and/or copied only with the written
#       permission from Ericsson Radio Systems AB or in accordance with
#       the terms and conditions stipulated in the agreement/contract
#       under which the document(s) have been supplied.
#
#################################################################################

# COMInf Automated Test Harness (ATCOMINF)

# Revision History
# 04/05/2012	v1.0	eedmaxw 
# 22/05/2012	Replaced AT_ROOT with FA_ROOT for unique TC_ID searches
# 04/12/2012	Enabled exporting test suite name through AT_SUITE_NAME variable

usage() {

${CAT} << EOF

Usage:  ${SCRIPTNAME} [-j <CI_jobnum>] [-h] 
		[-a "<FA_NAME> <FA_NAME> ..."] 
		[-u "<UC_NAME> <UC_NAME> ..."]
		[-i "<TC_ID> <TC_ID> ..."] 
		[-s <TS_NAME>] 
		[-p high|low] 
		[-P positive|negative] 
		[-t FT|UNIT] 
		[-S] [-l] [-f]

Run a selection of test cases (TCs). 
Without any selection options all test cases for all FAs are run.

-h	Print help.

-j <CI_jobnum>	
	When run from the CI server, the CI job number must be supplied.
	The number is used to label the harness report for CI collection.
	This option is not necessary for a local job, local job numbers
	are generated by the harness.

-a "<FA_NAME> <FA_NAME> ..."
	Select TCs from a space-separated list of FA names.

-u "<UC_NAME> <UC_NAME> ..."
	Select TCs from a space-separated list of UC names.

-i "<TC_ID> <TC_ID> ..."
	Select TCs from a space-separated list of TC IDs.

-p low|high
	Apply low|high priority filter to TC selection.

-P positive|negative
	Apply positive|negative polarity filter to TC selection.

-T FT|UNIT
	Apply FT|UNIT type filter to TC selection.

-s <TS_NAME>
	Select a single test suite by name. Option filters are not allowed.

-l List test cases that are selected to run but don't run them.

-S Produce stats based on all test cases in the installed cominf_test rpm .

-f Force execution of a TC which has test spec setting SPEC_TC_AUTOMATED=0

The selection options and filters are applied to produce an array of TCs to run. 

Harness confif file: /opt/ericsson/cominf_test/harness/etc/atcominf_ini.bsh

Default RESULTS_ROOT=/var/tmp/results
Default REPORTS_ROOT=/var/tmp/reports

For a CI job, results are available under <RESULTS_ROOT>/ci/<CI_jobnum>
For a CI job, the report archive is available as <REPORTS_ROOT>/ci/<CI_jobnum>_report.tar.gz

For a local job, results are available under ${RESULTS_ROOT}/local/<local_jobnum>
For a local job, the report archive is available as ${REPORTS_ROOT}/local/<local_jobnum>_report.tar.gz

All TC  selections are run in independent mode unless a test suite is defined with TS_INDEPENDENT=0.
Independent test case can be run in any order and do not depend on each other's inputs or outputs.
All callbacks are called for independent test cases: TC_SETUP, TC_PRECON, TC_TEST, TC_POSTCON, TC_CLEANUP.

Dependent test cases are called in a fixed order where one test case provides the setup for the next.
Callbacks TC_SETUP and TC_CLEANUP are not called for dependent test cases.
A test suite must be defined to run test cases in dependent mode.

EOF

	return 0

}

check_option_usage() {

	# One of -a, -u, -i, -s is required
	if [[ ${option_a} -eq 0 && ${option_u} -eq 0 && ${option_i} -eq 0 && ${option_s} -eq 0 ]]; then
		printf "ERROR: One of options -a, -u, -i, -s is required.\n"
		exit 1
	fi

	# Options -a, -u, -i, -s are mutually exclusive
	if [[ ${option_a} -eq 1 ]]; then
		if [[  ${option_u} -eq 1 || ${option_i} -eq 1 || ${option_s} -eq 1 ]]; then
			printf "ERROR: Options -a, -u, -i, -s are mutually exclusive.\n"
			exit 1
		fi
	fi

	if [[ ${option_u} -eq 1 ]]; then
		if [[  ${option_a} -eq 1 || ${option_i} -eq 1 || ${option_s} -eq 1 ]]; then
			printf "ERROR: Options -a, -u, -i, -s are mutually exclusive.\n"
			exit 1
		fi
	fi

	if [[ ${option_i} -eq 1 ]]; then
		if [[  ${option_a} -eq 1 || ${option_u} -eq 1 || ${option_s} -eq 1 ]]; then
			printf "ERROR: Options -a, -u, -i, -s are mutually exclusive.\n"
			exit 1
		fi
	fi
	
	if [[ ${option_s} -eq 1 ]]; then
		if [[  ${option_a} -eq 1 || ${option_u} -eq 1 || ${option_i} -eq 1 ]]; then
			printf "ERROR: Options -a, -u, -i, -s are mutually exclusive.\n"
			exit 1
		fi
	fi
	
	
	# Options -p, -P, -t only allowed with options -a, -u
	if  [[  ${option_p} -eq 1 ||  ${option_P} -eq 1 || ${option_t} -eq 1 ]]; then
		if [[ ${option_i} -eq 1 || ${option_s} -eq 1 ]]; then
			printf "ERROR: Options -p, -P, -t cannot be used with options -i, -s.\n"
			exit 1
		fi
	fi
	
	return 0
	
}
	
init_job_outputs() {

	# Create CI and LOCAL result dirs 
	ret=$(${MKDIR} -p ${RESULTS_ROOT}/ci; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${RESULTS_ROOT}/ci] failed; error [${ret}]\n"
		exit 1
	fi

	ret=$(${MKDIR} -p ${RESULTS_ROOT}/local; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${RESULTS_ROOT}/local] failed; error [${ret}]\n"
		exit 1
	fi

	# Create CI and LOCAL report dirs
	ret=$(${MKDIR} -p ${REPORTS_ROOT}/ci; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${REPORTS_ROOT}/ci] failed; error [${ret}]\n"
		exit 1
	fi
	
	ret=$(${MKDIR} -p ${REPORTS_ROOT}/local; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${REPORTS_ROOT}/local] failed; error [${ret}]\n"
		exit 1
	fi
	
	# If a CI job, supplied CI job number must be unique
	if [[ ${JOB_SCOPE} = "ci" ]]; then
		# Job number must not already exist
		if [[ -d ${RESULTS_ROOT}/ci/${AT_JOB} ]]; then
			printf "ERROR: CI job number [${AT_JOB}] already exists.\n"
			exit 1
		fi
	fi
	
	# If not a CI job, create a local job on the target server e.g for test automation callback development
	if [[ ${JOB_SCOPE} != "ci" ]]; then
		JOB_SCOPE=local
		# Get the next local job number
		AT_JOB=$[$(${LS} ${RESULTS_ROOT}/local | ${SORT} -rn | ${HEAD} -1) + 1]
		if ! expr ${AT_JOB} + 1 >/dev/null 2>&1; then
			printf "ERROR: Invalid local job number calculation [${AT_JOB}]. Job number must be an integer.\n"
			exit 1
		fi
		export AT_JOB
	fi
	
	# Set result and report paths for this job
	AT_RESULTS_DIR=${RESULTS_ROOT}/${JOB_SCOPE}/${AT_JOB}
	AT_REPORT_TXT=${AT_RESULTS_DIR}/atcominf_results_job_${AT_JOB}.txt
	AT_SUMMARY=${AT_RESULTS_DIR}/atcominf_summary_job_${AT_JOB}.txt
	AT_REPORT_HTML=${AT_RESULTS_DIR}/index.html
	AT_STATS_HTML=${AT_RESULTS_DIR}/stats.html
	
	AT_REPORT_DIR=${REPORTS_ROOT}/${JOB_SCOPE}
	AT_REPORT_ARCHIVE=${AT_REPORT_DIR}/${AT_JOB}_report.tar
	${RM} -f ${AT_REPORT_HTML}
	${RM} -f ${AT_REPORT_ARCHIVE}
	${RM} -f ${AT_REPORT_HTML}
	${RM} -f ${AT_STATS_HTML}
	
	AT_FA_STATS=${AT_RESULTS_DIR}/atcominf_stats_fa_job_${AT_JOB}.txt
	AT_UC_STATS=${AT_RESULTS_DIR}/atcominf_stats_uc_job_${AT_JOB}.txt
	
	# Create result dir for this job
	ret=$(${MKDIR} -p ${AT_RESULTS_DIR}; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${AT_RESULTS_DIR}] failed; error [${ret}]\n"
		exit 1
	fi
	
	# Create report dir for this job
	ret=$(${MKDIR} -p ${AT_REPORT_DIR}; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${AT_REPORT_DIR}] failed; error [${ret}]\n"
		exit 1
	fi
	
	# Remove any report that exists with this job number
	
	return 0
	
}
	
log_result() {

	local tc_id=$1
	local tc_result=$2
	local tc_remark=$3
	local datetime=$(date "+%Y-%m-%d %H:%M:%S")
	
	# Save TC stop time
	tc_stop_time=$(${PERL} -e 'print time."\n"')
	tc_duration=$(echo "scale=2; (${tc_stop_time}-${tc_start_time})" | ${BC})
	
${CAT} >>${TC_RESULT_FILE} << EOF
# END DateTime: ${datetime}
	
TC_DURATION=${tc_duration} # seconds
TC_REMARK="${tc_remark}"
TC_RESULT=${tc_result}
EOF
	
${CAT} >&3 << EOF
${datetime} DURATION: [${tc_duration}] seconds
${datetime} REMARK: [${tc_remark}]
${datetime} RESULT: [${tc_result}] 
${datetime} CONSOLE OUTPUT: [${TC_CONSOLE_FILE}] 
${datetime} END TC [${SPEC_TC_ID}] [${tc_result}]
	
EOF
	
	return 0
	
}
	
log_callback() {

	local tc_id=$1
	local callback=$2
	local ret=$3
	local datetime=$(date "+%Y-%m-%d %H:%M:%S")
	
	printf "CALLBACK_${callback}=${ret}\n" >> ${TC_RESULT_FILE}
	
	return 0

}

init_TC() {

	local tc_id=$1
	local tc_spec=$2
	local mode=$3
	local tc_result_dir
	local datetime=$(date "+%Y-%m-%d %H:%M:%S")
	
	init_tc_spec
	
	if ! . ${tc_spec}; then
		printf "ERROR: Failed to source test spec [${tc_spec}]\n"
		return 1
	fi
	
	# Validate TC ID
	if [[ ${tc_id} != ${SPEC_TC_ID} ]]; then
		printf "ERROR: TC_ID [${tc_id}] not same as ID [${SPEC_TC_ID}] in test spec file [${tc_spec}]\n"
		return 1
	fi
	
	[[ ${mode} = AT_TC ]] && TC_RESULT_DIR=${AT_RESULTS_DIR}/FA/${SPEC_FA_NAME}/${SPEC_UC_NAME}/${tc_id}
	[[ ${mode} = AT_TS ]] && TC_RESULT_DIR=${AT_RESULTS_DIR}/${SPEC_TS_NAME}/${SPEC_FA_NAME}/${SPEC_UC_NAME}/${tc_id}
	TC_RESULT_FILE=${TC_RESULT_DIR}/${tc_id}_result.bsh
	TC_CONSOLE_FILE=${TC_RESULT_DIR}/${tc_id}_console.txt
	export TC_CONSOLE_FILE
	
	# Create results hierarchy if necesary
	if [[ ! -d ${TC_RESULT_DIR} ]]; then
		ret=$(${MKDIR} -p ${TC_RESULT_DIR}; echo $?)
		if [[ ${ret} -ne 0 ]]; then
			printf "ERROR: [${MKDIR} -p ${TC_RESULT_DIR}] failed; error [${ret}]\n"
			exit 1
		fi
	fi
	
	${RM} -f ${TC_CONSOLE_FILE}
	${RM} -f ${TC_RESULT_FILE}
	${TOUCH} ${TC_CONSOLE_FILE}
	
	# Save TC start time
	tc_start_time=$(${PERL} -e 'print time."\n"')
	
	# Start the result file
	printf "#!/bin/bash\n" > ${TC_RESULT_FILE}
	printf "AT_JOB=${AT_JOB}\n" >> ${TC_RESULT_FILE}
	${GREP} "^SPEC_TC" ${tc_spec} >> ${TC_RESULT_FILE}
	printf "\n# BEGIN DateTime: ${datetime}\n" >> ${TC_RESULT_FILE}
	
	return 0
	
}
	
timeouter() {

	timeout=$1
	command=$2
	
	declare -i cmd_pid
	declare -i retry=1
	declare -i sleep_pid
	declare -i sleep_ppid
	declare -i cmd_status
	
	${command} &
	cmd_pid=$!
	
	# Sleep in subshell that kills command after sleep
	( sleep ${timeout} && kill -TERM ${cmd_pid} ) &
	sleep_ppid=$!
	while [[ ${retry} -le 3 ]]; do 
		sleep_pid=$(ps -ef | ${AWK} '($3 ~ "'"^${sleep_ppid}$"'") { print $2; }')
		#echo "sleep: ${sleep_pid}"
		[[ ${sleep_pid} -ne 0 ]] && break
		sleep 1
		retry=$[${retry}+1]
	done
	
	wait ${cmd_pid} 
	cmd_status=$?
	[[ ${cmd_status} -eq 143 ]] && return 143
	
	disown ${sleep_ppid} >/dev/null 2>&1
	kill -9 ${sleep_ppid} >/dev/null 2>&1
	
	if [[ ${sleep_pid} -ne 0 ]]; then
		disown ${sleep_pid} >/dev/null 2>&1
		kill -9 ${sleep_pid} >/dev/null 2>&1
	fi
	
	return ${cmd_status}

}

run_TC() {

	local tc_id=$1
	local mode=$2
	local tc_unique
	local tc_path
	local tc_callback_lib
	local tc_disabled
	declare -i ret
	declare -i tc_tee_pid
	declare callback_error=0
	local remark=
	local datetime
	local code
	# Locate TC, check for unique TC_ID 
	# problem with $FIND in hub had to replace with just find.	tc_unique=$(find ${FA_ROOT} -type d -name "${tc_id}" | ${WC} -l)
	tc_unique=$(find ${FA_ROOT} -type d -name "${tc_id}" | ${WC} -l)
	echo "tc_unique = $tc_unique"
	tc_unique=$(echo ${tc_unique})

	case ${tc_unique} in
	
	0)	printf "ERROR: Failed to locate a test case with TC_ID [${tc_id}]\n"
		return 1
		;;
	
	1)	tc_path=$(find ${FA_ROOT} -type d -name "${tc_id}")
		if [[ ${option_l} -eq 1 ]]; then
			printf "${tc_path}\n"
			return 0
		fi
		tc_spec=${tc_path}/${tc_id}_spec.bsh
		tc_callback_lib=${tc_path}/${tc_id}_callbacks.lib
		tc_disabled=${tc_path}/.disabled
		;;
	
	*)	printf "ERROR: TC_ID [${tc_id}] is not unique.\n"
		find ${FA_ROOT} -type d -name "${tc_id}"
		return 1
		;;
	esac
	# Save stdout, stderr descriptors 
	exec 3>&1 4>&2
	
	# Check TC spec exists
	if [[ ! -f ${tc_spec} ]]; then
		printf "ERROR: Failed to locate test case spec [${tc_spec}]\n"
		return 1
	fi
	
	# Check TC callback lib exists
	if [[ ! -f ${tc_callback_lib} ]]; then
		printf "ERROR: Failed to locate TC callback library [${tc_callback_lib}]\n"
		return 1
	fi
	
	# Source the test spec file and set TC result paths
	init_TC ${tc_id} ${tc_spec} ${mode} || return 1
	
	# From this point on a TC is considered valid and appears in the report
	
	datetime=$(date "+%Y-%m-%d %H:%M:%S")
${CAT} << EOF
${datetime} BEGIN TC [${SPEC_TC_ID}]
${datetime} UC: [${SPEC_UC_NAME}]
${datetime} SLOGAN: [${SPEC_TC_SLOGAN}]
${datetime} SPEC FILE: [${tc_spec}]
EOF
	
	# Don't run if disabled
	if [[ -f ${tc_disabled} ]]; then
		log_result ${tc_id} ${CODE_NOT_RUN} "TC disabled"
		return 1
	fi
		
	# Don't run if automation not ready unless force option used
	if [[ ${SPEC_TC_AUTOMATED} = "0" ]]; then
		if [[ ${option_f} -eq 0 ]]; then
			log_result ${tc_id} ${CODE_NOT_RUN} "TC not automated"
			return 1
		fi
	fi
	
	# Tests are run as independent tests by default
	AT_INDEPENDENT=1 # default
	
	# Set dependent mode if running a dependent suite
	[[ ${mode} = AT_TS && ${SPEC_TS_INDEPENDENT} -eq 0 ]] && AT_INDEPENDENT=0
	
	# Don't run if independent mode is set but test is only able to run in dependent mode
	if [[ ${AT_INDEPENDENT} = 1 && ${SPEC_TC_DEPENDENT_ONLY} -eq 1 ]]; then
		log_result ${tc_id} ${CODE_NOT_RUN} "DEPENDENT_ONLY TC"
		return 1
	fi
	
	# Create pipe for TC tee
	tc_tee_fifo=${tc_path}/${tc_id}.fifo
	if [[ ! -e ${tc_tee_fifo} ]]; then
		ret=$(mkfifo ${tc_tee_fifo}; echo $?)
		if [[ ${ret} -ne 0 ]]; then
			log_result ${tc_id} ${CODE_NOT_RUN} "Harness error"
			AT_NUM_FAILED_CALLBACKS=$[${AT_NUM_FAILED_CALLBACKS}+1]
			return 1
		fi
	fi
	
	# Change to TC directory
	cd ${tc_path}
	
	# Record output from TC callbacks to console output file
	# Start TC tee in background, tee reads from pipe and writes to both TC console file and screen
	
	# Save stdout, stderr descriptors 
	exec 3>&1 4>&2
	
	${TEE} -a ${TC_CONSOLE_FILE} < ${tc_tee_fifo} >&3 &
	
	# Save TC tee PID
	tc_tee_pid=$!
	
	# Redirect stdout, stderr to TC console pipe
	exec > ${tc_tee_fifo} 2>&1
	
	# Run TC callbacks - all callbacks must succeed for a TC PASS result
	
	# CALLBACK: TC_SETUP
	# For an independent TC, run TC_SETUP with timeout
	if [[ ${AT_INDEPENDENT} -eq 1 ]]; then
	
		timeouter ${SPEC_TC_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TC ${tc_path} ${tc_id} TC_SETUP"
		ret=$?
		log_callback ${tc_id} TC_SETUP ${ret}
	
		if [[ ${ret} -ne 0 ]]; then
			callback_error=1
			code=${CODE_FAIL}
			remark="TC_SETUP failure"
			[[ ${ret} -eq 143 ]] && remark="TC_SETUP timeout"
		fi
	fi
	
	# CALLBACK: TC_PRECON
	# Run TC_PRECON with timeout
	if [[ ${callback_error} -eq 0 ]]; then 
	
		timeouter ${SPEC_TC_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TC ${tc_path} ${tc_id} TC_PRECON"
		ret=$?
		log_callback ${tc_id} TC_PRECON ${ret}
	
		if [[ ${ret} -ne 0 ]]; then
			callback_error=1
			code=${CODE_FAIL}
			remark="TC_PRECON failure"
			[[ ${ret} -eq 143 ]] && remark="TC_PRECON timeout"
		fi
	fi
	
	# CALLBACK: TC_TEST
	# Run TC_TEST with timeout
	if [[ ${callback_error} -eq 0 ]]; then 
	
		timeouter ${SPEC_TC_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TC ${tc_path} ${tc_id} TC_TEST"
		ret=$?
		log_callback ${tc_id} TC_TEST ${ret}
	
		if [[ ${ret} -ne ${SPEC_TC_TEST_PASSCODE} ]]; then
			callback_error=1
			code=${CODE_FAIL}
			remark="TC_TEST failure"
			[[ ${ret} -eq 143 ]] && remark="TC_TEST timeout"
		fi
	fi
	
	# Close the TC console output file and collect tee pid - this ensures console file is flushed 
	# before callback TC_POSTCON as callback TC_POSTCON may want to grep contents of TC console file 
	
	# Redirect stdout, stderr to screen and close duplicates
	exec 1>&3 2>&4 3>&- 4>&-
	
	# Wait for tee to exit
	wait ${tc_tee_pid}
	
	# Save stdout, stderr descriptors 
	exec 3>&1 4>&2
	
	# Start TC tee again 
	${TEE} -a ${TC_CONSOLE_FILE} < ${tc_tee_fifo} >&3 &
	
	# Save TC tee PID
	tc_tee_pid=$!
	
	# Redirect stdout, stderr to TC console pipe
	exec > ${tc_tee_fifo} 2>&1
	
	# CALLBACK: TC_POSTCON
	# Run TC_POSTCON with timeout
	if [[ ${callback_error} -eq 0 ]]; then 
	
		timeouter ${SPEC_TC_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TC ${tc_path} ${tc_id} TC_POSTCON"
		ret=$?
		log_callback ${tc_id} TC_POSTCON ${ret}
	
		if [[ ${ret} -ne 0 ]]; then
			callback_error=1
			code=${CODE_FAIL}
			remark="TC_POSTCON failure"
			[[ ${ret} -eq 143 ]] && remark="TC_POSTCON timeout"
		fi
	fi
	
	# CALLBACK: TC_CLEANUP
	# For an independent TC, run TC_CLEANUP with timeout
	
	if [[ ${AT_INDEPENDENT} -eq 1 ]]; then
	
		timeouter ${SPEC_TC_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TC ${tc_path} ${tc_id} TC_CLEANUP"
		ret=$?
		log_callback ${tc_id} TC_CLEANUP ${ret}
	
		if [[ ${ret} -ne 0 ]]; then
			callback_error=1
			code=${CODE_FAIL}
			remark="TC_CLEANUP failure"
			[[ ${ret} -eq 143 ]] && remark="TC_CLEANUP timeout"
		fi
	fi
	
	if [[ ${callback_error} -eq 0 ]]; then
		# All callbacks passed - TC passed
		code=${CODE_PASS}
		remark="PASS"
	fi
	
	log_result ${tc_id} ${code} "${remark}"
	
	# Redirect stdout, stderr to screen and close duplicates
	exec 1>&3 2>&4 3>&- 4>&-
	
	# Wait for tee to exit
	wait ${tc_tee_pid}
	
	# Remove TC tee pipe
	${RM} -f ${tc_tee_fifo}
	
	[[ ${callback_error} -eq 1 ]] && AT_NUM_FAILED_CALLBACKS=$[${AT_NUM_FAILED_CALLBACKS}+1]
	
	# Change to harness bin dir
	cd ${AT_BIN}
	
	return ${ret}
	
}
	
selected_UC() {

	local cmd_uc=$1
	local uc
	declare -i i=0
	
	for uc in ${CMD_TC_SELECTION[@]}; do
		[[ "${uc}" = "${cmd_uc}" ]] && return 0
	done
	
	return 1
	
}

filtered_TC() {

	# Returns 0 if TC is filtered
	# Returns 1 if TC is not filtered
	
	local tc_spec=$1
	
	if ! . ${tc_spec}; then
		printf "ERROR: Failed to source TC spec [${tc_spec}]\n"
		return 0 # filtered
	fi
	
	# Apply type filter
	if [[ ${option_t} -eq 1 ]]; then
		[[ ${CMD_TYPE} != ${SPEC_TC_TYPE} ]] && return 0 # filtered
	fi
	
	# Apply priority filter
	if [[ ${option_p} -eq 1 ]]; then
		[[ ${CMD_PRIORITY} != ${SPEC_TC_PRIORITY} ]] && return 0 # filtered
	fi
	
	# Apply polarity filter
	if [[ ${option_P} -eq 1 ]]; then
		[[ ${CMD_POLARITY} != ${SPEC_TC_POLARITY} ]] && return 0 # filtered
	fi
	
	# Survived all filters
	return 1 # not filtered
	
}
		
get_TCs() {
	
	local scope=$1
	local fa
	local uc
	local tc
	declare -i i=0
	local ts_spec_file

	case ${scope} in

	AT_FA_ALL) # Resolve all FAs to TCs
		cd ${FA_ROOT}
		for fa in *; do
			cd ${fa}
			for uc in *; do
				if [[ -d ${uc} ]]; then
					cd ${uc}
					for tc in *; do
						if [[ -f ${tc}/${tc}_spec.bsh ]]; then
							if ! filtered_TC ${FA_ROOT}/${fa}/${uc}/${tc}/${tc}_spec.bsh; then
					 			CMD_TCs[$i]=${tc}
								i=$[$i+1]
							fi
						fi
					done
					cd ..
				fi
			done
			cd ..
		done
		cd ${AT_BIN}
		;;
	
	AT_FA)	# Resolve selected FAs to TCs
	
		if [[ ${CMD_TC_SELECTION[0]} = "ALL" ]]; then
			get_TCs AT_FA_ALL 
			return 0
		fi
			
		cd ${FA_ROOT}
		for fa in ${CMD_TC_SELECTION[@]}; do
			if ! cd ${fa} 2>/dev/null; then
				printf "ERROR: FA [${FA_ROOT}/${fa}] does not exist.\n"
				exit 1
			fi
			for uc in *; do
				if [[ -d ${uc} ]]; then
					cd ${uc}
					for tc in *; do
						if [[ -f ${tc}/${tc}_spec.bsh ]]; then
							if ! filtered_TC ${FA_ROOT}/${fa}/${uc}/${tc}/${tc}_spec.bsh; then
					 			CMD_TCs[$i]=${tc}
								i=$[$i+1]
							fi
						fi
					done
					cd ..
				fi
			done
			cd ..
		done
		cd ${AT_BIN}
		;;
	
	AT_UC) # Resolve selected UCs to TCs
	
		cd ${FA_ROOT}
		for fa in *; do
			cd ${fa}
			for uc in *; do
				! selected_UC ${uc} && continue
				if [[ -d ${uc} ]]; then
					cd ${uc}
					for tc in *; do
						if [[ -f ${tc}/${tc}_spec.bsh ]]; then
							if ! filtered_TC ${FA_ROOT}/${fa}/${uc}/${tc}/${tc}_spec.bsh; then
					 			CMD_TCs[$i]=${tc}
								i=$[$i+1]
							fi
						fi
					done
					cd ..
				fi
			done
			cd ..
		done
		cd ${AT_BIN}
		;;
	
	AT_TC) # TCs already on command line - validate
	
		for tc in ${CMD_TC_SELECTION[@]}; do
			# TC ID must be integer
			if ! expr ${tc} + 1 >/dev/null 2>&1; then
				printf "ERROR: Invalid TC ID on command line [${tc}]. TC ID must be an integer.\n"
				exit 1
			fi
		done
		CMD_TCs=( "${CMD_TC_SELECTION[@]}" )
		;;
	
	AT_TS) # Resolve suite to TCs
	
		ts_spec_file=${TS_ROOT}/${SPEC_TS_ID}/${SPEC_TS_ID}_spec.bsh
	
		if [[ ! -f ${ts_spec_file} ]]; then
			printf "ERROR: Failed to locate test suite spec file [${ts_spec_file}]\n"
			exit 1
		fi
		
		# Read in the TCs contained in the spec file array
		.  ${ts_spec_file}
		CMD_TCs=( "${SPEC_TS_TC_IDS[@]}" )
		;;
	esac
	
	return 0
	
}
	
# MAIN

SCRIPTNAME=$(/bin/basename $0)
AT_BIN=$(cd $(/usr/bin/dirname $0); pwd)
HARN_ROOT=$(/usr/bin/dirname ${AT_BIN})
AT_LIB=${HARN_ROOT}/lib
AT_ETC=${HARN_ROOT}/etc
AT_ROOT=$(/usr/bin/dirname ${HARN_ROOT})
FA_ROOT=${AT_ROOT}/FA
TS_ROOT=${AT_ROOT}/suites

# Environment variables 
export AT_ROOT AT_BIN AT_LIB AT_ETC 

# Source config file
. ${AT_ETC}/atcominf_ini.bsh
if [  -z ${WORKSPACE} ]; then {
	# Results root directory
	RESULTS_ROOT=/var/tmp/results

	# Reports root directory
	REPORTS_ROOT=/var/tmp/reports
}
else {
# Results root directory
	if [ -z ${BUILD_ID} ]; then
		echo "ERROR:$BASH_SOURCE BUILD_ID Not set"; 
		exit 1  
	fi
	#RESULTS_ROOT=$(dirname ${WORKSPACE})/builds/${BUILD_ID}/results
	RESULTS_ROOT=${WORKSPACE}/${BUILD_ID}/results
	# Reports root directory
	#REPORTS_ROOT=$(dirname ${WORKSPACE})/builds/${BUILD_ID}/reports
	REPORTS_ROOT=${WORKSPACE}/${BUILD_ID}/reports
}
fi
# Source function library
. ${AT_LIB}/atcominf.lib

# Globals
AT_CALLBACK_SCRIPT=${AT_BIN}/callback.bsh

# By default, test cases are run in independent mode. 
# In independent mode all callbacks are called for each test case.
# In dependent mode callbacks TC_SETUP and TC_CLEANUP are not called for each test case.
declare -i AT_INDEPENDENT

# Save command line and PID for report
AT_COMMAND="$0 $*"
AT_PID=$$

# Failed TC counter
AT_NUM_FAILED_CALLBACKS=0

# Array to hold test selection
declare -a CMD_TC_SELECTION=()
declare -a CMD_TS_SELECTION=()
declare -a CMD_TCs=()

# Option parsing

# Test case selection filters

# Run one of:
declare -i option_a=0	# Run FA
declare -i option_u=0	# Run UC
declare -i option_i=0 	# Run TC 
declare -i option_s=0	# Run Suite

# Filter FA, UC selection with one or more of
declare -i option_t=0	# Run only of type (FT|UNIT)
declare -i option_p=0	# Run only of priority (high/low)
declare -i option_P=0	# Run only of polarity (positive|negative)

# Other options
declare -i option_l=0	# List-only mode
declare -i option_j=0	# Run with CI job number
declare -i option_S=0	# Run statistics after tests
declare -i option_f=0	# Force TC execution flag

while getopts "ha:u:i:s:t:p:P:j:lSfe:" opt; do

	case ${opt} in

	h)      # Print help and exit OK
		usage
		exit 0
		;;

	a)	# Functional Area selection
		option_a=1
		CMD_TC_SELECTION=(${OPTARG})
		CMD_SCOPE=AT_FA
		;;

	u)	# Use case selection
		option_u=1
		CMD_TC_SELECTION=(${OPTARG})
		CMD_SCOPE=AT_UC
		;;
	
	i)      # Single test case as argument
		option_i=1
		CMD_TC_SELECTION=(${OPTARG})
		CMD_SCOPE=AT_TC
		;;

	s)	# Suite selection
		option_s=1
		CMD_TS_SELECTION=(${OPTARG})
		AT_SUITE_NAME=$CMD_TS_SELECTION
		export AT_SUITE_NAME
		CMD_SCOPE=AT_TS
		;;

	t)	option_t=1
		if [[ ${OPTARG} != ${CODE_FT} && ${OPTARG} != ${CODE_UNIT} ]]; then
			printf "ERROR: Invalid type [${OPTARG}]; valid types are \"${CODE_FT}\", \"${CODE_UNIT}\"\n"
			exit 1
		fi
		CMD_TYPE=${OPTARG}
		;;

	p)	option_p=1
		if [[ ${OPTARG} != ${CODE_HIGH} && ${OPTARG} != ${CODE_LOW} ]]; then
			printf "ERROR: Invalid priority [${OPTARG}]; valid priorities are \"${CODE_HIGH}\", \"${CODE_LOW}\"\n"
			exit 1
		fi
		CMD_PRIORITY=${OPTARG}
		;;

	P)	option_P=1
		if [[ ${OPTARG} != ${CODE_POS} && ${OPTARG} != ${CODE_NEG} ]]; then
			printf "ERROR: Invalid polariry [${OPTARG}]; valid polarities are \"${CODE_POS}\", \"${CODE_NEG}\"\n"
			exit 1
		fi
		CMD_POLARITY=${OPTARG}
		;;

	j)	# CI job number provided
		option_j=1
		# Must be integer
		if ! expr ${OPTARG} + 1 >/dev/null 2>&1; then
			printf "ERROR: Invalid CI job number [${OPTARG}]. Job number must be an integer.\n"
			exit 1
		fi
		AT_JOB=${OPTARG}
		export AT_JOB
		JOB_SCOPE=ci
		;;

	l)	# List TCs that would run but don't run them
		option_l=1
		;;

	S)	# Generate stats after run
		option_S=1
		;;

	f)	# Force execution of TC that has spec file setting SPEC_TC_AUTOMATED=0
		option_f=1
		;;
	e)
		for variable in $(echo $OPTARG | sed 's/,/ /g'); do
			export $variable
		done
		;;

	?)	# Hint to run usage
		printf "Run \"${SCRIPTNAME} -h\" for help\n"
		exit 1
		;;
	esac
done

# Should be no extra stuff on the command line
shift $((${OPTIND} - 1))
if [ "$#" -ne 0 ]; then
        usage
        exit 1
fi

check_option_usage

cd ${AT_BIN}

# Create the output directories for this job
init_job_outputs

if [[ ${option_s} -eq 1 ]]; then

	# Run suite(s)

	if [[ ${CMD_TS_SELECTION[0]} = ALL ]]; then 
		get_TS ${TS_ROOT} || exit 1
		CMD_TS_SELECTION=( "${AT_TSs[@]}" )
	fi

	for ts_name in ${CMD_TS_SELECTION[@]}; do
		echo "{CMD_TS_SELECTION[@]} = ${CMD_TS_SELECTION[@]}"
		echo "ts_name=${ts_name}"
		# Get TS_ID from TS_NAME
		ts_unique=$(find ${TS_ROOT} -type f -name "*_spec.bsh" -exec ${GREP} -l "^SPEC_TS_NAME=${ts_name}$" {} \; | ${WC} -l)
		ts_unique=$(echo ${ts_unique})

		case ${ts_unique} in

		0)	printf "ERROR: TS [${ts_name}]: Failed to locate a test suite with name [${ts_name}]\n"
			exit 1
			;;
	
		1)	ts_spec=$(find ${TS_ROOT} -type f -name "*_spec.bsh" -exec ${GREP} -l "^SPEC_TS_NAME=${ts_name}$" {} \;)
			ts_path=$(${DIRNAME} ${ts_spec})
			eval $(${GREP} "^SPEC_TS_ID=" ${ts_spec})
			if [[ -z ${SPEC_TS_ID} ]]; then
				printf "ERROR: TS [${ts_name}]: Failed to get SPEC_TS_ID from test suite spec [${ts_spec}]\n"
				exit 1
			fi
			;;
	
		*)	printf "ERROR: TS [${ts_name}]: TS [${ts_name}] is not unique. Check suite spec files:\n"
			find ${TS_ROOT} -type f -name "*_spec.bsh" -exec ${GREP} -l "^SPEC_TS_NAME=${ts_name}$" {} \;
			exit 1
			;;
		esac


		# Locate the test suite callback lib
		ts_callback_lib=${ts_path}/${SPEC_TS_ID}_callbacks.lib
		if [[ ! -f ${ts_callback_lib} ]]; then
			printf "ERROR: TS [${ts_name}]: Failed to locate test suite callback library [${ts_callback_lib}]\n"
			exit 1
		fi

		init_ts_spec
		if ! . ${ts_spec}; then
			printf "ERROR: Failed to source test suite spec [${ts_spec}]\n"
			exit 1
		fi

		# Create the suite results directory
		ret=$(${MKDIR} -p ${AT_RESULTS_DIR}/${ts_name}; echo $?)
		if [[ ${ret} -ne 0 ]]; then
			printf "ERROR: TS [${ts_name}]: [${MKDIR} -p ${AT_RESULTS_DIR}/${ts_name} failed; error [${ret}]\n"
			exit 1
		fi

		# Set execution mode
		AT_INDEPENDENT=${SPEC_TS_INDEPENDENT}

		printf "================================================================================\n"
		datetime=$(date "+%Y-%m-%d %H:%M:%S")
		printf "${datetime} BEGIN TS [${ts_name}]; INDEPENDENT=${AT_INDEPENDENT}\n"
		printf "${datetime} SLOGAN [${SPEC_TS_SLOGAN}]\n"

		# CALLBACK: TS_SETUP
		# Run callback TS_SETUP with timeout
	
		timeouter ${SPEC_TS_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TS ${ts_path} ${SPEC_TS_ID} TS_SETUP"
		ret=$?
		if [[ ${ret} -ne 0 ]]; then
			printf "ERROR: TS [${ts_name}]: TS_SETUP callback failed; error [${ret}]\n"
			timeouter ${SPEC_TS_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TS ${ts_path} ${SPEC_TS_ID} TS_CLEANUP"
			ret=$?
			if [[ ${ret} -ne 0 ]]; then
				printf "ERROR: TS [${ts_name}]: TS_CLEANUP callback failed; error [${ret}]\n"
			fi
			datetime=$(date "+%Y-%m-%d %H:%M:%S")
			printf "${datetime} END TS [${ts_name}]\n\n"
			continue
		fi
		printf "\n"

		# Run suite TCs
		for cmd_tc in ${SPEC_TS_TC_IDS[@]}; do
			if ! run_TC ${cmd_tc} AT_TS; then
				# Stop now if running a suite of dependent test cases as this TC failed
				[[ ${SPEC_TS_INDEPENDENT} -eq 0 ]] && break
			fi
		done

		# Test suite cleanup

		# CALLBACK: TS_CLEANUP
		# Run callback TS_CLEANUP with timeout
	
		timeouter ${SPEC_TS_TIMEOUT} "${AT_CALLBACK_SCRIPT} AT_TS ${ts_path} ${SPEC_TS_ID} TS_CLEANUP"
		ret=$?
		if [[ ${ret} -ne 0 ]]; then
			printf "ERROR: TS [${ts_name}]: TS_CLEANUP callback failed; error [${ret}]\n"
		fi

		datetime=$(date "+%Y-%m-%d %H:%M:%S")
		printf "${datetime} END TS [${ts_name}]\n\n"
	done
fi

if [[ ${option_a} -eq 1 || ${option_u} -eq 1 || ${option_i} -eq 1 ]]; then

	# Create the FA results directory
	ret=$(${MKDIR} -p ${AT_RESULTS_DIR}/FA; echo $?)
	if [[ ${ret} -ne 0 ]]; then
		printf "ERROR: [${MKDIR} -p ${AT_RESULTS_DIR}/FA failed; error [${ret}]\n"
		exit 1
	fi

	# Resolve command line selection into array of TC IDs
	get_TCs ${CMD_SCOPE} 

	# Run TCs
	for cmd_tc in ${CMD_TCs[@]}; do
		run_TC ${cmd_tc} AT_TC
	done
fi

# Stats
if [[ ${option_S} -eq 1 ]]; then
	write_stats_txt
	write_stats_html
fi

# Reports 
if [[ ${option_l} -ne 1 ]]; then
	write_report_txt ${CMD_SCOPE}
	write_report_html ${CMD_SCOPE}
	# Tar file of results for CI collection 
	write_report_archive
fi

if [[ ${option_S} -eq 1 ]]; then
	printf "\nFA stats (txt): ${AT_FA_STATS}\n"
	printf "UC stats (txt): ${AT_UC_STATS}\n"
	printf "Stats (html): ${AT_STATS_HTML}\n"
fi

printf "Exiting number of failed callbacks: [${AT_NUM_FAILED_CALLBACKS}]\n\n" 
exit ${AT_NUM_FAILED_CALLBACKS}
