#!/bin/bash
#################################################################################
#
#
#       COPYRIGHT (C) ERICSSON RADIO SYSTEMS AB, Sweden
#
#       The copyright to the document(s) herein is the property of
#       Ericsson Radio Systems AB, Sweden.
#
#       The document(s) may be used and/or copied only with the written
#       permission from Ericsson Radio Systems AB or in accordance with
#       the terms and conditions stipulated in the agreement/contract
#       under which the document(s) have been supplied.
#
#################################################################################

# NFD function library
# NOTE: Please keep function names consistent and meaningful. i.e use 'get','set','is' 
#       Please use a variable called RESULT to store the result of a Function, or preferably 
#       echo the string so that the funtion name can be used as the return string as indicated in the example below.
# E.G.  [[ $(getHostname) == "atrcxb2214" ]]

# Revision History
# 10/08/2012    eeidle         Initial script
#   Provides a set of library functions related to SCK,USCK, STG and SOLARIS Teams

###################
# GLOBAL VARIABLES
###################

ARCH="`uname -p`"
HASTATUS=${HASTATUS:-/opt/VRTS/bin/hastatus}
HAGRP=${HAGRP:-/opt/VRTS/bin/hagrp}
HASYS=${HASYS:-/opt/VRTS/bin/hasys}
HACLUS=${HACLUS:-/opt/VRTS/bin/haclus}

LDAPLIST=${LDAPLIST:-/bin/ldaplist}
LDAPCLIENT=${LDAPCLIENT:-/bin/ldapclient}
LDAP_CLIENT_FILE="/var/ldap/ldap_client_file"

AWK=${AWK:-/bin/awk}
#CAT=${CAT:-/bin/cat}
#ECHO=${ECHO:-/bin/echo}
GREP=/usr/xpg4/bin/grep #The other version of grep doesnt support -q and some other options.
UNIQ=${UNIQ:-/bin/uniq}
WC=${WC:-/bin/wc}

ETCHOSTS=${ETCHOSTS:-"/etc/hosts"}

G_SMTOOL=/opt/ericsson/nms_cif_sm/bin/smtool
GEGREP=/usr/sfw/bin/gegrep
DMTOOL=/ericsson/dmr/bin/dmtool
G_EXPECT_DIR="${AT_LIB}/exp_files"
G_LIC_SERVER="159.107.220.96"
G_usr_LIC_SERVER="ossread"
G_pwd_LIC_SERVER="ossread"
CI_UPDATE_OLD_WEBSITE=FALSE

[[ $(uname) == "Linux" ]] && {
			PING=/bin/ping
			EXPECT=/usr/bin/expect
			BANNER=bashBanner
			CP=/bin/cp
			CAT=/bin/cat
			ECHO=/bin/echo
			RM=/bin/rm
			SED=/bin/sed
			SLEEP=/bin/sleep
	}

[[ $(uname) == "SunOS" ]] && {
			PING=/usr/sbin/ping
			if [ -x /usr/local/bin/expect ]; then 
				EXPECT=/usr/local/bin/expect
			elif [ -x /app/expect/5.40.1/bin/expect  ]; then
				EXPECT=/app/expect/5.40.1/bin/expect
			fi
			BANNER=/bin/banner
			CP=/usr/bin/cp
			CAT=/usr/bin/cat
			ECHO=/usr/bin/echo
			RM=/usr/bin/rm
			SED=/usr/xpg4/bin/sed
			SLEEP=/usr/bin/sleep
	}

[ -x "$EXPECT" ] || {
	echo "Unable to find expect binary - aborting" 
	return 1
}


#[[ $(uname) == "Linux" ]] && EXPECT=/usr/bin/expect
#[[ $(uname) == "SunOS" ]] && EXPECT=/usr/local/bin/expect
#[[ $(uname) == "Linux" ]] && BANNER=bashBanner
#[[ $(uname) == "SunOS" ]] && BANNER=/bin/banner
#[[ $(uname) == "Linux" ]] && CP=/bin/cp
#[[ $(uname) == "SunOS" ]] && CP=/usr/bin/cp
#[[ $(uname) == "Linux" ]] && CAT=/bin/cat
#[[ $(uname) == "SunOS" ]] && CAT=/usr/bin/cat
#[[ $(uname) == "Linux" ]] && ECHO=/bin/echo
#[[ $(uname) == "SunOS" ]] && ECHO=/usr/bin/echo
#[[ $(uname) == "Linux" ]] && RM=/bin/rm
#[[ $(uname) == "SunOS" ]] && RM=/usr/bin/rm
#[[ $(uname) == "Linux" ]] && SLEEP=/bin/sleep
#[[ $(uname) == "SunOS" ]] && SLEEP=/usr/bin/sleep


###################
# FUNCTIONS
###################
# Function: getHAsysNames
# Purpose: Sets variables "SYS_#" to the hostname for each cluster member
# Usage: : getHAsysNames 
#
# Arguments:
# None
#
# Return Values:
# 0     Completed OK
# 1     Something went wrong
#
## Input globals accessed by this function
# none
#
# Output globals set by this function
# SYS_1 ; SYS_2; etc 
# HA_ClusterSize (number of hosts in the cluster)
# HA_RunningHosts (Number of hosts which are running)
function getHAsysNames() {

local count=0

	for host in `${HASYS} -list` ;do
		(( count++ ))
		export SYS_${count}="${host}"
		
	done
HA_ClusterSize=${count}
HA_RunningHosts=`$HASYS -state |grep -c "RUNNING"`


}

###################
# FUNCTIONS
###################
# Function: checkHAgrps
# Purpose: check all defined groups in HA to see if running
# Usage: : checkHAgrps 
#
# Arguments:
# None
#
# Return Values:
# 0     All HA groups are online
# 1     One or more HA groups are incorrectly offline.
# 2	HA groups are online on more hosts than should be
#
## Input globals accessed by this function
# none
#
# Output globals set by this function
# HA_GRP_STATUS  can be used for post function parsing.  ie. use StringSearch to check the file after this function
#

function checkHAgrps() {

local _date=`date +%Y%m%d.%H%M%S`
local _logdir="/var/tmp/platform_taf/LOGS"
local _logfile="/var/tmp/platform_taf/LOGS/checkHAgrps_${_date}"
local _tmpfile="/var/tmp/HA_grp_status"

	[[ ! -d ${Logdir} ]] && {
		 mkdir -p ${_logdir}
		chmod -fR 777 ${_logdir}
	}
	cat /dev/null > $_tmpfile

# Capture status to log file if required for later.
`$HASTATUS -sum > "${_logfile}"`
echo -e "\n========================================================================" >> ${_logfile}


getHAsysNames


echo "
=====================================================
Cluster size: [$HA_ClusterSize]
Number of hosts currently running in the cluster: [$HA_RunningHosts]
Log file: [$_logfile]
=====================================================
" 

	for grp in `$HAGRP -list | awk '{print $1}' | uniq` ;do

		local parallel=`$HAGRP -display "${grp}" -attribute Parallel |tail -1 |awk '{print $4}'`
		grp_state=`$HAGRP -state "${grp}" | grep ${grp} | tr -d \| | awk '{print $1" "$3" "$4}'`
		

		if [ ${parallel} == 1 ] ; then
			num_grps=99
			num_grps=`echo "${grp_state}" | $GEGREP -wo "ONLINE" | grep -c "ONLINE"`
			
			[[ ${num_grps} -lt ${HA_RunningHosts} ]] && echo "[NOK] Group: [${grp}] is running on [${num_grps}] hosts. Should be [${HA_RunningHosts}]." >> ${_tmpfile}
			[[ ${num_grps} -eq ${HA_RunningHosts} ]] && echo "[OK] Group: [${grp}] is running on [${num_grps}] hosts. Should be [${HA_RunningHosts}]." >> ${_tmpfile}
			[[ ${num_grps} -gt ${HA_RunningHosts} ]] && echo "[ERROR] Group: [${grp}] is running on [${num_grps}] hosts. Should be [${HA_RunningHosts}]." >> ${_tmpfile}

		elif [ ${parallel} == 0 ] ; then
			num_grps=99
			num_grps=`echo "${grp_state}" | $GEGREP -wo "ONLINE" | grep -c "ONLINE"`

			[[ ${num_grps} -lt 1 ]] && echo "[NOK] Group: [${grp}] is running on [${num_grps}] hosts. Should be [1]." >> ${_tmpfile}
			[[ ${num_grps} -eq 1 ]] && echo "[OK] Group: [${grp}] is running on [${num_grps}] hosts. Should be [1]." >> ${_tmpfile}
			[[ ${num_grps} -gt 1 ]] && echo "[ERROR] Group: [${grp}] is running on [${num_grps}] hosts. Should be [1]." >> ${_tmpfile}
			
		fi
	
	done

	export HA_GRP_STATUS=${_tmpfile}    # to give direct access to the result file to other external functions.
	cat ${_tmpfile} >> ${_logfile}   # save a copy of the processed group status to the log.

# below line can be used for negative testing
#echo -e "[NOK] test 1\n[ERROR] test2\ntest3 [NOK]\ntest4 [ERROR]" >> ${_tmpfile}	

	local _errors=`grep "^\[NOK\]" ${_tmpfile}`
	local _warnings=`grep "^\[ERROR\]" ${_tmpfile}`
	[[ -n ${_errors} ]] && banner error! && echo -e "Errors found:\n===============\n${_errors}" && return 1
	[[ -n ${_warnings} ]] && banner warning! && echo -e "Warnings found:\n===============\n${_warnings}" && return 2


	echo -e "==========================================================\nHA groups are OK:\n==========================================================\n`cat ${_tmpfile}`\n==========================================================\n"

return 0
}

###################
# FUNCTIONS
###################
# Function: isCmdExecutable
# Purpose: Validate that a command that is specified exists on the server and is executable
# Usage: : isCmdExecutable <full path to command>
#
# Arguments:
# $1 Full path to command
#
# Return Values:
# 0     Success, command found and is executable by 
# 1     Failure, command not found.
#
## Input globals accessed by this function
# none
#
# Output globals set by this function
# none
#

function isCmdExecutable() { # <full path to command>
        local cmd=$1

        if [[ -x "${cmd}" ]]; then
                echo "${cmd} is executable"
                return 0
        else
                echo "ERROR:${cmd} not executable, exiting function ${FUNCNAME} ${@}"
                return 1
        fi
}


##############################
# Function: StringSearch()
# Purpose: To check for a string in a log file, directory, or command output.
# Usage: : StringSearch -f <file> | -d <directory> | -c <command> -s <string> [-e <exclude_list>] [-w <warn_list>]
#
# Return Values:
#      0        String not found
#      1        String found
#      2        Something went wrong
#      255      String found but is classed as a warning (currently returns 0)
#
# Input globals accessed by this function
# GEGREP
#
# Output globals set by this function
# ERRORS
# WARNINGS
#
function StringSearch() {
unset ExcludeList
unset WarnList
unset ERRORS
unset WARNINGS

while getopts e:f:d:c:s:w: opt; do
        case ${opt} in

        f)      FileName=$OPTARG
               [ ! -f ${FileName} ] && echo -e "${FileName} not found or not a file" && return 2
               ;;
        d)      DirName=$OPTARG
               [ ! -d ${DirName} ] && echo -e "${DirName} not found or not a directoy" && return 2
                ;;
        c)      CmdName=$OPTARG
               [ ! -e ${CmdName} ] && echo -e "${CmdName} not found" && return 2
                ;;
        s)      ErrString=$OPTARG
                [[ -z ${ErrString} ]] && echo -e "-s option used without a value" && return 2
                ;;
        e)      ExcludeList=${OPTARG}
		[[ -z ${ExcludeList} ]] && echo -e "-e option used without a value" && return 2
                ;;
        w)      WarnList=${OPTARG}
		[[ -z ${WarnList} ]] && echo -e "-w option used without a value" && return 2
                ;;

        esac

done


        [[ ( -z ${FileName} )  &&  ( -z ${DirName} )  &&  ( -z ${CmdName} ) ]] && echo -e "one of -f -d -c must be set" && return 2
        [ -z "${ErrString}" ] && echo -e "Error String is null\n" && return 2


echo "
FileName: ${FileName}
DirName: ${DirName}
CmdName: ${CmdName}
ErrString: ${ErrString}
ExcludeList: "${ExcludeList}"
WarnList: ${WarnList}
"



        if [[ -n "${ExcludeList}" ]];then
                [[ -n ${FileName} ]] && RESULTS1=`cat ${FileName} | $GEGREP -i "${ErrString}" | $GEGREP -v "${ExcludeList}"`
                [[ -n ${DirName} ]] && RESULTS2=`$GEGREP -i "${ErrString}" "${DirName}"/* | $GEGREP -v "${ExcludeList}"`
                [[ -n ${CmdName} ]] && RESULTS3=`${CmdName} | $GEGREP -i "${ErrString}" | $GEGREP -v "${ExcludeList}"`

        else
		echo "exclude list has no value"
                [[ -n ${FileName} ]] && RESULTS1=`cat ${FileName} | $GEGREP -i "${ErrString}"`
                [[ -n ${DirName} ]] && RESULTS2=`$GEGREP -i "${ErrString}" "${DirName}"/*`
                [[ -n ${CmdName} ]] && RESULTS3=`${CmdName} | $GEGREP -i "${ErrString}"`
        fi





        RESULTS=`echo -e "${RESULTS1}\n${RESULTS2}\n${RESULTS3}"`
        [[ -z "${RESULTS}" ]] && echo "no errors" && return 0


        if [[ -n "${WarnList}" ]];then
		echo "Warn List is NOT empty"
                ERRORS=`echo "${RESULTS}"  | $GEGREP -v "${WarnList}"`
                [[ -n "${ERRORS}" ]] && banner "ERR found" && echo -e "Error List:\n$ERRORS\n"
                WARNINGS=`echo "${RESULTS}"  | $GEGREP "${WarnList}"`
                [[ -n "${WARNINGS}" ]] && banner "WA found" && echo -e "Warnings found:\n$WARNINGS\n" 
		[ -n "${ERRORS}" ] && return 1
        else
		echo "Warn List is empty."
		banner "ERROR found" && echo -e "Error List:\n$RESULTS\n" && return 1
        fi

export ERRORS
export WARNINGS

}

##############################
# Function: BuildMCExcludeList()
# Purpose: To generate a list of MCs whos status can be ignored based on the architecture/release
# Usage: : BuildMCExcludeList
#
# Return Values:
#      0        Success
#      1        Failure
#
# Input globals accessed by this function
# MC_EXCLUDE_FILE
#
# Output globals set by this function
# MC_EXCLUDE_LIST
function BuildMCExcludeList() {

MC_EXCLUDE_FILE=${AT_ROOT}/excluded_mcs.txt
local sparcMCs=""
local x86MCs=""
local commonMCs="BI_SMRS_MC\nnetop_ems"


	echo -e ${commonMCs} > ${MC_EXCLUDE_FILE}
	[ ! -f ${MC_EXCLUDE_FILE} ] && return 1 


	case ${ARCH} in
        
        i386|x86*)   
                echo -e ${x86MCs} >> ${MC_EXCLUDE_FILE}
                ;;
        sparc)
                echo -e ${sparcMCs} >> ${MC_EXCLUDE_FILE}
                ;;
        esac


	MC_EXCLUDE_LIST=`cat ${MC_EXCLUDE_FILE} | $SED '/^$/d' |$SED -e :a -e '$!N; s/\n/|/; ta'`

return 0
}






##############################
# Function: areAllManagedComponents()
# Purpose: Validate that All managed components except those listed are <-online> or <-offline>
# Usage: : areAllManagedComponents <-online|-offline> [-except <MC1>,<MC2>|-exceptthosein <file>]
#
# Return Values: 
#      0	Success
#      1	Failure
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
function areAllManagedComponents() { # <-online|-offline> [-except <MC1>,<MC2>|-exceptthosein <file>]
	# -exceptthosein <file> is not implemented yet
	#set -xv
	if (( ${#} > 3 )) ; then
		${ECHO} "Usage: Too many arguments: AreManagedComponents <-online|-offline> [-except <MC1>,<MC2>|-exceptthosein <file>]"
		return 1
	fi
	local ACTION=$1  # -online|-offline
	local EXCEPT=$2  # -except|-exceptthosein
	local MCS_TO_EXCLUDE="$3"
	local MC_COUNT=""
	local MCS_NOT_MEETING_CRITERIA
	#replace , with | for egrep arguments. 
	#Using text EXCLUDE_LIST as a cheat so that egrep will never have empty argument.
	MCS_TO_EXCLUDE=$($ECHO "${MCS_TO_EXCLUDE}|EXCLUDE_LIST" | $SED s'/,/\|/g')
	
	if [ "$ACTION" = "-online" ]; then
		ACTION="started"
	fi
	if [ "$ACTION" = "-offline" ]; then
		ACTION="offline"

	fi
	echo "Checking if all the Managed Components are $ACTION" #| tee -a ${LOGFILE}
	echo "-------------------------------------------------" #| tee -a ${LOGFILE}
	MC_COUNT=$(${G_SMTOOL} list | egrep -v $ACTION | egrep -v "${MCS_TO_EXCLUDE}" | wc -l)

	if [ $MC_COUNT == 0 ] ;then
			echo "All Required Managed Components (MCs) are $ACTION" #| tee -a ${LOGFILE}
			return 0
	else
			MCS_NOT_MEETING_CRITERIA=$($G_SMTOOL list | grep -v $ACTION | egrep -v "${MCS_TO_EXCLUDE}")
			echo "The below MC's are NOT $ACTION" #| tee -a ${LOGFILE}
			echo "$MCS_NOT_MEETING_CRITERIA" #| tee -a ${LOGFILE}
			return 1
	fi
	
}

############################# Start: Functions related to HA status #############################

##############################
# Function: getAdmin1Hostname
# Purpose: Get the hostname of the current Admin1
# Usage: getAdmin1Hostname
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The hostname of Admin1
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getAdmin1Hostname() {

        # Admin1 is the node which has the Oss state ONLINE

        # Before that we will ensure that there is no issue with hastatus
        if [[ $(${HASTATUS} -sum >/dev/null 2>&1) -ne 0 ]] ; then
                ${ECHO} "ERROR: getAdmin1Hostname"
                return 1
        fi

        RESULT=$(${HAGRP} -display Oss -attribute State | ${GREP} ONLINE | ${AWK} '{print $3}')
        ${ECHO} "${RESULT}"

        return 0
}

##############################
# Function: getAdmin2Hostname
# Purpose: Get the hostname of the current Admin2
# Usage: getAdmin2Hostname
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The hostname of Admin2
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getAdmin2Hostname() {

        # Admin2 is the node which has the Oss state OFFLINE

        # Before that we will ensure that there is no issue with hastatus
        if [[ $(${HASTATUS} -sum >/dev/null 2>&1) -ne 0 ]] ; then
                ${ECHO} "ERROR: getAdmin2Hostname"
                return 1
        fi

        RESULT=$(${HAGRP} -display Oss -attribute State | ${GREP} OFFLINE | ${AWK} '{print $3}')
        ${ECHO} "${RESULT}"

        return 0
}

##############################
# Function: isServerAdmin1
# Purpose: Check if the specified server is Admin1
# Usage: isServerAdmin1 <servername>
#
# Return Values:
# 0     <servername> is not Admin1
# 1     <servername> is Admin1
# 2     Error in fetching hostname
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isServerAdmin1() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isServerAdmin1 <servername>"
                return 2
        fi

        # Get the hostname of the Admin1
        getAdmin1Hostname

        if [[ $? -eq 1 || "${RESULT}" == "" ]] ; then
                ${ECHO} "ERROR: isServerAdmin1"
                return 2
        fi

        if [[ "${RESULT}" == "$1" ]] ; then
                ${ECHO} "1"
                return 1
        fi

        ${ECHO} "0"
        return 0
}

##############################
# Function: isServerAdmin2
# Purpose: Check if the specified server is Admin2
# Usage: isServerAdmin2 <servername>
#
# Return Values:
# 0     <servername> is not Admin2
# 1     <servername> is Admin2
# 2     Error in fetching hostname
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isServerAdmin2() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isServerAdmin2 <servername>"
                return 2
        fi

        # Get the hostname of the Admin1
        getAdmin2Hostname

        if [[ $? -eq 1 || "${RESULT}" == "" ]] ; then
                ${ECHO} "ERROR: isServerAdmin2"
                return 2
        fi

        if [[ "${RESULT}" == "$1" ]] ; then
                ${ECHO} "1"
                return 1
        fi

        ${ECHO} "0"
        return 0
}

##############################
# Function: isHaGroupOnline
# Purpose: Check if the server is Online for specified groupname and hostname
# Usage: isHaGroupOnline <groupname> <hostname>
#
# Return Values:
# 0     <groupname> is offline
# 1     <groupname> is online
# 2     Error in fetching group details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isHaGroupOnline() {

        if (( ${#} < 2 )) ; then
                ${ECHO} "Usage: isHaGroupOnline <groupname> <hostname>"
                return 2
        fi

        RESULT=$(${HAGRP} -state "${1}" -sys "${2}")
        if [[ "${RESULT}" == "ONLINE" ]] ; then
                #${ECHO} "1"
                return 1
        elif [[ "${RESULT}" == "OFFLINE" ]] ; then
                #${ECHO} "0"
                return 0
        else
                ${ECHO} "ERROR: isHaGroupOnline ${1} ${2}"
                return 2
        fi
}

##############################
# Function: isHaStateRunningForServer
# Purpose: Check if the server is running for specified hostname
# Usage: isHaStateRunningForServer <hostname>
#
# Return Values:
# 0     <hostname> is RUNNING
# 1     <hostname> has EXITED
# 2     Error in fetching state details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isHaStateRunningForServer() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isHaStateRunningForServer <hostname>"
                return 2
        fi

        RESULT=$(${HASYS} -state "${1}")

        if [[ "${RESULT}" == "RUNNING" ]] ; then
                ${ECHO} "0"
                return 0
        elif [[ "${RESULT}" == "EXITED" ]] ; then
                ${ECHO} "1"
                return 1
        else
                ${ECHO} "ERROR: isHaStateRunningForServer ${1}"
                return 2
        fi
}

##############################
# Function: isHaStateRunningForCluster
# Purpose: Check if the server is running for specified cluster
# Usage: isHaStateRunningForCluster <clustername>
#
# Return Values:
# 0     <clustername> is RUNNING
# 1     <clustername> has EXITED
# 2     Error in fetching state details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isHaStateRunningForCluster() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isHaStateRunningForCluster <clustername>"
                return 2
        fi

        RESULT=$(${HACLUS} -state "${1}")

        if [[ "${RESULT}" == "RUNNING" ]] ; then
                ${ECHO} "0"
                return 0
        elif [[ "${RESULT}" == "EXITED" ]] ; then
                ${ECHO} "1"
                return 1
        else
                ${ECHO} "ERROR: isHaStateRunningForCluster ${1}"
                return 2
        fi
}

##############################
# Function: isHaStatusNormal
# Purpose: Check if the services are running normally for admin1 and admin2
# Usage: isHaStatusNormal
#
# Return Values:
# 0     HA status is normal
# 1     HA status is not normal
# 2     Error in fetching service details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
#function isHaStatusNormal() {
#}

#function isHaClusterSplit() {
#        return 1
#}
#

############################# End: Functions related to HA status ###############################

############################# Start: Functions related to /etc/passwd and /etc/hosts ############

##############################
# Function: isUserInEtcPasswd
# Purpose: Check if the specified user is in /etc/passwd file
# Usage: isUserInEtcPasswd <username>
#
# Return Values:
# 0     <username> is present in /etc/passwd
# 1     <username> is not present in /etc/passwd
# 2     Error in fetching username details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isUserInEtcPasswd() {

        ETCPASSWD="/etc/passwd"

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isUserInEtcPasswd <username>"
                RESULT=2
                return 2
        fi

        if [[ ! -r ${ETCPASSWD} ]] ; then
                ${ECHO} "ERROR: isUserInEtcPasswd"
                RESULT=2
                return 2
        fi

        if [[ $(${GREP} -w "^${1}" ${ETCPASSWD} >/dev/null 2>&1) -eq 0 ]] ; then
                ${ECHO} "0"
                RESULT=0
                return 0
        fi

        RESULT=1
        ${ECHO} "1"
        return 1
}

##############################
# Function: getEtcHostsIpAddressfor
# Purpose: Get the Ip Address for specified hostname/nickname from /etc/hosts file
# Usage: getEtcHostsIpAddressfor <hostname/nickname>
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The IP Address for specified hostname/nickname
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getEtcHostsIpAddressfor() { # <name in /etc/hosts>

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: getEtcHostsIpAddressfor <hostname/nickname>"
                RESULT=""
                return 2
        fi

        #TODO: <Validate the input "name" as given in  "man hosts">

        RESULT=$(${GREP} -v "^[         ]*#" ${ETCHOSTS} | ${SED} 's/\(.*\)#.*/\1/' | ${GREP} -wi ${1} | ${AWK} '{print $1}')

        if [[ "${RESULT}" == "" ]] ; then
                return 1
        fi

        return 0
}

##############################
# Function: isIpAddressInEtcHosts
# Purpose: Check if the specified Ip Address is in /etc/hosts file
# Usage: isIpAddressInEtcHosts <ipaddress>
#
# Return Values:
# 0     <ipaddress> is present in /etc/hosts
# 1     <ipaddress> is not present in /etc/hosts
# 2     Error in fetching hosts details or invalid input
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isIpAddressInEtcHosts() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isIpAddressInEtcHosts <ipaddress>"
                RESULT=2
                return 2
        fi

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: isIpAddressInEtcHosts: Cannot read ${ETCHOSTS}"
                RESULT=2
                return 2
        fi

        #TODO: <Need to check if IP Address is valid>

        if [[ $(${GREP} -w "^${1}" ${ETCHOSTS} >/dev/null 2>&1) -eq 0 ]] ; then
                ${ECHO} "0"
                RESULT=0
                return 0
        fi

        RESULT=1
        ${ECHO} "1"
        return 1
}

##############################
# Function: isHostnameInEtcHosts
# Purpose: Check if the specified hostname is in /etc/hosts file
# Usage: isHostnameInEtcHosts <hostname>
#
# Return Values:
# 0     <hostname> is present in /etc/hosts
# 1     <hostname> is not present in /etc/hosts
# 2     Error in fetching hosts details or invalid input
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isHostnameInEtcHosts() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isHostnameInEtcHosts <hostname>"
                RESULT=2
                return 2
        fi

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: isHostnameInEtcHosts: Cannot read ${ETCHOSTS}"
                RESULT=2
                return 2
        fi

        #TODO: <Need to check if hostname is valid>

        # Domain names are case insensitive
        if [[ $(${GREP} -v "^[  ]*#" ${ETCHOSTS} | ${AWK} '{print $2}' | ${GREP} -q -i ${1}) -eq 0 ]] ; then
                ${ECHO} "0"
                RESULT=0
                return 0
        fi

        RESULT=1
        ${ECHO} "1"
        return 1
}

##############################
# Function: areAllIpAddressesUniqueInEtcHosts
# Purpose: Check if  all the ipaddresses in /etc/hosts are unique
# Usage: areAllIpAddressesUniqueInEtcHosts
#
# Return Values:
# 0     All the ipaddresses in /etc/hosts are unique
# 1     IpAddresses are not unique
# 2     Error in fetching hosts details
#
##############################
function areAllIpAddressesUniqueInEtcHosts() {

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: areAllIpAddressesUniqueInEtcHosts: Cannot read ${ETCHOSTS}"
                RESULT=2
                return 2
        fi

        etchosts_ips=$(${CAT} ${ETCHOSTS} | ${AWK} '{print $1}' | ${UNIQ} -d)

        if [[ -z "${etchosts_ips}" ]]; then
                return 0
        else
                return 1
        fi
}

##############################
# Function: getNasConsoleForServer
# Purpose: Get the Nas Console Ip Address 
# Usage: getNasConsoleForServer
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The Nas Console IP Address
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getNasConsoleForServer() {

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: getNasConsoleForServer: Cannot read ${ETCHOSTS}"
                RESULT=""
                return 1
        fi

        # NR == 1 check for making sure we pick first one if more than one entry found for nasconsole
        RESULT=$(${GREP} -v "^[     ]*#" ${ETCHOSTS} | 
                 ${GREP} -w -i "nasconsole" ${ETCHOSTS} | ${AWK} 'NR == 1 {print $1}')

        # nasconsole was not present in /etc/hosts
        if [[ -z "${RESULT}" ]] ; then
                return 1
        fi

        ${ECHO} "${RESULT}"
       
        return 0
}

##############################
# Function: getNas1IpAddressForServer
# Purpose: Get the Nas1 Ip Address 
# Usage: getNas1IpAddressForServer
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The Nas 1 IP Address
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getNas1IpAddressForServer() {

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: getNas1IpAddressForServer: Cannot read ${ETCHOSTS}"
                RESULT=""
                return 1
        fi

        # NR == 1 check for making sure we pick first one if more than one entry found for nas 1
        RESULT=$(${GREP} -v "^[     ]*#" ${ETCHOSTS} | 
                 ${GREP} -w -i "nas1" ${ETCHOSTS} | ${AWK} 'NR == 1 {print $1}')

        # nas1 was not present in /etc/hosts
        if [[ -z "${RESULT}" ]] ; then
                return 1
        fi

        ${ECHO} "${RESULT}"
       
        return 0
}


##############################
# Function: getNas2IpAddressForServer
# Purpose: Get the Nas 2 Ip Address 
# Usage: getNas2IpAddressForServer
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The Nas 2 IP Address
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getNas2IpAddressForServer() {

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: getNas2IpAddressForServer: Cannot read ${ETCHOSTS}"
                RESULT=""
                return 1
        fi

        # NR == 1 check for making sure we pick first one if more than one entry found for nas 2
        RESULT=$(${GREP} -v "^[     ]*#" ${ETCHOSTS} | 
                 ${GREP} -w -i "nas2" ${ETCHOSTS} | ${AWK} 'NR == 1 {print $1}')

        # nas2 was not present in /etc/hosts
        if [[ -z "${RESULT}" ]] ; then
                return 1
        fi

        ${ECHO} "${RESULT}"
       
        return 0
}


##############################
# Function: areCorrectPermissionsOnFile
# Purpose: Check if a file has the matching permissions as specified
#
# Usage: areCorrectPermissionsOnFile <filename> <permissions>
#
# Return Values:
# 0     File does not have matching permissions as specified
# 1     File has matching permissions as specified
# 2     Error in fetching details or invalid input
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function areCorrectPermissionsOnFile() {

        if (( ${#} < 2 )) ; then
                ${ECHO} "Usage: areCorrectPermissionsOnFile <filename> <permissions>"
                ${ECHO} "Refer man chmod for syntax of file permissions"
                RESULT=2
                return 2
        fi

        if [[ ! -f "${1}" ]] ; then
                ${ECHO} "ERROR: areCorrectPermissionsOnFile: File does not exist: ${1}"
                RESULT=2
                return 2
        fi

        # If the permissions match, then the find command will return the filename
        RESULT=$(${FIND} "${1}" -prune -perm "${2}" -name "${1}" 2>&1)
        retVal=$?

        # retVal is not zero indicates a problem in find.
        if [[ $retVal -ne 0 ]] ; then
                ${ECHO} "ERROR: areCorrectPermissionsOnFile: Incorrect permissions entered: ${2}"
                ${ECHO} "Refer man chmod for syntax of file permissions"
                RESULT=2
                return 2

        fi

        if [[ "${RESULT}" != "${1}" ]] ; then
                RESULT=1
                return 1
        fi

        RESULT=0
        return 0
}

##############################
# Function: areCorrectPermissionsOnDirectory
# Purpose: Check if a directory has the matching permissions as specified
#
# Usage: areCorrectPermissionsOnDirectory <dirname> <permissions>
#
# Return Values:

# 0     Directory have matching permissions as specified
# 1     Directory does not exist
# 2     Error in fetching details or invalid input
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function areCorrectPermissionsOnDirectory() {

if (( ${#} < 2 )) ; then
                ${echo} "Usage: areCorrectPermissionsOnDirectory <dirname> <permissions>"
                ${echo} "Refer man chmod for syntax of file permissions"
                return 2
        fi

        if [[ ! -d "${1}" ]] ; then
                ${echo} "ERROR: areCorrectPermissionsOnDirectory: Dir does not exist: ${1}"
                return 1
        fi

        # If the permissions match, then the find command will return the filename

        RESULT=$(find "$1" -prune "-perm" "$2" 2>/dev/null)
        retVal=$?

        if [ "$RESULT" == "$1" ]; then
        echo "Directory permission of $1 match with $2"
        return 0
        fi

}

##############################
# Function: isPmsVipOnSeparateIpAddress
# Purpose: Check if pms vip has a separate IP Address
# Usage: isPmsVipOnSeparateIpAddress
#
# Return Values:
# 0     pms vip is the same as masterservice ip
# 1     pms vip is not the same as masterservice ip
# 2     Error in fetching hosts details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isPmsVipOnSeparateIpAddress() {

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: isPmsVipOnSeparateIpAddress: Cannot read ${ETCHOSTS}"
                RESULT=2
                return 2
        fi

        masterservice_ip=$(${GREP} -v "[ 	]*#" ${ETCHOSTS} | 
                           ${GREP} -w -i "masterservice" | ${AWK} 'NR == 1 {print $1}')

        pms_vip=$(${GREP} -v "[        ]*#" ${ETCHOSTS} |
                  ${GREP} -w -i "pms-vip" | ${AWK} 'NR == 1 {print $1}')

        if [[ "${masterservice_ip}" == "${pms_vip}" ]] ; then
                RESULT=1
                return 1
        fi

        RESULT=0
        return 0
}

##############################
# Function: isCmsVipOnSeparateIpAddress
# Purpose: Check if cms vip has a separate IP Address
# Usage: isCmsVipOnSeparateIpAddress
#
# Return Values:
# 0     cms vip is the same as masterservice ip
# 1     cms vip is not the same as masterservice ip
# 2     Error in fetching hosts details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isCmsVipOnSeparateIpAddress() {

        if [[ ! -r ${ETCHOSTS} ]] ; then
                ${ECHO} "ERROR: isCmsVipOnSeparateIpAddress: Cannot read ${ETCHOSTS}"
                RESULT=2
                return 2
        fi

        masterservice_ip=$(${GREP} -v "[ 	]*#" ${ETCHOSTS} | 
                           ${GREP} -w -i "masterservice" | ${AWK} 'NR == 1 {print $1}')

        cms_vip=$(${GREP} -v "[        ]*#" ${ETCHOSTS} |
                  ${GREP} -w -i "cms-vip" | ${AWK} 'NR == 1 {print $1}')

        if [[ "${masterservice_ip}" == "${cms_vip}" ]] ; then
                RESULT=1
                return 1
        fi

        RESULT=0
        return 0
}

##############################
# Function: getAdmin1StorageVip
# Purpose: Get the Admin 1 Storage Vip
# Usage: getAdmin1StorageVip
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The Admin 1 storage vip
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getAdmin1StorageVip() {
        
        # Get the hostname of the Admin1
        getAdmin1Hostname
        if [[ $? -eq 1 || "${RESULT}" == "" ]] ; then
                ${ECHO} "ERROR: getAdmin1StorageVip : Could not fetch Admin1 hostname details"
                return 1
        fi

        admin1_hostname="${RESULT}"

        RESULT=$(${NAWK} -F"=" '/systemname='"${admin1_hostname}"'/,/storIPaddress=/ 
                 { if(match($0,/storIPaddress/)){print $2} }' /ericsson/config/cluster.ini)

        if [[ -z "${RESULT}" ]] ; then
                ${ECHO} "ERROR: getAdmin1StorageVip : Could not fetch Admin1 Storage Vip"
                return 1
        fi

        #TODO: Nice to have: Check if RESULT is in a proper IP Address format.

        return 0
}

##############################
# Function: getAdmin2StorageVip
# Purpose: Get the Admin 2 Storage Vip
# Usage: getAdmin2StorageVip
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        The Admin 2 storage vip
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getAdmin2StorageVip() {
        
        # Get the hostname of the Admin2
        getAdmin2Hostname
        if [[ $? -eq 1 || "${RESULT}" == "" ]] ; then
                ${ECHO} "ERROR: getAdmin2StorageVip : Could not fetch Admin2 hostname details"
                return 1
        fi

        admin2_hostname="${RESULT}"

        RESULT=$(${NAWK} -F"=" '/systemname='"${admin2_hostname}"'/,/storIPaddress=/ 
                 { if(match($0,/storIPaddress/)){print $2} }' /ericsson/config/cluster.ini)

        if [[ -z "${RESULT}" ]] ; then
                ${ECHO} "ERROR: getAdmin2StorageVip : Could not fetch Admin2 Storage Vip"
                return 1
        fi

        #TODO: Nice to have: Check if RESULT is in a proper IP Address format.

        return 0
}


############################# End: Functions related to /etc/passwd and /etc/hosts ##############

############################# Start: Functions related to LDAP ##################################

##############################
# Function: isUserInLDAP
# Purpose: Check if the specified user is configured in LDAP
# Usage: isUserInLDAP <username>
#
# Return Values:
# 0     <username> is not present in LDAP
# 1     <username> is present in LDAP
# 2     Error in fetching LDAP details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function isUserInLDAP() {

        if (( ${#} < 1 )) ; then
                ${ECHO} "Usage: isUserInLDAP <username>"
                RESULT=2
                return 2
        fi

        #Check if LDAP client is configured, if not flag error

        if [[ ! -f "${LDAP_CLIENT_FILE}" ]] ; then
                ${ECHO} "ERROR: isUserInLDAP : LDAP client not configured"
                RESULT=2
                return 2
        fi

        if [[ $(${LDAPLIST} passwd -l "${1}" >/dev/null 2>&1) -eq 0 ]] ; then
                RESULT=1
                ${ECHO} "1"
                return 1
        else
                RESULT=0
                ${ECHO} "0"
                return 0
        fi
}

##############################
# Function: areLDAPPrimaryAndSecondaryConfigured
# Purpose: Check if LDAP Primary and Secondary are configured in LDAP
# Usage: areLDAPPrimaryAndSecondaryConfigured
#
# Return Values:
# 0     Primary and Secondary are not configured in LDAP
# 1     Primary and Secondary are configured in LDAP
# 2     Error in fetching LDAP details
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function areLDAPPrimaryAndSecondaryConfigured() {

        #Check if LDAP client is configured, if not flag error

        if [[ ! -f "${LDAP_CLIENT_FILE}" ]] ; then
                ${ECHO} "ERROR: areLDAPPrimaryAndSecondaryConfigured : LDAP client not configured"
                RESULT=2
                return 2
        fi

        # When primary and secondary are configured, the output of ldapclient list should show a line similar to:
        # NS_LDAP_SERVERS= 10.42.36.224, 10.42.36.226 
        # Hence if this line has 3 entries, it should mean that primary and secondary are configured

        if [[ $(${LDAPCLIENT} list | ${AWK} '/NS_LDAP_SERVERS/ {print NF}') -eq 3 ]] ; then
               RESULT=1
               ${ECHO} "1"
               return 1
        else
               RESULT=0
               ${ECHO} "0"
               return 0
        fi
}

##############################
# Function: getTotalNumberOfUsersDefinedInLDAP
# Purpose: Get the total number of users defined in LDAP
# Usage: getTotalNumberOfUsersDefinedInLDAP
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        Total number of users defined in LDAP
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getTotalNumberOfUsersDefinedInLDAP() {

        #Check if LDAP client is configured, if not flag error

        if [[ ! -f ${LDAP_CLIENT_FILE} ]] ; then
                ${ECHO} "ERROR: getTotalNumberOfUsersDefinedInLDAP : LDAP client not configured"
                return 1
        fi

        RESULT=0
        RESULT=$(${LDAPLIST} passwd | ${SED} '/^$/d' | ${WC} -l )

        if [[ "${RESULT}" -lt 1 ]] ; then
                ${ECHO} "ERROR: getTotalNumberOfUsersDefinedInLDAP : LDAP client not configured"
                return 1
        fi

        ${ECHO} "${RESULT}"

        return 0
}

#function getNumberOfSysadmUsersDefinedInLDAP() {
#        echo "" # number
#        return 1
#}


#function getNumberOfUsersDefinedInLdapWithExpiredPassword() { # <ldapdomain>
#        echo "" # number
#        return 1
#}

##############################
# Function: getLdapDomain
# Purpose: Get the LDAP domain
# Usage: getLdapDomain
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        LDAP domain
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getLdapDomain() {

        #Check if LDAP client is configured, if not flag error

        if [[ ! -f ${LDAP_CLIENT_FILE} ]] ; then
                ${ECHO} "ERROR: getTotalNumberOfUsersDefinedInLDAP : LDAP client not configured"
                return 1
        fi

        RESULT=$(${LDAPCLIENT} list | ${GREP} "^NS_LDAP_BINDDN=" | ${SED} 's/dc=//g' | ${AWK} -F"," '{print $3"."$4}')

        if [[ -z "${RESULT}" ]] ; then
                return 1
        fi

        return 0
}

##############################
# Function: getPrimaryLdapServerIpAddress
# Purpose: Get the primary LDAP server IP Address
# Usage: getPrimaryLdapServerIpAddress
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        IP Address of primary LDAP server
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getPrimaryLdapServerIpAddress() {

        #Check if LDAP client is configured, if not flag error

        if [[ ! -f ${LDAP_CLIENT_FILE} ]] ; then
                ${ECHO} "ERROR: getPrimaryLdapServerIpAddress : LDAP client not configured"
                return 1
        fi

        RESULT=$(${LDAPCLIENT} list | ${GREP} NS_LDAP_SERVERS | ${AWK} '{print $2}' | ${CUT} -d"," -f1)

        if [[ -z "${RESULT}" ]] ; then
                ${ECHO} "ERROR: getPrimaryLdapServerIpAddress : NS_LDAP_SERVERS not defined"
                return 1
        fi

        ${ECHO} "${RESULT}"

        return 0
}

##############################
# Function: getSecondaryLdapServerIpAddress
# Purpose: Get the secondary LDAP server IP Address
# Usage: getSecondaryLdapServerIpAddress
#
# Return Values:
#      0        Success
#      1        Failure
# RESULT        IP Address of secondary LDAP server
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# RESULT
##############################
function getSecondaryLdapServerIpAddress() {

        #Check if LDAP client is configured, if not flag error

        if [[ ! -f ${LDAP_CLIENT_FILE} ]] ; then
                ${ECHO} "ERROR: getSecondaryLdapServerIpAddress : LDAP client not configured"
                return 1
        fi

        RESULT=$(${LDAPCLIENT} list | ${GREP} NS_LDAP_SERVERS | ${AWK} '{print $2}' | ${CUT} -d"," -f2)

        if [[ "${RESULT}" == "" ]] ; then
                ${ECHO} "ERROR: getSecondaryLdapServerIpAddress : NS_LDAP_SERVERS not defined"
                return 1
        fi

        ${ECHO} "${RESULT}"

        return 0

}

############################# End: Functions related to LDAP ####################################




##############################
# Function: isSolarisServiceOnline
# Purpose: Check if the service is online 
# Usage: isSolarisServiceOnline <service>
#
# Return Values:
# 0     <service> is online
# 1     <service> is not in online state
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
##############################
function isSolarisServiceOnline (){  #<servicename>
	isSolarisServiceOnline=$(svcs -H ${1} )
	if [[ ${#} != 1 ]];
		then
			echo "Usage: ${FUNCNAME} <service>"
			return 1
	elif [[ "$isSolarisServiceOnline" =~ "online" ]]
		then
		return 0
	else
		return 1
	fi
}
##############################
# Function: getPackageVersion
#Purpose: Check the package version
# Usage: getPackageVersion <package>
#
# Return Values:
# 0      <package> not given
# 1      <package> version given
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
##############################
function getPackageVersion (){
        getPackageVersion=$(pkginfo -l $1 | grep -v "version:")
        if [[ ${#} != 1 ]];
                then
                        echo "Usage: ${FUNCNAME} <package>"
                        return 1
        elif [[ $? != 0 ]];
                then
                        echo "(Package $1 does not exist)"
                        return 1
        else echo $getPackageVersion
                return 0
        fi
}
##############################
# Function: startLog         
# Purpose: Start Log file            
# Usage: startLog <log directory> <log filename>
#
# Return Values:
# 0      
# 1      
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# LOGFILE
##############################

function startLog () {


        LOG_DIR=$1
        LOG_FILE=$2                                                  
        SCK_TMP="/tmp/sck.$$"
        [[ ! -d ${LOG_DIR} ]] && { 
		mkdir -p ${LOG_DIR}
		chmod -fR 777 ${LOG_DIR}
	}
        [[ ! -d ${SCK_TMP} ]]  && {
 		mkdir -p ${SCK_TMP}
		chmod -fR 777 ${SCK_TMP}
	}

        LOGFILE=${LOG_DIR}/${LOG_FILE}

        touch ${LOGFILE}

        [ -e ${SCK_TMP}/sug.fifo ] && rm -f ${SCK_TMP}/sug.fifo
        mkfifo ${SCK_TMP}/sug.fifo
        # save stdout/stderr to 3 & 4
        exec 3>&1 4>&2

        # start tee in the background
        tee -a ${LOGFILE} < ${SCK_TMP}/sug.fifo >&3 &
        tee_pid=$!

        # redirect stdout/stderr to the named pipe
        exec >${SCK_TMP}/sug.fifo 2>&1

        echo "Starting log file :" $LOGFILE

}

####################################
# Purpose: Stop Log                  
# Usage: stopLog 
#
# Return Values:
# 0      
#
# Input globals accessed by this function
# none
#
# Output globals set by this function
# none
##############################

function stopLog () {

        # Stop log

        # restore fds, close 3 & 4
        exec 1>&3 3>&- 2>&4 4>&-

        # sleep for a bit, to allow tee to die on its own
        sleep 6
                if [[ ${tee_pid} -ne 0 ]]; then
                ps -p $tee_pid 1>/dev/null && kill $tee_pid
        fi
        return 0

}

####################################
# Purpose: Confirm it is possible to connect to a node
# Usage: confirmConnection <node>
#
# Return Values:
# 0 success
# 1 failure
#
# Input globals accessed by this function
# server ip address or server full name e.g. atrcus1234.athtem.eei.ericsson.se
#
# Output globals set by this function
# none
##############################

function confirmConnection () {

        ${PING} -c 3 $1  > /dev/null
        if [[ $? -ne 0 ]]; then
                echo "WARNING: Could not contact $1 "
                return 1
        else
                echo "INFO: Successfully contacted $1"
                return 0
        fi
}
####################################
# Purpose: Get ADMIN1 and ADMIN2 server names from cluster.ini
# Usage: getServers 
#
# Return Values:
# 0 success
# 1 failure
#
# Input globals accessed by this function
# -                                            
#
# Output globals set by this function
# ADMIN1
# ADMIN2
##############################

function getServers () {


CLUSTER_INI=/ericsson/config/cluster.ini

        if [[ -f ${CLUSTER_INI} ]]; then
                NUM_NODES=$(cat /ericsson/config/cluster.ini |grep systemname | wc -l)
                if [[ $NUM_NODES -eq 2 ]]; then
                        ADMIN1=$(cat /ericsson/config/cluster.ini |grep systemname |head -1 |awk -F'=' '{print $2}')
                        ADMIN2=$(cat /ericsson/config/cluster.ini |grep systemname |tail -1 |awk -F'=' '{print $2}')
                        return 0
                else
                        echo "ERROR: Not a 2 node cluster"
                        return 1
                fi
        else
                echo "ERROR: No add_cluster_node file found"
                return 1
        fi
}
####################################
# Purpose: Check both servers are RUNNING in cluster
# Usage: checkServers
#
# Return Values:
# 0 success
# 1 failure
#
# Input globals accessed by this function
# - 
#
# Output globals set by this function
# - 
##############################

function checkServers () {
        getServers

        ADMIN1_STATE=`${HASYS} -state ${ADMIN1}`
        ADMIN2_STATE=`${HASYS} -state ${ADMIN2}`

        if [ ${ADMIN1_STATE} != "RUNNING" ]; then
                echo "ERROR: Cluster not in running state on ${ADMIN1}"
                return 1
        else
                echo "INFO: Cluster running OK on ${ADMIN1}"
        fi

        if [ ${ADMIN2_STATE} != "RUNNING" ]; then
                echo "ERROR: Cluster not in running state on ${ADMIN2}"
                return 1
        else
                echo "INFO: Cluster running OK on ${ADMIN2}"
                return 0
        fi
}
####################################
# Purpose: Switck HA Group from the server it is ONLINE to the other server
# Usage: SwitchGroup <GROUP>        
#
# Return Values:
# 0 success
# 1 failure
#
# Input globals accessed by this function
# Group (Oss or Sybase1)
#
# Output globals set by this function
# TO_SERVER    (The server group is swiched to)
##############################
function switchGroup () {
        GROUP=$1
        getServers 

        MAX_TIMER=600
        [[ ${GROUP} == "Oss" ]] && MAX_TIMER=1800

        ADMIN1_GRP_STATE=`${HAGRP} -state ${GROUP} -sys ${ADMIN1}`
        ADMIN2_GRP_STATE=`${HAGRP} -state ${GROUP} -sys ${ADMIN2}`

        if [[ ${ADMIN1_GRP_STATE} == "ONLINE" && ${ADMIN2_GRP_STATE} == "OFFLINE" ]]; then
                TO_SERVER=${ADMIN2}
        elif [[ ${ADMIN2_GRP_STATE} == "ONLINE" && ${ADMIN1_GRP_STATE} == "OFFLINE" ]]; then
                TO_SERVER=${ADMIN1}
        else
                echo "ERROR: ${GROUP} group not ONLINE on either server or ${GROUP} is a parallel group"
                echo "ERROR: Not possible to switch ${GROUP} group"
                return 1
        fi

        echo -e "\nSwitching ${GROUP} group to ${TO_SERVER}"
        ${HAGRP} -switch ${GROUP} -to ${TO_SERVER}
        if [[ $? -ne 0 ]]; then
                echo -e "\nERROR: Switching ${GROUP} Group order failed"
                return 1
        fi
        MYTIMER=0
        while : ; do
                count=`${HAGRP} -state ${GROUP} -sys ${TO_SERVER} | grep "ONLINE" | wc -l`
                if [ $count -eq 1 ];then
                        echo -e "\nINFO: ${GROUP} started OK after switch"
                        return 0
                else
                        if [ $MYTIMER -gt $MAX_TIMER ];then
                                echo -e  "\nError: ${GROUP} faild to come ONLINE after $MYTIMER seconds"
                                return 1
                        fi
                        sleep 15; ((MYTIMER=MYTIMER+15))
                        echo  -e '.\c'
                fi
        done
}


# Purpose: To check whether II or Upgrade is successful
# Return Values:
#  1     II is successful
# -1     II is not successful
#  2     Upgrade is successful
# -2     Upgrade is not successful 
#  3     one of the keyfiles doesn't exist or empty
#
# Input globals accessed by this function
# none
#
##############################

function IsIIorUpgradeSuccessful () {

if [ ! \( -s "/ericsson/config/.iistage" -a -s "/ericsson/config/next_stage" -a -s "/var/opt/ericsson/sck/data/cp.history" \) ]
then
        echo "Error: one of the keyfiles doesn't exist or empty and the system is not Initial Installed or upgraded"
        return 3
else

IIST=`cat /ericsson/config/.iistage`
IINXT=`tail -1 /ericsson/config/next_stage |grep cleanup |awk '{print $1}'`
CP_HISTORY=/var/opt/ericsson/sck/data/cp.history
II=`cat $CP_HISTORY | grep "Initial Installation" |awk '{print $4}'`
COUNT=`cat $CP_HISTORY | wc -l`
OLD=`tail -1 $CP_HISTORY |grep Upgrade |awk '{print $5}'`
NEW=`tail -1 $CP_HISTORY|grep Upgrade |awk '{print $8}'`

if [ "$COUNT" -eq 1 -a "$IIST" == done  -a  "$IINXT" == cleanup ]; then
        echo "II to $II is Successful "
        return 1
elif [ "$COUNT" -eq 1 -a "$IIST" != done  -o "$IINXT" != cleanup ]
then
        echo "II to $II is not successful"
        return -1
fi

if [ $COUNT -gt 1 ]; then

grep -i "from $OLD to $NEW stage: done" /var/opt/ericsson/sck/log/SUG/$NEW/system_ug_to_*_4_* 1>/dev/null 2>/dev/null
if [ $? -eq 0 ]; then
        echo "upgrade is successful from $OLD to $NEW"
        return 2
else
        echo "upgrade is not successful from $OLD to $NEW"
        return -2
fi
fi
fi

}


####################################
# Purpose: create output like Solaris "banner" command
# Usage: bashBanner <text>
#
# Return Values:
# 0 success
# 1 failure
#
# Input globals accessed by this function
# Group (Oss or Sybase1)
#
# Output globals set by this function
# TO_SERVER    (The server group is swiched to)
##############################
bashBanner ()
{

A=$((1<<0))
B=$((1<<1))
C=$((1<<2))
D=$((1<<3))
E=$((1<<4))
F=$((1<<5))
G=$((1<<6))
H=$((1<<7))

function outLine
{
  typeset r=0 scan
  for scan
  do
    typeset l=${#scan}
    typeset line=0
    for ((p=0; p<l; p++))
    do
      line="$((line+${scan:$p:1}))"
    done
    for ((column=0; column<8; column++))
      do
#RB      [[ $((line & (1<<column))) == 0 ]] && n=" " || n="#"
        raw[r]="${raw[r]}$n"
      done
      r=$((r+1))
    done
}

function outChar
{
    case "$1" in
    (" ") outLine "" "" "" "" "" "" "" "" ;;
    ("0") outLine "BCDEF" "AFG" "AEG" "ADG" "ACG" "ABG" "BCDEF" "" ;;
    ("1") outLine "F" "EF" "F" "F" "F" "F" "F" "" ;;
    ("2") outLine "BCDEF" "AG" "G" "CDEF" "B" "A" "ABCDEFG" "" ;;
    ("3") outLine "BCDEF" "AG" "G" "CDEF" "G" "AG" "BCDEF" "" ;;
    ("4") outLine "AF" "AF" "AF" "BCDEFG" "F" "F" "F" "" ;;
    ("5") outLine "ABCDEFG" "A" "A" "ABCDEF" "G" "AG" "BCDEF" "" ;;
    ("6") outLine "BCDEF" "A" "A" "BCDEF" "AG" "AG" "BCDEF" "" ;;
    ("7") outLine "BCDEFG" "G" "F" "E" "D" "C" "B" "" ;;
    ("8") outLine "BCDEF" "AG" "AG" "BCDEF" "AG" "AG" "BCDEF" "" ;;
    ("9") outLine "BCDEF" "AG" "AG" "BCDEF" "G" "G" "BCDEF" "" ;;
    ("a") outLine "" "" "BCDE" "F" "BCDEF" "AF" "BCDEG" "" ;;
    ("b") outLine "B" "B" "BCDEF" "BG" "BG" "BG" "ACDEF" "" ;;
    ("c") outLine "" "" "CDE" "BF" "A" "BF" "CDE" "" ;;
    ("d") outLine "F" "F" "BCDEF" "AF" "AF" "AF" "BCDEG" "" ;;
    ("e") outLine "" "" "BCDE" "AF" "ABCDEF" "A" "BCDE" "" ;;
    ("f") outLine "CDE" "B" "B" "ABCD" "B" "B" "B" "" ;;
    ("g") outLine "" "" "BCDEG" "AF" "AF" "BCDE" "F" "BCDE" ;;
    ("h") outLine "B" "B" "BCDE" "BF" "BF" "BF" "ABF" "" ;;
    ("i") outLine "C" "" "BC" "C" "C" "C" "ABCDE" "" ;;
    ("j") outLine "D" "" "CD" "D" "D" "D" "AD" "BC" ;;
    ("k") outLine "B" "BE" "BD" "BC" "BD" "BE" "ABEF" "" ;;
    ("l") outLine "AB" "B" "B" "B" "B" "B" "ABC" "" ;;
    ("m") outLine "" "" "ACEF" "ABDG" "ADG" "ADG" "ADG" "" ;;
    ("n") outLine "" "" "BDE" "BCF" "BF" "BF" "BF" "" ;;
    ("o") outLine "" "" "BCDE" "AF" "AF" "AF" "BCDE" "" ;;
    ("p") outLine "" "" "ABCDE" "BF" "BF" "BCDE" "B" "AB" ;;
    ("q") outLine "" "" "BCDEG" "AF" "AF" "BCDE" "F" "FG" ;;
    ("r") outLine "" "" "ABDE" "BCF" "B" "B" "AB" "" ;;
    ("s") outLine "" "" "BCDE" "A" "BCDE" "F" "ABCDE" "" ;;
    ("t") outLine "C" "C" "ABCDE" "C" "C" "C" "DE" "" ;;
    ("u") outLine "" "" "AF" "AF" "AF" "AF" "BCDEG" "" ;;
    ("v") outLine "" "" "AG" "BF" "BF" "CE" "D" "" ;;
    ("w") outLine "" "" "AG" "AG" "ADG" "ADG" "BCEF" "" ;;
    ("x") outLine "" "" "AF" "BE" "CD" "BE" "AF" "" ;;
    ("y") outLine "" "" "BF" "BF" "BF" "CDE" "E" "BCD" ;;
    ("z") outLine "" "" "ABCDEF" "E" "D" "C" "BCDEFG" "" ;;
    ("A") outLine "D" "CE" "BF" "AG" "ABCDEFG" "AG" "AG" "" ;;
    ("B") outLine "ABCDE" "AF" "AF" "ABCDE" "AF" "AF" "ABCDE" "" ;;
    ("C") outLine "CDE" "BF" "A" "A" "A" "BF" "CDE" "" ;;
    ("D") outLine "ABCD" "AE" "AF" "AF" "AF" "AE" "ABCD" "" ;;
    ("E") outLine "ABCDEF" "A" "A" "ABCDE" "A" "A" "ABCDEF" "" ;;
    ("F") outLine "ABCDEF" "A" "A" "ABCDE" "A" "A" "A" "" ;;
    ("G") outLine "CDE" "BF" "A" "A" "AEFG" "BFG" "CDEG" "" ;;
    ("H") outLine "AG" "AG" "AG" "ABCDEFG" "AG" "AG" "AG" "" ;;
    ("I") outLine "ABCDE" "C" "C" "C" "C" "C" "ABCDE" "" ;;
    ("J") outLine "BCDEF" "D" "D" "D" "D" "BD" "C" "" ;;
    ("K") outLine "AF" "AE" "AD" "ABC" "AD" "AE" "AF" "" ;;
    ("L") outLine "A" "A" "A" "A" "A" "A" "ABCDEF" "" ;;
    ("M") outLine "ABFG" "ACEG" "ADG" "AG" "AG" "AG" "AG" "" ;;
    ("N") outLine "AG" "ABG" "ACG" "ADG" "AEG" "AFG" "AG" "" ;;
    ("O") outLine "CDE" "BF" "AG" "AG" "AG" "BF" "CDE" "" ;;
    ("P") outLine "ABCDE" "AF" "AF" "ABCDE" "A" "A" "A" "" ;;
    ("Q") outLine "CDE" "BF" "AG" "AG" "ACG" "BDF" "CDE" "FG" ;;
    ("R") outLine "ABCD" "AE" "AE" "ABCD" "AE" "AF" "AF" "" ;;
    ("S") outLine "CDE" "BF" "C" "D" "E" "BF" "CDE" "" ;;
    ("T") outLine "ABCDEFG" "D" "D" "D" "D" "D" "D" "" ;;
    ("U") outLine "AG" "AG" "AG" "AG" "AG" "BF" "CDE" "" ;;
    ("V") outLine "AG" "AG" "BF" "BF" "CE" "CE" "D" "" ;;
    ("W") outLine "AG" "AG" "AG" "AG" "ADG" "ACEG" "BF" "" ;;
    ("X") outLine "AG" "AG" "BF" "CDE" "BF" "AG" "AG" "" ;;
    ("Y") outLine "AG" "AG" "BF" "CE" "D" "D" "D" "" ;;
    ("Z") outLine "ABCDEFG" "F" "E" "D" "C" "B" "ABCDEFG" "" ;;
    (".") outLine "" "" "" "" "" "" "D" "" ;;
    (",") outLine "" "" "" "" "" "E" "E" "D" ;;
    (":") outLine "" "" "" "" "D" "" "D" "" ;;
    ("!") outLine "D" "D" "D" "D" "D" "" "D" "" ;;
    ("/") outLine "G" "F" "E" "D" "C" "B" "A" "" ;;
    ("\\") outLine "A" "B" "C" "D" "E" "F" "G" "" ;;
    ("|") outLine "D" "D" "D" "D" "D" "D" "D" "D" ;;
    ("+") outLine "" "D" "D" "BCDEF" "D" "D" "" "" ;;
    ("-") outLine "" "" "" "BCDEF" "" "" "" "" ;;
    ("*") outLine "" "BDF" "CDE" "D" "CDE" "BDF" "" "" ;;
    ("=") outLine "" "" "BCDEF" "" "BCDEF" "" "" "" ;;
    ("~") outLine "BC" "ADG" "EF" "" "" "" "" "" ;;
    ("_") outLine "" "" "" "" "" "" "" "ABCDEFGH" ;;
    (">") outLine "C" "D" "E" "F" "E" "D" "C" "" ;;
    ("<") outLine "F" "E" "D" "C" "D" "E" "F" "" ;;

    (*) outLine "ABCDEFGH" "AH" "AH" "AH" "AH" "AH" "AH" "ABCDEFGH" ;;
    esac
}

function outArg
{
  typeset l=${#1} c r
  for ((c=0; c<l; c++))
  do
    outChar "${1:$c:1}"
  done
  echo
  for ((r=0; r<8; r++))
  do
    printf "%-*.*s\n" "${COLUMNS:-80}" "${COLUMNS:-80}" "${raw[r]}"
    raw[r]=""
  done
}

for i
do
  outArg "$i"
  echo
done
}

testRemote_func ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
echo "variables in lib function:
===============
expect: $EXPECT
Arg1: $1
Arg2: $2
From TC: ${G_WRAPPER_ARGS}
Admin1: ${CI_ADMIN1_HOSTNAME}
exp_dir: ${G_EXPECT_DIR}
"

$EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}	
			ret=$?
		return "${ret}"
}

#
# function to test if we can ssh to the specified server
#

canSSHToAdminNode () {
	server_hostname=$1
	get_server_details $server_hostname  || {
		 error "Failed to get \"$server_hostname\" server details" "CI config issue"
		return 1
	}
	$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${_SERVER_DETAILS[1]} ls" ${_SERVER_DETAILS[8]} > /dev/null || return 1 

}

setExpect ()
{
if [ $(uname) = "Linux" ]; then
        EXPECT=/usr/bin/expect
else
        EXPECT=/app/expect/5.40.1/bin/expect
fi

#message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
#if [ $( hostname ) = "eeiatuc432" ]; then
        ## eeiatuc432 uses libexpect5.38 and libtcl8.4
        #LD_LIBRARY_PATH=/app/expect/5.38/lib:/app/tcl/8.4.5/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH
        #EXPECT="/usr/local/bin/expect"
#elif [ $( hostname ) = "eieatx009" ]; then
        ## eieatx009 uses libexpect5.38 and libtcl8.4
        #LD_LIBRARY_PATH=/app/expect/5.38/lib:/app/tcl/8.4.5/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH
        #EXPECT="/usr/local/bin/expect"
#elif [ $( hostname ) = "eeiatuc681" ]; then
        #LD_LIBRARY_PATH=/app/expect/5.38/lib:/app/tcl/8.4.5/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH
		#EXPECT="/app/expect/5.38/bin/expect"
#elif [ $( uname -s ) = "Linux" ]; then
		#EXPECT="/usr/bin/expect"
#elif [ $( uname -s ) = "SunOS" ]; then
		#EXPECT="/usr/local/bin/expect"
#else
        ## eieatx008 and eeiatuc681 use libexpect5.22 and libtcl7.6
        #LD_LIBRARY_PATH=/usr/local/expect/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH
        #EXPECT="/app/expect/5.43/bin/expect"
#fi
}

message()
{
echo ""
echo "=======return CI: $1 `date '+%Y%m%d-%H:%M:%S'` >==================="
echo ""
}

err_msg()
{
# pass in arguments like so:
# $1 "text in quotes"
# $2 $LINENO
# $3 $FUNCNAME
# $4 <return code>
local _msg=$1
local _ln=$2
local _func=$3
local _rc=$4
local _script=$(basename $BASH_SOURCE)
${BANNER} "->error"
echo -e "\n\tERROR: ${_msg}.\tFUNCTION: ${_func}\tLINE:${_ln} IN: ${_script}\tCODE:$4\n"
}

error () 
{
        echo "Error: $1 $2" 
	#echo "Install Failed:[$1 $2] , see logs for details" | mailx -s "$CI_RELEASE $CI_SHIPMENT for $CI_PLATFORM $CI_TYPE FAILED" priju.punnoose@ericsson.com,roopa.k10@wipro.com,PDLSCKSUPP@ex1.eemea.ericsson.se,PDLUSCKSUP@ex1.eemea.ericsson.se

	if [[ "${CI_TYPE}" == "II" ]]; then
		content_for_log=contentII-$CI_PLATFORM-$WDATE.html
		log_for_log=lnstall-$CI_PLATFORM-$WDATE.html
		type_for_log="Initial Install"
		resultsfile=/net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/results1-${CI_PLATFORM}-$WDATE
	else
		content_for_log=contentUG-$CI_PLATFORM-$WDATE.html
		log_for_log=installug-$CI_PLATFORM-$WDATE.html
		type_for_log="Upgrade from $CI_BASE"
		resultsfile=/net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/ugresults1-${CI_PLATFORM}-$WDATE
	fi
	if [[ "${CI_ADMIN2_HOSTNAME}" == "NO" ]]; then
		servers_for_log=${CI_ADMIN1_HOSTNAME}
	else
		servers_for_log=${CI_ADMIN1_HOSTNAME},${CI_ADMIN2_HOSTNAME}
	fi

	installfinish_for_log=`date +'%a %b %e %Y %T'`
	echo "Install Finished: $installfinish_for_log"
	echo "Arch: $CI_PLATFORM"
	echo "Install type: $type_for_log"
	echo "DM build date: $II_build_complete"
	echo "Server: $servers_for_log"
	echo "Install status: Failed at $2"
	echo "Install log: $log_for_log"
	echo "content: $content_for_log"
 	if [ -f $LOGDIR/${INSTALL} ]; then
               echo "<html> <body>"  > $LOGDIRHTML/$log_for_log
               cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/$log_for_log
               echo "</body></html>"  >> $LOGDIRHTML/$log_for_log
        fi
	
	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
 		echo  "@$installfinish_for_log@$CI_PLATFORM@$type_for_log@$II_build_complete@$servers_for_log@Failed at $2@Failed@<a href=\"./logs/$log_for_log\">Install log</a\>@Failed@<a href=\"./logs/$content_for_log\">Content</a>" >> $resultsfile
	fi
        return 1
}

add_uploaded ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	ERICsck=/ossrc_base_sw/inst_config/common/ericsson/ERICsck.pkg
	ERICusck=/ossrc_base_sw/inst_config/common/upgrade/ERICusck.pkg
	ERICcore=/ossrc_base_sw/inst_config/common/install/ERICcore.pkg
	ECONFsystem=/ossrc_base_sw/inst_config/common/config/ECONFsystem.pkg
	ECONFbase=/ossrc_base_sw/inst_config/common/config/ECONFbase.pkg
	ERICsol=/ossrc_base_sw/inst_config/common/install/ERICsol.pkg
	ERICaxe=/ossrc_base_sw/eric_app/common/ERICaxe.pkg
        dest1=$1/uploaded
        dest2=$1
        if [ -d "$dest1" ] && [ -n "`ls -1 $dest1`" ]; then
                i386new_manifest=/tmp/i386.$$
                sparcnew_manifest=/tmp/sparc.$$
                i386tmp_manifest=/tmp/i386t.$$
                sparctmp_manifest=/tmp/sparct.$$
                /bin/cat $dest2/ossrc_base_sw/build_manifest_i386 >> $i386new_manifest
                /bin/cat $dest2/ossrc_base_sw/build_manifest_sparc >> $sparcnew_manifest

                for files in $dest1/* ; do
                        basefile=$(/bin/basename $files)
                        basefile1=$(echo $basefile | $SED "s/\.pkg//" )
                        path=$dest2/$(eval echo \$$basefile1)
                        currentver=$(pkginfo -ld $path |grep VERSION: | $SED 's/VERSION://;s/^[ \t]*//;s/[ \t]*$//')
                        newver=$(pkginfo -ld $files |grep VERSION: | $SED 's/VERSION://;s/^[ \t]*//;s/[ \t]*$//')

 			if [[ "$newver" <  "$currentver" || "$newver" =  "$currentver"  ]]; then
                                printf "%-30s" "discard"
                                continue
                        fi


                        declare -a man_array=($(cat $dest2/ossrc_base_sw/build_manifest_i386|grep "$basefile1 "))
                        target_package=${man_array[0]}
                        apr=${man_array[1]}
                        misc1=${man_array[3]}
                        misc2=${man_array[4]}
                        misc3=${man_array[5]}
                        $SED "/$target_package /d" $i386new_manifest > $i386tmp_manifest
                        echo "$target_package $apr $newver $misc1 $misc2 $misc3" 1>> $i386tmp_manifest
                        cp $i386tmp_manifest $i386new_manifest

                        declare -a man_arrays=($(cat $dest2/ossrc_base_sw/build_manifest_sparc|grep "$basefile1 "))
                        target_packages=${man_arrays[0]}
                        aprs=${man_arrays[1]}
                        misc1s=${man_arrays[3]}
                        misc2s=${man_arrays[4]}
                        misc3s=${man_arrays[5]}
                        $SED "/$target_packages /d" $sparcnew_manifest > $sparctmp_manifest
                        echo "$target_packages $aprs $newver $misc1s $misc2s $misc3s" 1>> $sparctmp_manifest

                        cp $sparctmp_manifest $sparcnew_manifest

                        cp $files $path
                        cp $files $dest2/current_jump/ 
                 done

        cp $sparcnew_manifest $dest2/ossrc_base_sw/build_manifest_sparc
        cp $i386new_manifest $dest2/ossrc_base_sw/build_manifest_i386
        rm $i386new_manifest
        rm $sparcnew_manifest
        rm $i386tmp_manifest
        rm $sparctmp_manifest
fi
}

getVeritasLicense ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"	
cmddir=`dirname $0`
[[ -n ${G_EXPECT_DIR} ]] && cmddir=${G_EXPECT_DIR}
[[ $( uname -s ) != "Linux" ]] && PATH=$PATH:/usr/xpg4/bin:/bin


unset VER_LIC
[[ $(uname) == "SunOS" ]] && ID=/usr/xpg4/bin/id
[[ $(uname) == "Linux" ]] && ID=/usr/bin/id
user=$($ID -un)

#setExpect


bete_CI_MWS_HOSTNAME=attemjump220.athtem.eei.ericsson.se
bete_CI_MWS_IP=159.107.220.94
veritas_license_path=/net/${bete_CI_MWS_IP}/export/veritas/LICENSES.txt
#veritas_license_path=/var/tmp/LICENSES.txt
# check automount works
ls $veritas_license_path > /dev/null || {
	echo "Automount of $bete_CI_MWS_IP:/export/veritas appears not to be working. Will try manual mount"
	mkdir -p /net/${bete_CI_MWS_IP}/export/veritas &&
	mount ${bete_CI_MWS_IP}:/export/veritas /net/${bete_CI_MWS_IP}/export/veritas || {
		echo "Warning: manual mount of $bete_CI_MWS_IP:/export/veritas has failed"
	}
}
case $CI_RELEASE in 
	R6_0)
		VER_LIC=$(grep OSSRC_R6@ $veritas_license_path | grep License1= | awk '{print $2}' | $SED 's/OSSRC_R6@//')
		;;
        R6_1)
                VER_LIC=$(grep OSSRC_R6@ $veritas_license_path | grep License1= | awk '{print $2}' | $SED 's/OSSRC_R6@//')
                ;;
        R6_2)
                VER_LIC=$(grep OSSRC_R6@ $veritas_license_path | grep License1= | awk '{print $2}' | $SED 's/OSSRC_R6@//')
                ;;

        R6_3)
                VER_LIC=$(grep OSSRC_R6@ $veritas_license_path | grep License1= | awk '{print $2}' | $SED 's/OSSRC_R6@//')
		;;

	R7_0)
                VER_LIC=$(grep OSSRC_R6@ $veritas_license_path | grep License1= | awk '{print $2}' | $SED 's/OSSRC_R6@//')
                ;;
	O1*)
		if [ ${CI_PLATFORM} = "i386" ]; then
                	VER_LIC=$({ cat $veritas_license_path ; echo ; } | grep License1_i386 | $SED 's/\(.*[@]\)//')
		else
                	VER_LIC=$(grep OSSRC_R6@ $veritas_license_path | grep License1= | awk '{print $2}' | $SED 's/OSSRC_R6@//')
		fi
                ;;
	*)
		VER_LIC=$(grep WILDCARD $veritas_license_path | $SED 's/WILDCARD@//')
		;;
esac
if [ -z "$VER_LIC" ]; then
	echo "** Error - unable to determine veritas license"
	return 1
else
	echo "** using veritas license $VER_LIC **"
fi

#added umount to prevent stale mounts when isolating a node. ebatric
#umount -f /net/${bete_CI_MWS_IP}/export/veritas || {
	#echo "WARNING: un-mount of veritas license directory failed."
	#}
}

handleArgs_func ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
missing_params=""

[ "$CI_IPV6" != "" ] || missing_params="$missing_params CI_IPV6"

if [ "$CI_IPV6" = "YES" ]; then
	[ "$CI_IPV6_ROUTER" != "" ] || missing_params="$missing_params CI_IPV6_ROUTER"
	count=0
	while [ $count -lt ${#CI_SERVER_HOSTNAME[@]} ]; do
		if [ -z "${CI_SERVER_IPV6[$count]}" ]; then
			missing_params="$missing_params CI_SERVER_IPV6 for server ${CI_SERVER_HOSTNAME[$count]}"
		fi
		let count+=1
	done
fi

if [[ "$CI_TYPE" == "II" || "$CI_TYPE" == "UG" ]]; then
	if [ -z  "$CI_FQ_SHIPMENT" ]; then 
		missing_params="$missing_params CI_FQ_SHIPMENT"
	else
		CI_RELEASE=$( dirname $CI_FQ_SHIPMENT )
		CI_SHIPMENT_SRC=$( basename $CI_FQ_SHIPMENT )
		CI_SHIPMENT=$( basename $CI_FQ_SHIPMENT )	
	fi
[ "$CI_TEAM" != "" ] || missing_params="$missing_params CI_TEAM"
[ "$CI_SHIPMENT" != "" ] || missing_params="$missing_params CI_SHIPMENT"
[ "$CI_RELEASE" != "" ] || missing_params="$missing_params CI_RELEASE"
[ "$CI_SHIPMENT_SRC" != "" ] || missing_params="$missing_params CI_SHIPMENT_SRC"
[ "$CI_TYPE" != "" ] || missing_params="$missing_params CI_TYPE"
	[ "$CI_PLATFORM" != "" ] || missing_params="$missing_params CI_PLATFORM"
	[ "$CI_PLATFORM" != "ignore" ] || missing_params="$missing_params CI_PLATFORM"
fi
# function below sets CI_ADMIN1_HOSTNAME
getAdminClusterDetails
#[[ "$CI_ENVIRONMENT" != vapp && -z "$CI_ADMIN1_HOSTNAME" ]] && missing_params="$missing_params CI_ADMIN1_HOSTNAME"
if [[  -z "$CI_MWS_HOSTNAME" ]]; then
	missing_params="$missing_params CI_MWS_HOSTNAME"
fi
if [[ -z "$CI_MWS_ROOTPW" ]]; then
	missing_params="$missing_params CI_MWS_ROOTPW"
fi
if [[ -z "$CI_MWS_IP" ]]; then
	missing_params="$missing_params CI_MWS_IP"
fi
if [[ -z "$CI_MWS_BIP" ]]; then
	missing_params="$missing_params CI_MWS_BIP"
fi
# WDATE should be defined in atcominf.bsh
if [ -z "$WDATE" ]; then
	missing_params="$missing_params WDATE"
fi

if [ -n "$missing_params" ]; then
	echo "Error - followng compulsory parameters are not set: $missing_params"
	echo "Error - check your env file"
	return 1
fi

if [ -n "$CI_OMFQ_SHIPMENT" ]; then
	echo "*Info - $CI_OMFQ_SHIPMENT shipment will be selected for OM media"
	CI_OM_RELEASE=$( dirname $CI_OMFQ_SHIPMENT )
	CI_OM_SHIPMENT_SRC=$( basename $CI_OMFQ_SHIPMENT )
	CI_OM_SHIPMENT=$( basename $CI_OMFQ_SHIPMENT )
else
	CI_OM_RELEASE=$( dirname $CI_FQ_SHIPMENT )
	CI_OM_SHIPMENT_SRC=$( basename $CI_FQ_SHIPMENT )
	CI_OM_SHIPMENT=$( basename $CI_FQ_SHIPMENT )
fi

[ -z "$CI_ENVIRON_TEST" ] && {
	CI_ENVIRON_TEST=FALSE
}

[ -z "$CI_COMPACT_OSS" ] && {
	CI_COMPACT_OSS=FALSE
}

############
# why was the script run?
#

if [[ -f /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT/II_build_complete ]];then
	II_build_complete=$(cat /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/II_build_complete)
else
	II_build_complete="NA"
fi
VMA_SERVER=10.45.226.57
VMA_SERVER_ROOTPW=jaguar
CI_CORE_SETTING=2
CI_GRAN_SETTING=100
CI_WRAN_SETTING=100

if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
	LOGDIR=/proj/ossrcci/logs/${CI_TYPE}/$CI_RELEASE/$CI_SHIPMENT/
	LOGDIRHTML=/view/www_integrationci/vobs/ossrc/del-mgt/html/CI/$CI_TEAM/$CI_RELEASE/$CI_SHIPMENT_SRC/logs/
	TESTLOGDIR=/proj/ossrcci/logs/extra/$CI_RELEASE/$CI_SHIPMENT/
else
	LOGDIR=/var/tmp/ci_log
	LOGDIRHTML=/var/tmp/ci_log_html
	TESTLOGDIR=/var/tmp/ci_testlog
fi
[ ! -d $LOGDIR ] && {
	mkdir -p $LOGDIR
}
[ ! -d $LOGDIRHTML  ] && {
	mkdir -p $LOGDIRHTML
}
if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
	chmod -fR 777 /proj/ossrcci/logs/${CI_TYPE}
	chmod -fR 777 /view/www_integrationci/vobs/ossrc/del-mgt/html/CI/$CI_TEAM
fi

INSTALL="INSTALL-${CI_ADMIN1_HOSTNAME}-${CI_TYPE}-${CI_RELEASE}-${CI_SHIPMENT}-${CI_PLATFORM}-${WDATE}.txt"
WRAPPER="WRAPPER-${CI_TYPE}-${CI_RELEASE}-${CI_SHIPMENT}-${CI_PLATFORM}-${WDATE}.txt"
if [ -f /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/II_build_complete ]; then
	II_build_complete=$(cat /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/II_build_complete)
fi

DMR_set_globals


}

# function to determine cluster details from env file

getAdminClusterDetails () {
	unset CI_ADMIN1_HOSTNAME
	CI_ADMIN2_HOSTNAME=NO
	local l_count=0
	while [ $l_count -lt ${#CI_SERVER_HOSTNAME[@]} ]; do
		if [ -n "${CI_SERVER_HOSTNAME[$l_count]}" ]; then
			if [ "${CI_SERVER_CLUSTER_PURPOSE[$l_count]}" = admin1 ]; then
				CI_ADMIN1_HOSTNAME=${CI_SERVER_HOSTNAME[$l_count]}
			fi
			if [ "${CI_SERVER_CLUSTER_PURPOSE[$l_count]}" = admin2 ]; then
				CI_ADMIN2_HOSTNAME=${CI_SERVER_HOSTNAME[$l_count]}
			fi
		fi
		let l_count+=1
	done


}

create_content() {
echo "Generating content web page .. "
tmpfile1=/tmp/content1.$$
tmpfile2=/tmp/content2.$$
tmpfile3=/tmp/content3.$$



date=`date '+%Y%m%d'`
logdate=`date '+%Y%m%d-%H:%M:%S'`
[ -d $LOGDIR ] || {
	 mkdir -p $LOGDIR
	chmod -fR 777 $LOGDIR
}
[ -d $LOGDIRHTML ] || {
	 mkdir -p $LOGDIRHTML
	chmod -fR 777 $LOGDIRHTML
}

if [[ ${CI_PLATFORM} == "ignore" ]]; then
	INSTALL="INSTALL-${CI_ADMIN1_HOSTNAME}-${CI_TYPE}-${CI_RELEASE}-${CI_SHIPMENT}-${WDATE}.txt"
else
	INSTALL="INSTALL-${CI_ADMIN1_HOSTNAME}-${CI_TYPE}-${CI_RELEASE}-${CI_SHIPMENT}-${CI_PLATFORM}-${WDATE}.txt"
	WRAPPER="WRAPPER-${CI_TYPE}-${CI_RELEASE}-${CI_SHIPMENT}-${CI_PLATFORM}-${WDATE}.txt"
fi
output=/view/www_integrationci/vobs/ossrc/del-mgt/html/CI/$CI_TEAM/$CI_RELEASE/$CI_SHIPMENT_SRC/logs/content${CI_TYPE}-${CI_PLATFORM}-${WDATE}.html
destination=/net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC


if [[ "${CI_TYPE}" == "UG" ]]; then
current_manifest=/net/${CI_MWS_HOSTNAME}/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_$CI_RELEASE/${CI_SHIPMENT}_UG/ossrc_base_sw/build_manifest_${CI_PLATFORM}
else
current_manifest=/net/${CI_MWS_HOSTNAME}/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_$CI_RELEASE/${CI_SHIPMENT}/ossrc_base_sw/build_manifest_${CI_PLATFORM}
fi
previous_manifest=${destination}/build_manifest_${CI_PLATFORM}_${CI_TYPE}_CI_PREVIOUS
unchanged_manifest=${destination}/build_manifest_${CI_PLATFORM}_${CI_TYPE}_DM_UNCHANGED


[[ -f  ${previous_manifest} ]] || prev="-"
[[ -f  ${unchanged_manifest} ]] || uncha="-"

cat $current_manifest|awk '{print $1}' >$tmpfile1
	if [[ "$prev" != "-" ]];then
		cat $previous_manifest|awk '{print $1}' >>$tmpfile1
	fi
	if [[ "$uncha" != "-" ]];then
		cat $unchanged_manifest|awk '{print $1}' >>$tmpfile1
	fi

cat ${tmpfile1} | sort | uniq > ${tmpfile2}
rm ${tmpfile1}


cat ${AT_ETC}/headercontent > ${output}
echo "<h1>Content for ${CI_SHIPMENT} ${CI_PLATFORM}</h1>" >>${output}
echo "<h3>Current Version: Shows current version of package used in install</h3>" >>${output} 
echo "<h3>Previous Version: Shows version of package used in last CI install</h3>" >>${output}
echo "<h3>Changed: Shows version of package in unchanged DM install</h3>" >>${output}
echo "<TABLE id=table-1 class=sort-table frame=box><THEAD><TR><TD>Package</TD><TD>Current Version</TD><TD>Previous Version</TD><TD>DM build Version</TD><TD>Changed</TD></THEAD><TBODY>" >> ${output}
while read package
do
	class="normal"
	diff="No"
	current=$(grep "$package " $current_manifest |awk '{print $3}')
	if [[ "$prev" != "-" ]];then
		prev=$(grep "$package " $previous_manifest |awk '{print $3}')
	fi
	if [[ "$uncha" != "-" ]];then
		uncha=$(grep "$package " $unchanged_manifest |awk '{print $3}')
	fi
	if [[ "$current" != "$prev" || "$current" != "$uncha" ]];then
		class="change"
		diff="Yes"
	fi

echo "<TR><TD class = ${class}>${package}</TD><TD class = ${class}>${current}</TD><TD class = ${class}>${prev}</TD><TD class = ${class}>${uncha}</TD><TD class = ${class}>${diff}</TD></TR>" >> ${output}
		

done < "${tmpfile2}"
cat ${AT_ETC}/footercontent >> ${output}
rm ${tmpfile2}

}

checkMirrors ()
{
local _server=$1
	$EXPECT $AT_LIB/exp_files/check_mirrors_II.exp ${_server}
	ret=$?
	return $ret
}

#
# function to do initial install prep, create HTML reports etc
#

II_prep () {
	# copy pre-ini files to mws
	dest1=/net/${CI_MWS_IP}/JUMP/MWS_add_client_files
       	for inifile in ${AT_ROOT}/build_scripts/infrastructure/etc/preini/preinirate_${CI_ADMIN1_HOSTNAME} \
			${AT_ROOT}/build_scripts/infrastructure/etc/preini/add_cluster_node_to_${CI_ADMIN1_HOSTNAME} \
			${AT_ROOT}/build_scripts/infrastructure/etc/preini/${CI_ADMIN1_HOSTNAME}.ini; do
		if [ -f $inifile ]; then
			echo "Copying $inifile to MWS"
               		basefile=$(/bin/basename $inifile)
			if [ -f $dest1/$basefile ]; then
				/bin/rm -f $dest1/$basefile
			fi
               		/bin/cp $inifile $dest1/ && /bin/chmod 777 $dest1/$basefile
		fi
       	done

	if [ "$CI_ENVIRONMENT" = vmware ]; then
		files="$AT_LIB/exp_files/vApp_power.pl $AT_LIB/exp_files/mac_address.pl $AT_LIB/exp_files/BootOrder.pl $AT_LIB/exp_files/jumpit_vmware.bsh"
		$EXPECT $AT_BIN/ssh_setup2.sh scp "$files root@$VMA_SERVER:/ci" $VMA_SERVER_ROOTPW || {
			error "Failed to copy required files to VMA server" "File copy error"
			return 1
		}
	fi
		
	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
		create_content || return 1
		cp /net/${CI_MWS_HOSTNAME}/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_$CI_RELEASE/$CI_SHIPMENT/ossrc_base_sw/build_manifest_${CI_PLATFORM} /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/build_manifest_${CI_PLATFORM}_II_CI_PREVIOUS
		installstart=`date +'%a %b %e %Y %T'`
		echo -ne "$installstart" > /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/results1-${CI_PLATFORM}-$WDATE
	fi

	
}

#
# function to do initial install wrap-up tasks
#
II_wrapup() {
	echo "doing wrap-up tasks"
	installfinish=`date +'%a %b %e %Y %T'`
	testdate=`date '+%Y%m%d'`
	testtime=`date '+%H:%M:%S'`
	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
		checkformat=$((`cat /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results1-$CI_PLATFORM-$WDATE|$SED 's/[^@]//g'|wc -m`-1))
		[ ! -f /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results ] && {
			touch /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results
			chmod 777 /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results
		}
		if [[ "$checkformat" != "10" ]];then
			echo "<TR><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD></TR>" >> /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results
		else
			cat /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results1-$CI_PLATFORM-$WDATE >> /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results
		fi
	fi
	#rm /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/results1-$CI_PLATFORM-$WDATE 
}

# perform the required config on the MWS
X86II_mws_config() {
	X86II_add_mws_admin1_dhcp_client | tee -a $LOGDIR/$INSTALL 
	[ ${PIPESTATUS[0]} -ne 0 ] && {
		 error "Failed to add admin1 as install client on MWS" "admin1 MWS issue"
		return 1
	}
	if [ "$CI_ADMIN2_HOSTNAME" != NO ]; then
		X86II_add_mws_admin2_dhcp_client | tee -a $LOGDIR/$INSTALL  
		[ ${PIPESTATUS[0]} -ne 0 ] && {
		 	error "Failed to add admin2 as install client on MWS" "admin2 MWS issue"
			return 1
		}
	fi
	return 0
}

# function to add specified server as client on MWS
X86II_add_mws_admin1_dhcp_client () {
	get_server_details $CI_ADMIN1_HOSTNAME  || {
		 error "Failed to get admin1 server details" "CI config issue"
		return 1
	}
	macaddr=${_SERVER_DETAILS[2]}
	ip_addr=${_SERVER_DETAILS[1]}
	ipv6_addr=${_SERVER_DETAILS[10]}
	march=${_SERVER_DETAILS[3]}
	server_vendor=${_SERVER_DETAILS[5]}
	netmask=${_SERVER_DETAILS[14]}
	# netmask not given in env file ? Try getting from pre-ini file
	if [ -z "$netmask" ]; then
		get_preini_param $CI_ADMIN1_HOSTNAME pubNETMM netmask
	fi
	get_preini_param $CI_ADMIN1_HOSTNAME PRIMARYFQHN ldap_server
	get_preini_param $CI_ADMIN1_HOSTNAME LDAPSERVERIP ldap_server_ip
	rootcer_location=/JUMP/MWS_add_client_files/rootcer/rootca.cer.$ldap_server
	preini_file=/net/${CI_MWS_IP}/JUMP/MWS_add_client_files/preinirate_${CI_ADMIN1_HOSTNAME}
	get_preini_param $CI_ADMIN1_HOSTNAME LDAPDOMAINNAME ldap_domain_name
	get_preini_param $CI_ADMIN1_HOSTNAME LDAPPROXYPASSWORD ldap_proxy_pass
	get_preini_param $CI_ADMIN1_HOSTNAME LDAPCLIENTCERTDBPW ldap_certdb_pass
	if [ -z "$ldap_server" ]; then
		ldap_server=none
		ldap_domain_name=${CI_ADMIN1_HOSTNAME}.com
	else
		# check if rootca for this ldap server installed on MWS
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$CI_MWS_HOSTNAME /ericsson/jumpstart/bin/manage_pks_rootcerts.bsh -a list" $CI_MWS_ROOTPW | grep -w $ldap_server > /dev/null || {
			[[  -f "/var/tmp/rootca.cer.$ldap_server" ]] && rm /var/tmp/rootca.cer.$ldap_server
                	$EXPECT $AT_LIB/exp_files/getldaprootca.exp $ldap_server $ldap_server_ip
                	[[  -f "/var/tmp/rootca.cer.$ldap_server" ]] || {
				 error "no rootca.cer found" "rootca problem"
				return 1
			}
			if [ -s /net/${CI_MWS_HOSTNAME}/$rootcer_location ]; then
				/bin/rm -f /net/${CI_MWS_HOSTNAME}/$rootcer_location
			fi
                	cp /var/tmp/rootca.cer.$ldap_server /net/${CI_MWS_IP}/JUMP/MWS_add_client_files/rootcer/ || {
				echo "Error - failed to copy root certificate to MWS"
				return 1
			}
			
                	$EXPECT $AT_LIB/exp_files/add_ldap_rootcer.exp $ldap_server $CI_MWS_HOSTNAME $CI_MWS_ROOTPW || {
				echo "Error - failed to add rootca on MWS"
				return 1 
			}
		}

		
	fi
	X86II_removeDHCPConfig ${CI_ADMIN1_HOSTNAME} || return 1
	mws_clientfile=/net/${CI_MWS_IP}/JUMP/MWS_add_client_files/mws_${CI_ADMIN1_HOSTNAME}
	[ -s $mws_clientfile ] && /bin/rm -f $mws_clientfile
	touch $mws_clientfile || {
		echo "Error - failed to create file $mws_clientfile"
		return 1
	}
	sollocmws=$(cat /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/sol_x86.loc)
	[ -z "$sollocmws" ] && {
		echo "Error - unable to determine solaris jumpstart location for $CI_RELEASE/$CI_SHIPMENT"
		return 1
	}
	if [ "$server_vendor" = vmware ]; then
		vga_type=VGA
	else
		vga_type=NON-VGA
	fi
	cat << EOF > $mws_clientfile
CLIENT_HOSTNAME@$CI_ADMIN1_HOSTNAME
CLIENT_IP_ADDR@$ip_addr
CLIENT_NETMASK@$netmask
CLIENT_MAC_ADDR@$macaddr
CLIENT_ARCH@i86pc
CLIENT_DISP_TYPE@$vga_type
LDAP_SERVER_HOSTNAME@$ldap_server
LDAP_DOMAIN_NAME@$ldap_domain_name
LDAP_ROOTCERT@$rootcer_location
CLIENT_JUMP_LOC@$sollocmws
CLIENT_OM_LOC@/JUMP/OM_MEDIA/OSSRC_$CI_OM_RELEASE/$CI_OM_SHIPMENT
CLIENT_APPL_TYPE@ossrc
CLIENT_APPL_MEDIA_LOC@/JUMP/OSSRC_MEDIA/OSSRC_$CI_RELEASE/$CI_SHIPMENT
IPV6_PARAMETER@${CI_IPV6}
EOF
	if [ "$CI_IPV6" = YES ]; then
		echo "CLIENT_IP_ADDR_V6@$ipv6_addr" >> $mws_clientfile
		echo "ROUTER_IP_ADDR_V6@$CI_IPV6_ROUTER" >> $mws_clientfile
	fi
	if  [ ${CI_PRE_INI} = "YES" ] ;then
		getVeritasLicense || {
			error "Error - failed to get Veritas License key" "Veritas License problem"
			return 1
		}
		if [ ! -s $preini_file ]; then
			error "Error - failed to locate preini file \"$preini_file\" or file empty" "preini problem"
			return 1
		fi
		installcmd="CLIENT_INSTALL_PARAMS@- install label_disks inst_type=ossrc config=system rmirr ppass=$ldap_proxy_pass dpass=$ldap_certdb_pass pre_ini=${CI_MWS_IP}:/JUMP/MWS_add_client_files/"
        	$SED s/VXVMLIC.*/VXVMLIC=$VER_LIC/ $preini_file > /tmp/preini.$$ &&
        	chmod 777 /tmp/preini.$$
               	/bin/mv -f /tmp/preini.$$ $preini_file || {
			error "Error - failed to update preini file" "preini problem"
			return 1
		}
	
	else
        	installcmd="CLIENT_INSTALL_PARAMS@- install inst_type=ossrc config=system environ=test label_disks"
	fi
	if [ "$CI_ENVIRON_TEST" = TRUE ]; then
		installcmd="$installcmd environ=test"
	fi
	if [ "$CI_COMPACT_OSS" = TRUE ]; then
		installcmd="$installcmd environ=basic"
	fi

	echo $installcmd >> $mws_clientfile
	wait_mws_dhcp_free || return 1
	$EXPECT $AT_LIB/exp_files/add_mws_client.exp $( basename $mws_clientfile ) $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
	if [[ "$?" != "0" ]];then
                echo "MWS add client failed"
		return 1
        fi
	#/bin/rm -f $mws_clientfile
}


# function to add admin2 client on MWS

X86II_add_mws_admin2_dhcp_client () {
	get_server_details $CI_ADMIN2_HOSTNAME || {
		error "Unable to get admin2 details" "CI config issue"
		return 1
	}
	macaddr=${_SERVER_DETAILS[2]}
	ip_addr=${_SERVER_DETAILS[1]}
	ipv6_addr=${_SERVER_DETAILS[10]}
	march=${_SERVER_DETAILS[3]}
	server_vendor=${_SERVER_DETAILS[5]}
	netmask=${_SERVER_DETAILS[14]}
	# if netmask is not in env file, try pre-ini file
	[ -z "$netmask" ] && {
		get_preini_param $CI_ADMIN1_HOSTNAME pubNETMM netmask
	}
	X86II_create_dhcp_client_file $CI_ADMIN2_HOSTNAME $ip_addr $netmask $macaddr $server_vendor "inst_type=ossrc bmr_inst rmirr" || return 1

}

X86II_add_mws_admin2_dhcp_client_edavgly () {
	get_server_details $CI_ADMIN1_HOSTNAME || {
		error "Unable to get admin1 details" "CI config issue"
		return 1
	}
	macaddr=${_SERVER_DETAILS[2]}
	ip_addr=${_SERVER_DETAILS[1]}
	ipv6_addr=${_SERVER_DETAILS[10]}
	march=${_SERVER_DETAILS[3]}
	server_vendor=${_SERVER_DETAILS[5]}
	netmask=${_SERVER_DETAILS[14]}
	# if netmask is not in env file, try pre-ini file
	[ -z "$netmask" ] && {
		get_preini_param $CI_ADMIN1_HOSTNAME pubNETMM netmask
	}
	X86II_create_dhcp_client_file $CI_ADMIN1_HOSTNAME $ip_addr $netmask $macaddr $server_vendor "inst_type=ossrc bmr_inst rmirr" || return 1

}

# function to add solaris only client on MWS
X86II_add_mws_solonly_dhcp_client () {
	hostname=$1
	if [ -z "$hostname" ]; then
		echo "Error: $FUNCNAME: hostname not specified"
		return 1
	fi
	get_server_details $hostname || {
		error "Unable to get $hostname details" "CI config issue"
		return 1
	}
	macaddr=${_SERVER_DETAILS[2]}
	ip_addr=${_SERVER_DETAILS[1]}
	ipv6_addr=${_SERVER_DETAILS[10]}
	march=${_SERVER_DETAILS[3]}
	server_vendor=${_SERVER_DETAILS[5]}
	netmask=${_SERVER_DETAILS[14]}
	X86II_create_dhcp_client_file $hostname $ip_addr $netmask $macaddr $server_vendor "inst_type=cominf config=smrs_slave" || return 1
}
#
# Function to create file to add DHCP client
#
X86II_create_dhcp_client_file () {
	hostname=$1
	ip_addr=$2
	netmask=$3
	macaddr=$4
	server_vendor=$5
	client_install_params=$6

	if [ -z "$hostname" ]; then
		echo "Error: $FUNCNAME - hostname param blank"
		return 1
	fi
	if [ -z "$ip_addr" ]; then
		echo "Error: $FUNCNAME - ip_addr param blank"
		return 1
	fi
	if [ -z "$netmask" ]; then
		echo "Error: $FUNCNAME - netmask param blank"
		return 1
	fi
	if [ -z "$macaddr" ]; then
		echo "Error: $FUNCNAME - macaddr param blank"
		return 1
	fi
	if [ -z "$server_vendor" ]; then
		echo "Error: $FUNCNAME - server_vendor param blank"
		return 1
	fi
	if [ -z "$client_install_params" ]; then
		echo "Error: $FUNCNAME - client_install_params param blank"
		return 1
	fi

	X86II_removeDHCPConfig ${hostname} || return 1
	
	mws_clientfile=/net/${CI_MWS_IP}/JUMP/MWS_add_client_files/mws_${hostname}
	[ -s $mws_clientfile ] && /bin/rm -f $mws_clientfile
	touch $mws_clientfile || {
		echo "Error - failed to create file $mws_clientfile"
		return 1
	}
	sollocmws=$(cat /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/${CI_SHIPMENT_SRC}/sol_x86.loc)
	[ -z "$sollocmws" ] && {
		echo "Error - unable to determine solaris jumpstart location for $CI_RELEASE/$CI_SHIPMENT"
		return 1
	}
	if [ "$server_vendor" = vmware ]; then
		vga_type=VGA
	else
		vga_type=NON-VGA
	fi
	cat << EOF > $mws_clientfile
CLIENT_HOSTNAME@$hostname
CLIENT_IP_ADDR@$ip_addr
CLIENT_NETMASK@$netmask
CLIENT_MAC_ADDR@$macaddr
CLIENT_ARCH@i86pc
CLIENT_DISP_TYPE@$vga_type
LDAP_SERVER_HOSTNAME@none
LDAP_DOMAIN_NAME@none
LDAP_ROOTCERT@none
CLIENT_JUMP_LOC@$sollocmws
CLIENT_OM_LOC@/JUMP/OM_MEDIA/OSSRC_$CI_RELEASE/$CI_SHIPMENT
CLIENT_APPL_TYPE@solonly
CLIENT_APPL_MEDIA_LOC@/JUMP/OSSRC_MEDIA/OSSRC_$CI_RELEASE/$CI_SHIPMENT
IPV6_PARAMETER@${CI_IPV6}
CLIENT_INSTALL_PARAMS@- install $client_install_params
EOF
	if [ "$CI_IPV6" = YES ]; then
		echo "CLIENT_IP_ADDR_V6@$ipv6_addr" >> $mws_clientfile
		echo "ROUTER_IP_ADDR_V6@$CI_IPV6_ROUTER" >> $mws_clientfile
	fi
	wait_mws_dhcp_free || return 1
	$EXPECT $AT_LIB/exp_files/add_mws_client.exp $( basename $mws_clientfile ) $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
	if [[ "$?" != "0" ]];then
                echo "MWS add client failed"
		return 1
        fi
	#/bin/rm -f $mws_clientfile

}

#
# Function to verify admin1 and admin2 are added as DHCP
# clients on MWS
#

X86II_verifyMWSDHCPConfig() {
	for host in $CI_ADMIN1_HOSTNAME $CI_ADMIN2_HOSTNAME; do
		X86II_verifyMWSDHCPConfig_sub $host || return 1 
	done
}

#
# Function to remove DHCP profile from MWS
#
#

X86II_removeDHCPConfig() {
	hostname=$1
	if [ -z "$hostname" ]; then
		echo "Error - $FUNCNAME: hostname parameter not specified"
		return 1
	fi
	echo "Attempting to remove $hostname as client on DHCP"
	X86II_verifyMWSDHCPConfig_sub $hostname || return 0 
        $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$CI_MWS_HOSTNAME /ericsson/jumpstart/bin/manage_dhcp_clients.bsh -a remove -c $hostname -N" $CI_MWS_ROOTPW
        if [ $? -ne 0 ]; then
               echo "Error - failed to remove $hostname as client on MWS"
               return 1
        fi
	return 0


}

#
# function to check for running instance of 
# manage_dhcp_clients.bsh on MWS and block while running
#
wait_mws_dhcp_free() {
	local l_mws_add_dhcpclientscript="/ericsson/jumpstart/bin/manage_dhcp_clients.bsh"
        local l_dhcpscriptpids=$( pgrep -f $l_mws_add_dhcpclientscript )
	local l_count=0
	local l_sleepinterval=60
	local l_retrycnt=120
	echo "Checking for instance of $l_mws_add_dhcpclientscript running on MWS"
	/bin/rm -f /tmp/mdhcp.pids
        $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$CI_MWS_HOSTNAME pgrep -f '^/bin/bash /ericsson/jumpstart/bin/manage_dhcp_clients.bsh' > /tmp/mdhcp.pids" $CI_MWS_ROOTPW 
        $EXPECT $AT_BIN/ssh_setup2.sh scp "root@$CI_MWS_HOSTNAME:/tmp/mdhcp.pids /tmp" $CI_MWS_ROOTPW > /dev/null || {
		echo "Error in $FUNCNAME: unable to determine $l_mws_add_dhcpclientscript pids on $CI_MWS_HOSTNAME"
		return 1
	}	
	l_dhcpscriptpids=$( cat /tmp/mdhcp.pids )
        if [ -n "$l_dhcpscriptpids" ]; then
                while [ $l_count -lt $l_retrycnt ]; do
                	echo "Waiting for instance(s) of $l_mws_add_dhcpclientscript (pid(s)=$l_dhcpscriptpids) to finish"
                        [ -z "$l_dhcpscriptpids" ] && break
                        sleep $l_sleepinterval
			/bin/rm -f /tmp/mdhcp.pids
        		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$CI_MWS_HOSTNAME pgrep -f '^/bin/bash /ericsson/jumpstart/bin/manage_dhcp_clients.bsh' > /tmp/mdhcp.pids" $CI_MWS_ROOTPW 
        		$EXPECT $AT_BIN/ssh_setup2.sh scp "root@$CI_MWS_HOSTNAME:/tmp/mdhcp.pids /tmp" $CI_MWS_ROOTPW > /dev/null || {
				echo "Error in $FUNCNAME: unable to determine $l_mws_add_dhcpclientscript pids on $CI_MWS_HOSTNAME"
				return 1
			}	
			l_dhcpscriptpids=$( cat /tmp/mdhcp.pids )
                        let l_count+=1
                done
        fi
        [ -n "$l_dhcpscriptpids" ] && {
                error "Timed out waiting for instance(s) of $l_mws_add_dhcpclientscript to finish"
                return 1
        }
	return 0
}


#
# Function to verify hostname added as DHCP
#

X86II_verifyMWSDHCPConfig_sub() {
	hostname=$1
	if [ -z "$hostname" ]; then
		echo "Error - $FUNCNAME: hostname parameter not specified"
		return 1
	fi
        $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$CI_MWS_HOSTNAME /ericsson/jumpstart/bin/manage_dhcp_clients.bsh -a list -c $hostname" $CI_MWS_ROOTPW
        if [ $? -ne 0 ]; then
               echo "Error - failed to verify $hostname is added as DHCP client on MWS"
               return 1
        fi
	return 0


}



#
# Function to jumpstart admin1
#
X86II_admin1_jump() {
	[ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && {
		echo "*debug* - exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE"
		[ $CI_DEBUG_SKIP_JUMP_RETURN_CODE -eq 1 ] && error "exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE" "debug exit"
		return $CI_DEBUG_SKIP_JUMP_RETURN_CODE
	}
	$EXPECT $AT_BIN/ssh_setup2.sh scp "$AT_BIN/ssh_setup2.sh $AT_LIB/exp_files/delete_fs.bsh root@${CI_MWS_IP}:/var/tmp" $CI_MWS_ROOTPW || {
		echo  "*WARNING* failed to copy config scripts to MWS"
	}
	$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_MWS_IP} /var/tmp/delete_fs.bsh -p /JUMP/MWS_add_client_files/preinirate_${CI_ADMIN1_HOSTNAME}" $CI_MWS_ROOTPW || {
		echo  "*WARNING* failed to delete cluster file systems from SFS "
	}
	

	#$EXPECT $AT_LIB/exp_files/delete_FS.exp $CI_ADMIN1_HOSTNAME | tee -a $LOGDIR/$INSTALL
	#$EXPECT $AT_LIB/exp_files/rm_scsi_keys.exp $CI_ADMIN1_HOSTNAME| tee -a $LOGDIR/$INSTALL
	get_server_details $CI_ADMIN1_HOSTNAME
	if [ $? -ne "0" ]; then
        	error "Admin1 configuration not found.. Unable to continue jumpstart.." "CI config issue"
		return 1
	fi
	server_vendor=${_SERVER_DETAILS[5]}
	if [ "$server_vendor" = vmware ]; then
		vm_host=${_SERVER_DETAILS[12]}
		if [ -z "$vm_host" ]; then
			error "Unable to determine vm host of  server $CI_ADMIN1_HOSTNAME" "CI config issue"
			return 1
		fi
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$VMA_SERVER /ci/jumpit_vmware.bsh $vm_host $CI_ADMIN1_HOSTNAME" $VMA_SERVER_ROOTPW || {
			error "Jumpstart of admin1 failed" "admin1 jumpstart failure"
			return 1
		}
	else
		# assume HP hw
		ilo_ip=${_SERVER_DETAILS[4]}
		if [ -z "$ilo_ip" ]; then
			error "Unable to determine ILO IP of server $CI_ADMIN1_HOSTNAME" "CI config issue"
			return 1
		fi
		ipmitoolboot=false
		if [ "$CI_IPMITOOL_PXEBOOT" = TRUE ]; then
			X86_install_ipmi_pxeboot $CI_ADMIN1_HOSTNAME || {
				error "Problem occured trying to pxe-boot $CI_ADMIN1_HOSTNAME using ipmitool" "CI config issue"
				return 1
			}
			ipmitoolboot=true
		fi
		
		$EXPECT $AT_LIB/exp_files/jumpit_mws.exp $CI_ADMIN1_HOSTNAME $ilo_ip $ipmitoolboot | tee -a $LOGDIR/$INSTALL
		
	fi
	[ ${PIPESTATUS[0]} -ne 0 ] && { 
		error "Jumpstart of admin1 failed" "admin1 jumpstart failure"
		return 1
	}
	return 0
}

#
# Function to jumpstart admin2
#
X86II_admin2_jump() {
        [ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && {
                echo "*debug* - exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE"
                [ $CI_DEBUG_SKIP_JUMP_RETURN_CODE -eq 1 ] && error "exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE" "debug exit"
                return $CI_DEBUG_SKIP_JUMP_RETURN_CODE
        }
        get_server_details $CI_ADMIN2_HOSTNAME
        if [ $? -ne "0" ]; then
                error "Admin2 configuration not found.. Unable to continue jumpstart.." "CI config issue"
                return 1
        fi
        ilo_ip=${_SERVER_DETAILS[4]}
        if [ -z "$ilo_ip" ]; then
                error "Unable to determine ILO IP of server $CI_ADMIN2_HOSTNAME" "CI config issue"
                return 1
        fi
        ipmitoolboot=false
        if [ "$CI_IPMITOOL_PXEBOOT" = TRUE ]; then
                X86_install_ipmi_pxeboot $CI_ADMIN2_HOSTNAME || { 
                error "Problem occured trying to pxe-boot $CI_ADMIN2_HOSTNAME using ipmitool" "CI config issue"
                return 1
                }
                ipmitoolboot=true
        fi

        $EXPECT $AT_LIB/exp_files/jumpit_admin2.exp $CI_ADMIN2_HOSTNAME $ilo_ip $ipmitoolboot | tee -a $LOGDIR/$INSTALL
        [ ${PIPESTATUS[0]} -ne 0 ] && {
                error "Jumpstart of admin2 failed" "admin2 jumpstart failure"
                return 1
        }
        return 0
}

X86II_admin2_jump_edavgly() {
        [ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && {
                echo "*debug* - exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE"
                [ $CI_DEBUG_SKIP_JUMP_RETURN_CODE -eq 1 ] && error "exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE" "debug exit"
                return $CI_DEBUG_SKIP_JUMP_RETURN_CODE
        }
        get_server_details $CI_ADMIN2_HOSTNAME
        if [ $? -ne "0" ]; then
                error "Admin2 configuration not found.. Unable to continue jumpstart.." "CI config issue"
                return 1
        fi
        ilo_ip=${_SERVER_DETAILS[4]}
        if [ -z "$ilo_ip" ]; then
                error "Unable to determine ILO IP of server $CI_ADMIN2_HOSTNAME" "CI config issue"
                return 1
        fi
        ipmitoolboot=false
        if [ "$CI_IPMITOOL_PXEBOOT" = TRUE ]; then
                X86_install_ipmi_pxeboot $CI_ADMIN2_HOSTNAME || { 
                error "Problem occured trying to pxe-boot $CI_ADMIN2_HOSTNAME using ipmitool" "CI config issue"
                return 1
                }
                ipmitoolboot=true
        fi

        $EXPECT $AT_LIB/exp_files/edavgly/jumpit_admin2.exp $CI_ADMIN2_HOSTNAME $ilo_ip $ipmitoolboot | tee -a $LOGDIR/$INSTALL
        [ ${PIPESTATUS[0]} -ne 0 ] && {
                error "Jumpstart of admin2 failed" "admin2 jumpstart failure"
                return 1
        }
        return 0
}

#
# Function to add admin2 server to cluster and configure root disk mirroring
#

X86II_add_admin2_to_cluster () {
	$EXPECT $AT_LIB/exp_files/add_admin2.exp $CI_ADMIN1_HOSTNAME $CI_ADMIN2_HOSTNAME $CI_MWS_IP $CI_MWS_ROOTPW | tee -a $LOGDIR/$INSTALL
	[ ${PIPESTATUS[0]} -ne 0 ] && { 
		error "Adding admin2 to cluster failed" "admin2 add cluster issue"
		return 1
	}
	$SLEEP 1800
echo "TODO: expect mr_admin2_II.exp needs work"
	$EXPECT $AT_LIB/exp_files/dmr_admin2_II.exp ${CI_ADMIN2_HOSTNAME} | tee -a $LOGDIR/$INSTALL
	[ ${PIPESTATUS[0]} -ne 0 ] && {
		 error "Configuring root disk mirroring on admin2 failed" "admin2 DMR issue"
		return 1
	}
	$SLEEP 300
	return 0


}

# X86 jumpstart solaris only
X86II_solonly_jump() {
	hostname=$1
	if [ -z "$hostname" ]; then
		echo "Error: $FUNCNAME: hostname not specified"
		return 1
	fi

	[ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && {
		echo "*debug* - exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE"
		[ $CI_DEBUG_SKIP_JUMP_RETURN_CODE -eq 1 ] && error "exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE" "debug exit"
		return $CI_DEBUG_SKIP_JUMP_RETURN_CODE
	}
	get_server_details $hostname
	if [ $? -ne "0" ]; then
        	error "Host $hostname configuration not found.. Unable to continue jumpstart.." "CI config issue"
		return 1
	fi
	server_vendor=${_SERVER_DETAILS[5]}
	if [ "$server_vendor" = vmware ]; then
		vm_host=${_SERVER_DETAILS[12]}
		if [ -z "$vm_host" ]; then
			error "Unable to determine vm host of  server $CI_ADMIN1_HOSTNAME" "CI config issue"
			return 1
		fi
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$VMA_SERVER /ci/jumpit_vmware.bsh $vm_host $CI_ADMIN1_HOSTNAME" $VMA_SERVER_ROOTPW || {
			error "Jumpstart of admin1 failed" "admin1 jumpstart failure"
			return 1
		}
	else
		# assume HP hw
		ilo_ip=${_SERVER_DETAILS[4]}
		if [ -z "$ilo_ip" ]; then
			error "Unable to determine ILO IP of server $hostname" "CI config issue"
			return 1
		fi
		$EXPECT $AT_LIB/exp_files/jumpit_solonly.exp $hostname $ilo_ip | tee -a $LOGDIR/$INSTALL 
		[ ${PIPESTATUS[0]} -ne 0 ] && {
		 	error "Jumpstart of $hostname failed" "$hostname jumpstart failure"
			return 1
		}
	fi
	return 0
}

# dig specified parameter out of preini file
get_preini_param () {
	local l_hostname=$1
	local l_paramname=$2
	local l_varname=$3
	eval unset \$l_varname
	if [ -z "$l_hostname" ]; then
		echo "Error - $FUNCNAME: hostname not specified"
		return 1
	fi
	if [ -z "$l_paramname" ]; then
		echo "Error - $FUNCNAME: paramname not specified"
		return 1
	fi
	if [ -z "$l_varname" ]; then
		echo "Error - $FUNCNAME: varname not specified"
		return 1
	fi
	local l_preinifile=$AT_ROOT/build_scripts/infrastructure/etc/preini/preinirate_${l_hostname}
	if [ ! -s $l_preinifile ]; then
		echo "Warning - preinirate file does not exist or is empty for host $l_hostname, Checking for add_cluster file..."
		local l_preinifile=$AT_ROOT/build_scripts/infrastructure/etc/preini/add_cluster_node_to_${CI_ADMIN1_HOSTNAME}
		if [ ! -s $l_preinifile ]; then
			echo "Error - No valid preinirate_${l_hostname} or add_cluster_node_to_${CI_ADMIN1_HOSTNAME} found."
			return 1
		fi
	fi
	eval $l_varname=$(egrep "^$l_paramname[:space:]*=[:space:]*" $l_preinifile | awk -F= '{print $2}')
	

}

#
# Function to perform pxeboot of blade using ipmitool
# This avoids some issues with boot order getting reset
# when RBSU is used to set the boot order.
# This function assumes that the ipmitool package
# is installed on the Jenkins slave on which the job will run.
#

X86_install_ipmi_pxeboot() {
	local l_ipmitool=/usr/bin/ipmitool
	local l_hostname=$1
	if [ -z "$l_hostname" ]; then
		echo "$FUNCNAME - host name parameter not supplied"
		return 1
	fi
	if [ ! -x $l_impitool ]; then
		echo "Error - $l_ipmitool is not installed on $(hostname)"
		return 1
	fi 
	get_server_details $l_hostname
	local l_ilo_ip=${_SERVER_DETAILS[4]}
	local l_ilo_rootpw=${_SERVER_DETAILS[15]}
	if [[ -z "$l_ilo_ip" || -z "$l_ilo_rootpw" ]]; then
        	echo "Error - $l_hostname configuration not found.. Unable to continue jumpstart.." 
		return 1
	fi
	# configure the server to pxe boot
	echo "Configuring $l_hostname to pxe-boot using $l_ipmitool"
	$l_ipmitool -I lanplus -H $l_ilo_ip -U root -P $l_ilo_rootpw chassis bootdev pxe || {
		echo "Error - failed to configure $l_hostname to pxe-boot using $l_ipmitool"
		return 1
	}

	# reset the server
	echo "Resetting $l_hostname using $l_ipmitool"
	$l_ipmitool -I lanplus -H $l_ilo_ip -U root -P $l_ilo_rootpw chassis power cycle || {
		echo "Error - failed to reset $l_hostname using $l_ipmitool"
		return 1
	}
set +x
	return 0
}



# jumpstart a SPARC server
SPARCII_install_sparc_server() {
	echo "Configure SPARC server"
	username=lmirbe
	get_server_details $CI_ADMIN1_HOSTNAME || {
		 error "Unable to get $CI_ADMIN1_HOSTNAME server details" "CI config issue"
		return 1
	}

	ip_addr=${_SERVER_DETAILS[1]}
	macaddr=${_SERVER_DETAILS[2]}
	march=${_SERVER_DETAILS[3]}
	ilo_ip=${_SERVER_DETAILS[4]}
	boot_device=${_SERVER_DETAILS[11]}
	[ -z "$boot_device" ] && {
		echo "Waning - advisable to specifiy boot device in env file to ensure boot device is set to disk1 slice 0 before jumpstart"
		boot_device=unknown 
	}
	jumparea=/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}
	sw_location=/${CI_SHIPMENT_SRC}
	user=$($ID -un)


	if [ -z "$CI_MWS_IP" ]; then
		printf "ERROR -unable to determine IP of MWS \"$CI_MWS_HOSTNAME\"\n"
		return 1
	fi

	#if [ $( uname ) = Linux ]; then
	#	wget=/usr/bin/wget
	#else
	#	wget=/usr/sfw/bin/wget
	#fi
	wget=/usr/sfw/bin/wget
        wget2=/usr/bin/wget

	#$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@atrcx1089.athtem.eei.ericsson.se $wget -O - --user=jump --password=jump --post-data='userid='${username}'&macaddr='${macaddr}'&hostname='${CI_ADMIN1_HOSTNAME}'&jump_serv=jumpstart:'${CI_MWS_IP}:/$jumparea'&arch='${march}'&ipaddr='${ip_addr}'&sw='${sw_location}'&serial=0' http://atdhcpx1.athtem.eei.ericsson.se/batch.php" dmbld23 
        $wget2 -O - --user=jump --password=jump --post-data='userid='${username}'&macaddr='${macaddr}'&hostname='${CI_ADMIN1_HOSTNAME}'&jump_serv=jumpstart:'${CI_MWS_IP}:/$jumparea'&arch='${march}'&ipaddr='${ip_addr}'&sw='${sw_location}'&serial=0' http://atdhcpx1.athtem.eei.ericsson.se/batch.php
	#$wget -O - --user=jump --password=jump --post-data='userid='${username}'&macaddr='${macaddr}'&hostname='${CI_ADMIN1_HOSTNAME}'&jump_serv=jumpstart:'${CI_MWS_IP}:/$jumparea'&arch='${march}'&ipaddr='${ip_addr}'&sw='${sw_location}'&serial=0' http://atdhcpx1.athtem.eei.ericsson.se/batch.php
	status=$?
	if [ $status -ne "0" ]; then
		echo "DHCP configuration of $CI_ADMIN1_HOSTNAME Failed.. Unable to continue jumpstart.."
		printf "%s\t%s\n" "[NOK]" "$(date '+%H:%M:%S')"
       		return 1
	else
		printf "%s\t%s\n" "[Ok]" "$(date '+%H:%M:%S')"
        	sleep 10
	fi

	if [ "${CI_ENVIRONMENT}" = "sunfire" ]; then
		echo "Installation on SUN Non M3000 Servers (ie. V245, V240)"
		stype=sun
		savedir=`pwd`
                cd /
                lxb sol10u10sparc /net/attembak3.athtem.eei.ericsson.se/adisk/sfw/scripts/console/disconnect.sh -s $CI_ADMIN1_HOSTNAME -i $user

		sleep 15
	else
		stype=m3000
		echo "Installation on SUN M3000 Servers "
	fi


	if  [ ${CI_PRE_INI} = "YES" ] ;then
       		[[ -f "/net/${CI_MWS_IP}/JUMP/MWS_add_client_files/preinirate_${CI_ADMIN1_HOSTNAME}" ]] || {
			 error "no preini file for ${CI_ADMIN1_HOSTNAME}" "pre-ini file missing"
			return 1
		}
		getVeritasLicense || {
			error "Error - failed to get Veritas License key" "Veritas License problem"
			return 1
		}
		echo "Inserting veritas license key $VER_LIC into preini file preinirate_${CI_ADMIN1_HOSTNAME}"
		jumpit=$AT_LIB/exp_files/jumpit_${CI_PLATFORM}_${stype}_preini.exp
		cat /net/${CI_MWS_IP}/JUMP/MWS_add_client_files/preinirate_${CI_ADMIN1_HOSTNAME} | $SED s/VXVMLIC.*/VXVMLIC=$VER_LIC/ > /tmp/preini.$$
        	chmod 777 /tmp/preini.$$
        	if [[ -s /tmp/preini.$$ ]] ; then
                	cp /tmp/preini.$$ /net/${CI_MWS_IP}/JUMP/MWS_add_client_files/preinirate_${CI_ADMIN1_HOSTNAME}
        	fi
        	rm /tmp/preini.$$
	else
		[[ -f "/net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/jumpit_${CI_PLATFORM}_${stype}.exp" ]] || {
			 error "Can't find the jumpstart area" "jumpstart area not found"
			return 1
		}
		jumpit=$AT_LIB/exp_files/jumpit_${CI_PLATFORM}_${stype}.exp
	fi

	shippath=/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC
	ompath=/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_OM_RELEASE/$CI_OM_SHIPMENT_SRC
	server=atbuild
	option=YES
	mws=NO
	IPV6=NO

	echo $EXPECT $jumpit $ilo_ip $CI_MWS_IP@${shippath} $CI_MWS_IP@${ompath} "$VER_LIC" $user $CI_CORE_SETTING $CI_GRAN_SETTING $CI_WRAN_SETTING $option /net/$CI_MWS_IP/JUMP/MWS_add_client_files $boot_device
	[ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && {
		echo "*debug* - exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE"
		[ $CI_DEBUG_SKIP_JUMP_RETURN_CODE -eq 1 ] && error "exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE" "debug exit"
		return $CI_DEBUG_SKIP_JUMP_RETURN_CODE
	}
	$EXPECT $jumpit $ilo_ip $CI_MWS_IP@${shippath} $CI_MWS_IP@${ompath} "$VER_LIC" $user $CI_CORE_SETTING $CI_GRAN_SETTING $CI_WRAN_SETTING $option /net/$CI_MWS_IP/JUMP/MWS_add_client_files $boot_device
 	if [[ "$?" != "0" ]];then
		error "error: install problem" "II failed"
		return 1
        fi



}

# perform post-install checks
II_postchecks() {
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	installfinish=`date +'%a %b %e %Y %T'`
	testdate=`date '+%Y%m%d'`
	testtime=`date '+%H:%M:%S'`
	sleeptime=3600
	[ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && sleeptime=0
	get_server_details $CI_ADMIN1_HOSTNAME || {
		error "Unable to get $CI_ADMIN1_HOSTNAME server details" "CI config issue"
		return 1
	}
        
	max_try_count=720
	count=0
	echo "Waiting for MCs to come online on ${CI_ADMIN1_HOSTNAME}"
	while [ $count -le $max_try_count ]; do
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${_SERVER_DETAILS[1]} $G_SMTOOL -progress" ${_SERVER_DETAILS[8]} > /dev/null 2>&1
		ret=$?
		if [ $ret -eq 0 ]; then
			break
		fi
		sleep 10
		let count+=1
	done

	if [ $ret -ne 0 ]; then
		error "Timed out waiting for managed components to come online on ${CI_ADMIN1_HOSTNAME}"
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${_SERVER_DETAILS[1]} $G_SMTOOL -progress" ${_SERVER_DETAILS[8]}
		return 1
	fi


	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
		if [[ "$CI_ADMIN2_HOSTNAME" == "NO" ]];then
       			$EXPECT $AT_LIB/exp_files/post_check.exp $CI_ADMIN1_HOSTNAME $CI_RELEASE $CI_SHIPMENT_SRC $CI_TEAM II NA $CI_PLATFORM $testdate $testtime "$installfinish" "$WDATE" "$II_build_complete" 8 NO $CI_MWS_HOSTNAME | tee -a $LOGDIR/$INSTALL
		else
       			$EXPECT $AT_LIB/exp_files/post_check.exp $CI_ADMIN1_HOSTNAME $CI_RELEASE $CI_SHIPMENT_SRC $CI_TEAM II NA $CI_PLATFORM $testdate $testtime "$installfinish" "$WDATE" "$II_build_complete" 13 $CI_ADMIN2_HOSTNAME $CI_MWS_HOSTNAME | tee -a $LOGDIR/$INSTALL
		fi
		if [ -f $LOGDIR/${INSTALL} ]; then
			[[ -f $LOGDIRHTML/install_$CI_PLATFORM.html ]] && rm $LOGDIRHTML/install_$CI_PLATFORM.html 
			echo "<html> <body>"  > $LOGDIRHTML/install-$CI_PLATFORM-$WDATE.html
               		cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/install-$CI_PLATFORM-$WDATE.html
			echo "</body></html>"  >> $LOGDIRHTML/install-$CI_PLATFORM-$WDATE.html
		fi
		if [ -f $TESTLOGDIR/post_check-II-$CI_RELEASE-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt ]; then
			echo "<html> <body>"  > $LOGDIRHTML/test-$CI_PLATFORM-$WDATE.html
			echo "<br><h1>Summary</h1>"  >> $LOGDIRHTML/test-$CI_PLATFORM-$WDATE.html
               		cat $TESTLOGDIR/post_check-II-$CI_RELEASE-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt| grep RESULT | $SED s/"$ RESULTLINE:"//g | $SED s/"RESULTLINE:"//g | $SED 's/$/\<BR\>/'>> $LOGDIRHTML/test-$CI_PLATFORM-$WDATE.html
			echo "<br><h1>Summary End</h1>"  >> $LOGDIRHTML/test-$CI_PLATFORM-$WDATE.html
               		cat $TESTLOGDIR/post_check-II-$CI_RELEASE-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt| $SED 's/$/\<BR\>/'>> $LOGDIRHTML/test-$CI_PLATFORM-$WDATE.html
			echo "</body></html>"  >> $LOGDIRHTML/test-$CI_PLATFORM-$WDATE.html
        	fi
	fi

}

#
# Function to update HTML log from TXT log
#
updateHTMLFromTXTLog() {
	if [ -f $LOGDIR/${INSTALL} ]; then
		[[ -f $LOGDIRHTML/install_$CI_PLATFORM.html ]] && rm $LOGDIRHTML/install_$CI_PLATFORM.html
		echo "<html> <body>"  > $LOGDIRHTML/install-$CI_PLATFORM-$WDATE.html
		cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/install-$CI_PLATFORM-$WDATE.html
		echo "</body></html>"  >> $LOGDIRHTML/install-$CI_PLATFORM-$WDATE.html
	fi
}



xUG_offline_peer_mcs ()
{
server1=$1
server2=$2
function=$3

#set -xv
echo "Server1:$server1"
echo "Server2:$server2"

$EXPECT << EOF
spawn scp -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no $cmddir_bash/login_upgraded_node.sh root@${server1}.athtem.eei.ericsson.se:/var/tmp
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"
                        break}

                }
        }
expect "#"
exit 0
expect closed
EOF

flag=$?

$EXPECT << EOF
spawn scp -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no $cmddir_bash/login_peer_server.sh root@${server1}.athtem.eei.ericsson.se:/var/tmp
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"}
                "Password:" {
                        send "shroot\r"
                        break}

                }
                break
        }
expect "#"
exit 0
expect closed
EOF

flag1=$?

#if [ $? -eq 0 ]  && [ $flag -eq 0 ] && [ $flag1 -eq 0 ]
#then

if [ "$function" == "RB" ]
then
$EXPECT << EOF
spawn ssh -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no root@${server1}.athtem.eei.ericsson.se
set timeout 500
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"
                        break}
                }
                break
        }
expect "#"
send -- "chmod a+x /var/tmp/login_upgraded_node.sh\r"
expect "#"
send -- "/var/tmp/login_upgraded_node.sh Off RB\r"
sleep 200
expect " #"
send "exit\r"
exit 0
expect closed
EOF

elif  [ "$function" == "CO" ]
then
$EXPECT << EOF
spawn ssh -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no root@${server1}.athtem.eei.ericsson.se
set timeout 500
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"
                        break}
                }
                break
        }
expect "#"
send -- "chmod a+x /var/tmp/login_upgraded_node.sh\r"
expect "#"
send -- "/var/tmp/login_upgraded_node.sh Off CO\r"
sleep 200
expect " #"
send "exit\r"
exit 0
expect closed
EOF

fi

if [ "$function" == "SC" ]
then
$EXPECT << EOF
spawn ssh -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no root@${server1}.athtem.eei.ericsson.se
set timeout 500
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "login: " {
                        send "root\r"}

                "Password:" {
                        send "shroot\r"
                        break}
        }
        break
}
expect "#"
send "ssh ${server2}-priv\r"
#exp_internal 1
expect "#"
send -- "chmod a+x /var/tmp/login_upgraded_node.sh\r"
expect "#"
send -- "/var/tmp/login_upgraded_node.sh Off SC\r"
sleep 200
expect " #"
send "exit\r"
exit 0
expect closed
EOF
fi


#elif [ $function == "RB" ]
##then
#       echo "Cutover to the upgraded node is not performed"
#fi

}

xUG_online_peer_mcs ()
{
admin1=$1
admin2=$2
function=$3

echo " xUG_online_peer_mcs " 
echo "Admin1:$admin1"
echo "Admin2:$admin2"
$EXPECT << EOF
spawn scp -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no $cmddir_bash/login_upgraded_node.sh root@${admin1}.athtem.eei.ericsson.se:/var/tmp
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"}
                "Password:" {
                        send "shroot\r"
                        break}

                }
                break
        }
expect "#"
exit 0
expect closed
EOF

flag=$?

$EXPECT << EOF
spawn scp -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no $cmddir_bash/login_peer_server.sh root@${admin1}.athtem.eei.ericsson.se:/var/tmp
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"}
                "Password:" {
                        send "shroot\r"
                        break}

                }
                break
        }
expect "#"
exit 0
expect closed
EOF

#if [ $? -eq 0 ]  && [ $flag -eq 0 ]
#then

if [ "$function" == "RB" ]
then
$EXPECT << EOF
spawn ssh -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no root@${admin1}.athtem.eei.ericsson.se
set timeout 500
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"
                        break}
                }
        }
expect "#"
send -- "chmod a+x /var/tmp/login_upgraded_node.sh\r"
expect "#"
send -- "/var/tmp/login_upgraded_node.sh On RB\r"
sleep 200
expect " #"
send "exit\r"
exit 0
expect closed
EOF
elif [ "$function" == "CO" ]
then
$EXPECT << EOF
spawn ssh -oUserKnownHostsFile=/dev/null -ostricthostkeychecking=no root@${admin2}.athtem.eei.ericsson.se
set timeout 500
#exp_internal 1
while 1 {
        expect {
                "Are you sure you want to continue connecting" {
                        send "yes\r"}
                "Password:" {
                        send "shroot\r"
                        break}
                }
        }
expect "#"
send -- "chmod a+x /var/tmp/login_upgraded_node.sh\r"
expect "#"
send -- "/var/tmp/login_upgraded_node.sh On CO\r"
sleep 200
expect " #"
send "exit\r"
exit 0
expect closed
EOF

fi


}


#
# gets server details from env file
# Populates array _SERVER_DETAILS
# 0=hostname, 1=ip, 2=mac addr, 3=arch
# 4=ilo_ip, 5=vendor_ip, 6=inst_type
# 7=config, 8=rootpw, 9=harness_host
# 10=ipv6 11=boot device 12=vmware host
# 13=backup ip 14=netmask 15=ilo rootpw


get_server_details () {
	local l_hostname=$1
	local l_count=0
	unset _SERVER_DETAILS
	if [ -z "$l_hostname" ]; then
		echo "Error - hostname argument is blank"
		return 1
	fi
	while [ $l_count -lt ${#CI_SERVER_HOSTNAME[@]} ]; do
		if [ "${CI_SERVER_HOSTNAME[$l_count]}" = "$l_hostname" ]; then
			_SERVER_DETAILS[0]=${CI_SERVER_HOSTNAME[$l_count]}
			_SERVER_DETAILS[1]=${CI_SERVER_IP[$l_count]}
			_SERVER_DETAILS[2]=${CI_SERVER_PXE_MAC_ADDR[$l_count]}
			_SERVER_DETAILS[3]=${CI_SERVER_ARCH[$l_count]}
			_SERVER_DETAILS[4]=${CI_SERVER_ILO_IP[$l_count]}
			_SERVER_DETAILS[5]=${CI_SERVER_VENDOR[$l_count]}
			_SERVER_DETAILS[6]=${CI_SERVER_INST_TYPE[$l_count]}
			_SERVER_DETAILS[7]=${CI_SERVER_CONFIG[$l_count]}
			_SERVER_DETAILS[8]=${CI_SERVER_ROOTPW[$l_count]}
			_SERVER_DETAILS[9]=${CI_SERVER_HARNESS_HOST[$l_count]}
			_SERVER_DETAILS[10]=${CI_SERVER_IPV6[$l_count]}
			_SERVER_DETAILS[11]=${CI_SERVER_BOOT_DEVICE[$l_count]}
			_SERVER_DETAILS[12]=${CI_SERVER_VMWARE_HOST[$l_count]}
			_SERVER_DETAILS[13]=${CI_SERVER_BUIP[$l_count]}
			_SERVER_DETAILS[14]=${CI_SERVER_NETMASK[$l_count]}
			_SERVER_DETAILS[15]=${CI_SERVER_ILO_ROOTPW[$l_count]}
			return 0
			
		fi
		let l_count+=1
	done
	return 1
	
}

###############################################
# X86 Upgrade sub-functions
###############################################
xUG_setupUG ()
{	
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	ugadmin1=$CI_ADMIN1_HOSTNAME  	#left in just in case this is used somewhere else
	ugadmin2=$CI_ADMIN2_HOSTNAME	#left in just in case this is used somewhere else

	# Check mirrors 1st:
	checkMirrors ${CI_ADMIN1_HOSTNAME} || { 
		error "Mirrors on ${CI_ADMIN1_HOSTNAME} NOK" "admin1 mirror issue"
		return 1 
	}
	checkMirrors ${CI_ADMIN2_HOSTNAME} || { 
		error "Mirrors on ${CI_ADMIN2_HOSTNAME} NOK" "admin2 mirror issue"
		return 1 
	}
    

}

xUG_rollBack ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
#RB rollback start?
		$EXPECT $AT_LIB/exp_files/check_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} 
		ret=$? 

		if [[ "$ret" == "2"  || "$ret" == "4" || "$ret" == "5" ]];then
			#rejump admin2
           		relbase=O$(echo "$CI_BASE" | $SED 's/\./_/;s/\..*//')

			message "Checking to see if ADMIN2 was cutover"
			resadmin1=$($EXPECT $AT_LIB/exp_files/get_backup_ip.exp  ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME})

			if [[ "$?" != "0" ]];then
				error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
				rb=NO
				return 1
			fi

			BUIP1=$(echo $resadmin1 | $SED 's/.*;//')
			state_a1=$(echo $resadmin1 |$SED 's/;.*//')
			resadmin2=$($EXPECT $AT_LIB/exp_files/get_backup_ip.exp  ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME})

			if [[ "$?" != "0" ]];then
				error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
				rb=NO
				return 1
			fi

			echo "$resadmin2"
			BUIP2=$(echo $resadmin2 | $SED 's/.*;//')
			state_a2=$(echo $resadmin2 |$SED 's/;.*//')

			if [[ "$state_a2" == "LIVE" && "$BUIP1" != "" && "$BUIP2" != "" && "$rb" != "NO" ]];then
				message "Starting: Admin 2 cutover rollback"
				$EXPECT $AT_LIB/exp_files/rollback_upgraded_live_node.exp $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW

				if [[ "$?" != "0" ]];then
					error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
					return 1
				fi

				$EXPECT $AT_LIB/exp_files/rollback_cutover_upgraded_node.exp $BUIP1 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW

				if [[ "$?" != "0" ]];then
					error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
					return 1
				fi

				message "Finished: Admin 2 cutover rollback"

			elif [[ "$state_a1" == "LIVE" ]];then
				message "Admin 2 Cutover rollback not needed, Admin 1 is LIVE"
			else
				error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
				return 1
			fi

			DDCrb=NO
			NMSrb=NO
 			
			if [[ "$relbase" == "O12_0" ]];then
				DDCrb=YES
			fi
 			
			if [[ "$relbase" == "O11_3" ]];then
				DDCrb=YES
				NMSrb=YES
			fi
			
			$EXPECT $AT_LIB/exp_files/rollback_admin2_part1.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} ${DDCrb} ${NMSrb} 
			ret=$?
            
			if [[ "$ret" != "0" ]];then
				error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 check"
				echo "problem with admin2 but continue anyway"
			fi

			$EXPECT $AT_LIB/exp_files/rollback_admin2_part2.exp ${CI_ADMIN1_HOSTNAME} 	
			X86II_add_mws_admin2_dhcp_client || return 1
			X86II_admin2_jump || return 1
			message "Admin 2 jumped"
			$SLEEP 1800
			$EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN2_HOSTNAME} NO 	
			ret=$?

			if [[ "$ret" != "0" ]];then
				error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 BMR"
				return 1
			fi

 			$EXPECT $AT_LIB/exp_files/check_mirrors.exp ${CI_ADMIN1_HOSTNAME}
			ret=$?

			if [[ "$ret" != "3" ]];then
				echo "in Not insync, proceed with sync"
				$EXPECT $AT_LIB/exp_files/sync_admin1.exp ${CI_ADMIN1_HOSTNAME} 	
			fi

			$EXPECT $AT_LIB/exp_files/re_add_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} 	
			ret=$?
            
            		if [[ "$ret" != "0" ]];then
               			 error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Add Admin2 back to cluster"
				return 1
           	 	fi

			sleep 3600	
			$EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} 
			ret=$?

			if [[ "$ret" != "0" ]];then
               			 error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Add Admin2 back to cluster"
				return 1
			fi
			
			$EXPECT $AT_LIB/exp_files/dmr_admin2.exp ${CI_ADMIN2_HOSTNAME} 	
		fi
#RB rollback stop?
}

xUG_rollBack_new ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
#RB rollback start?
	get_server_details $CI_ADMIN1_HOSTNAME || {
		error "Failed to get \"$CI_ADMIN1_HOSTNAME\" server details" "CI config issue"
		return 1
	}
	BUIP1=${_SERVER_DETAILS[13]}
	get_server_details $CI_ADMIN2_HOSTNAME || {
		error "Failed to get \"$CI_ADMIN2_HOSTNAME\" server details" "CI config issue"
		return 1
	}
	BUIP2=${_SERVER_DETAILS[13]}
	if [[ -z "$BUIP1" || -z "$BUIP2" ]]; then
		error "Failed to get admin1 or admin2 backup IP" "CI config issue"
		return 1
	fi
         $EXPECT $AT_LIB/exp_files/check_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
         ret=$?
            
         if [[ "$ret" == "2"  || "$ret" == "4" || "$ret" == "5" ]];then
            ##rejump admin2
            relbase=O$(echo "$CI_BASE" | sed 's/\./_/;s/\..*//')
                echo "ret is $ret, cutover is set to $CI_CUTOVER_COMPLETED"
		if [ "$CI_CUTOVER_COMPLETED" == "YES" ]
		then
                        xUG_offline_peer_mcs ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME} RB

                        if [[ "$BUIP1" != "" && "$BUIP2" != "" ]];then
                                message "Starting: Admin 2 cutover rollback"
                                $EXPECT $AT_LIB/exp_files/rollback_upgraded_live_node.exp $BUIP2 ${CI_MWS_HOSTNAME} ${CI_MWS_ROOTPW}

                                if [[ "$?" != "0" ]];then
                                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
					return 1
                                fi

                                $EXPECT $AT_LIB/exp_files/rollback_cutover_upgraded_node.exp $BUIP1 ${CI_MWS_HOSTNAME} ${CI_MWS_ROOTPW}

                                if [[ "$?" != "0" ]];then
                                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
					return 1
                                fi
#                                #xUG_online_peer_mcs RB
                         xUG_online_peer_mcs ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME} RB     

                                message "Finished: Admin 2 cutover rollback"

                        else
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 Rollback"
				return 1
                        fi
		fi
                        DDCrb=NO
                        NMSrb=NO

			if [[ "$relbase" == "O12_0" ]];then
                                DDCrb=YES
                        fi

                        if [[ "$relbase" == "O11_3" ]];then
                                DDCrb=YES
                                NMSrb=YES
                        fi

                        $EXPECT $AT_LIB/exp_files/rollback_admin2_part1_3pp.exp ${CI_MWS_HOSTNAME} \
${CI_MWS_ROOTPW} ${BUIP2} ${CI_ADMIN2_HOSTNAME} ${DDCrb} ${NMSrb}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 check"
                                echo "problem with admin2 but continue anyway"
				return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/rollback_admin2_part2_3pp.exp \
${CI_ADMIN1_HOSTNAME} ${CI_MWS_HOSTNAME} ${CI_MWS_ROOTPW} ${BUIP1}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Re-synchronize Disks"
				return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/check_mirrors_RB.exp ${CI_ADMIN1_HOSTNAME}
                        ret=$?

                        if [[ "$ret" != "3" ]];then
                                echo "${CI_ADMIN1_HOSTNAME} mirrors are  Not insync, proceed with sync"
                                # eolikil 23/06/14 changed to BUIP1 
                                $EXPECT $AT_LIB/exp_files/sync_admin1.exp ${BUIP1}  
                                if [[ "$?" != "0" ]];then
                                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Re-synchronize Disk completion"
					return 1
                                fi
                        fi

                        X86II_add_mws_admin2_dhcp_client RB   || return 1
                        X86II_admin2_jump RB  || return 1

                        message "Admin 2 jumped"
                        $SLEEP 300
                        $EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN2_HOSTNAME} NO
                        ret=$?

                        if [[ "$ret" != "0" ]];then
                                error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 BMR"
				return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/re_add_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
                        ret=$?

                        if [[ "$ret" != "0" ]];then
                                 error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Add Admin2 back to cluster"
				return 1
                        fi

                        sleep 3600
                        $EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
                        ret=$?

                        if [[ "$ret" != "0" ]];then
                                 error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Add Admin2 back to cluster"
				return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/dmr_admin2.exp ${CI_ADMIN2_HOSTNAME}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                 error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Adding Root Disk to newly added node"
				return 1
                        fi
        fi
#RB rollback stop?
}

xUG_checkCluster ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	message "Starting: Admin1 Check"
 	$EXPECT $AT_LIB/exp_files/server_check.exp ${CI_ADMIN1_HOSTNAME}
	ret=$?
        
    if [[ "$ret" != "0" ]];then
		error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin1 check"
		return 1
    fi
		
	message "Finished: Admin1 Check"
	message "Starting: Admin2 Check"
 	$EXPECT $AT_LIB/exp_files/server_check.exp ${CI_ADMIN2_HOSTNAME}
	ret=$?
    
	if [[ "$ret" != "0" ]];then
        	error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 check"
		return 1
    	fi
		
	message "Finished: Admin2 Check"

	$EXPECT $AT_LIB/exp_files/check_admin1.exp ${CI_ADMIN1_HOSTNAME} 	
	ret=$?
		
	if [[ "$ret" != "0" ]];then
    		error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin1 check"
		return 1
	fi
}

xUG_copySentinel ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	$EXPECT $AT_LIB/exp_files/get_sentinel.exp ${CI_ADMIN1_HOSTNAME} ${CI_RELEASE} || { local _rt=$?; err_msg "Sentinel license copy failed" $LINENO $FUNCNAME; return ${_rt}; }
}

xUG_installUSCK ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	echo -e "\n\t\t<<<Updating ${CI_ADMIN1_HOSTNAME}...>>>\n"
	$EXPECT $AT_LIB/exp_files/install_usck_and_wranmom.exp ${CI_ADMIN1_HOSTNAME} $CI_MWS_IP:/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}_UG || { local _rt=$?; err_msg "Install USCK pkg to ${CI_ADMIN1_HOSTNAME} failed." $LINENO $FUNCNAME; return ${_rt}; }
	echo -e "\n\t\t<<<Updating ${CI_ADMIN2_HOSTNAME}...>>>\n"
	$EXPECT $AT_LIB/exp_files/install_usck_and_wranmom.exp ${CI_ADMIN2_HOSTNAME} $CI_MWS_IP:/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}_UG || { local _rt=$?; err_msg "Install USCK pkg to ${CI_ADMIN2_HOSTNAME} failed." $LINENO $FUNCNAME; return ${_rt}; }
}

xUG_preChecks1 ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	
	# Run the 1st scripted check and load output to a variable for processing after:
	_expOut=`$EXPECT $AT_LIB/exp_files/pre_check1_PreSysUpgrade.exp ${CI_ADMIN1_HOSTNAME} $CI_MWS_IP:/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}_UG || { _rt=$?; err_msg "Upgrade Prechecks1 failed." $LINENO $FUNCNAME $_rt; return ${_rt}; }` ; _lineNo=$LINENO
	
	# below code is to reprocess the error message (if generated) by the expect command as the 
	# return code and error message is sent to the $_expOut variable instead of the shell and we 
	# need the return code to asses if the command was OK.
	# Also processing the other parts of the error message so it can be reconstructed and displayed.
	_hasErrors=`echo "${_expOut}" |grep "ERROR:.*FUNCTION:.*LINE:"`
	_return=`echo "${_hasErrors}" | awk -F"CODE:" '{print $2}'`
	_message=`echo "${_hasErrors}" | awk -F"ERROR:" '{print $2}'|awk -F"FUNCTION:" '{print $1}' | $SED 's/^[ \t]*//;s/[ \t]*$//'`
	#_lineNo=`echo "${_hasErrors}" | awk -F"LINE:" '{print $2}'|awk -F"IN:" '{print $1}'`
	
	if [[ ${_return} -gt 0 ]]; then 
		echo "${_expOut}"
		err_msg "${_message}" $LINENO $FUNCNAME ${_return}
		return ${_return}
	fi
		
	
	# Now process the output of the expect command to look for possible issues
	_log1=`echo "${_expOut}" | grep log |tail -1 |awk '{print $NF}'`
	if [[ -z ${_log1} ]]; then
		err_msg "Pre Sys Upgrade checks failed to create log file" $LINENO $FUNCNAME ${_return} 
		return 1
	fi
	
	_errors=`echo "${_expOut}" | grep "NOK" | egrep -v 'MCs|This warning can be ignored|During normal runtime, Sybase1 should be on the other admin server|/var/opt/ericsson/nms_umts_cms_nead_seg/neadStatus.log.yin'`
	
	
	if [[ -n ${_errors} ]]; then
	# add processing on $_errors to check if they can be ignored with a warning?
		_err_count=`echo "${_errors}" |grep -c NOK`	
		_err_list=`echo "${_errors}" |grep NOK`
		err_msg "$_err_count checks failed when running pre_check1_PreSysUpgrade.exp Check $_log1 on $CI_ADMIN1_HOSTNAME for details" $LINENO $FUNCNAME ${_return}
		echo -e "\n\nFull list of NOK checks:\n=========================\n$_err_list\n"
		#echo "$_expOut"
		return 1
	else echo "Preupgrade check: $AT_LIB/exp_files/pre_check1_PreSysUpgrade.exp on ${CI_ADMIN1_HOSTNAME} completed OK"
	
	fi
	
	
	#$BANNER break  # only for debugging
	
	
	# Run the 2nd scripted check and load output to a variable for processing after:
	_expOut=`$EXPECT $AT_LIB/exp_files/pre_check1_ne.exp ${CI_ADMIN1_HOSTNAME} $CI_MWS_IP:/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}_UG || { export _rt=$?; err_msg "Upgrade Prechecks1 failed." $LINENO $FUNCNAME $_rt; return ${_rt}; }` ; _lineNo=$LINENO
	
	# below code is to reprocess the error message (if generated) by the expect command 
	# as the return code and error message is sent to the $_expOut variable instead of the shell
	# and we need the return code to asses if the command was OK.
	# Also processing the other parts of the error message so it can be reconstructed and displayed.
	_hasErrors=`echo "${_expOut}" |grep "ERROR:.*FUNCTION:.*LINE:"`
	_return=`echo "${_hasErrors}" | awk -F"CODE:" '{print $2}'`
	_message=`echo "${_hasErrors}" | awk -F"ERROR:" '{print $2}'|awk -F"FUNCTION:" '{print $1}' | $SED 's/^[ \t]*//;s/[ \t]*$//'`
	#_line=`echo "${_hasErrors}" | awk -F"LINE:" '{print $2}'|awk -F"in:" '{print $1}'`
	
	[[ ${_return} -gt 0 ]] && { err_msg "${_message}" ${_lineNo} $FUNCNAME ${_return} ; return ${_return} ; }
	
	
	# Now process the output of the expect command to look for possible issues
		# will need to do some failed tests to know what output to look for.
	_log1=`echo "${_expOut}" | grep "Logs have been saved to" |awk '{print $NF}'`
	_log2=`echo "${_expOut}" | grep "Check log file" |awk '{print $NF}'`
	_neState=`echo "${_expOut}" | grep "OK" |grep "database" |awk '{print $NF}' | tr -cd '[:alpha:]'`
	
	if [ "${_neState}" == "NOK" ]; then
		err_msg "Unsuppoted NEs exist. Check ${_log2} on ${CI_ADMIN1_HOSTNAME} for details." $LINENO $FUNCNAME
		return 1
	
	elif [ "${_neState}" != "OK" ]; then
		err_msg "Something went wrong. NE status not set right.[${_neState/$'\n'/}]  Check ${_log1} on ${CI_ADMIN1_HOSTNAME}" $LINENO $FUNCNAME
		echo "${_expOut}"
		#return 1     -not sure if the UG should continue
		
	else echo "Preupgrade check: $AT_LIB/exp_files/pre_check1_ne.exp on ${CI_ADMIN1_HOSTNAME} completed OK"
		
	fi
	
	
	echo "=================
	Checking variables:
====================
log1 $_log1
log2 $_log2
NE state: $_neState
"
echo "preupgrade checks completed successfully"	
return 0	
}

xUG_splitCluster () 
{
	local l_upgnode
	local l_livenode
	get_server_details $CI_ADMIN1_HOSTNAME || {
		error "Failed to get \"$CI_ADMIN1_HOSTNAME\" server details" "CI config issue"
		return 1
	}
	$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${_SERVER_DETAILS[1]} /opt/VRTS/bin/hagrp -state Oss -sys ${CI_ADMIN1_HOSTNAME}" ${_SERVER_DETAILS[8]} | grep "ONLINE" > /dev/null 
	if [ $? -eq 0 ]; then
		l_livenode=$CI_ADMIN1_HOSTNAME
		l_upgnode=$CI_ADMIN2_HOSTNAME
	else
		l_livenode=$CI_ADMIN2_HOSTNAME
		l_upgnode=$CI_ADMIN1_HOSTNAME
	fi
		
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
        $EXPECT $AT_LIB/exp_files/UG_split_cluster.exp ${l_livenode}
        if [[ "$?" != "0" ]];then
                error "Server: ${l_livenode} Install Type: ${CI_TYPE} Error at: " "Split cluster"
		return 1
        fi

        $SLEEP 600
        $EXPECT $AT_LIB/exp_files/check_ha_admin2.exp ${l_livenode} ${l_upgnode}
        if [[ "$?" != "0" ]];then
                echo "*WARNING* Server: ${l_upgnode} Install Type: ${CI_TYPE}" 
		echo "*WARNING* Split Cluster: Oss did not come ONLINE on ${l_upgnode}"
        fi

        return 0
}

xUG_solLUG_omUG()
{
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	#RB Sol LUG start

	message "Starting: Solaris Live Upgrade" 
        mwsserver=/net/$CI_MWS_HOSTNAME
        MWSLOC=/export/jumpstart/teams/$CI_TEAM
        servertype=sol_x86.loc
        imageloc=Solaris_10/Product/SUNWsolnm/reloc/etc/release
        MWSOM=/export/SW_LOCATION/OM_MEDIA
	# Use bkupBaseIPP from preinirator file to determine  MWS backup IP to use
	bip=$(echo ${bkupBaseIPP} |awk -F. '{print $2}')
	echo  ${bip} ${CI_MWS_BIP}

        mwssolaris=$( cat ${mwsserver}/${MWSLOC}/OSSRC_${CI_RELEASE}/${CI_SHIPMENT_SRC}/${servertype} )
        mwsom="${MWSOM}/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}/om"
        check="NO"

	UG_get_new_boot_device ${CI_ADMIN1_HOSTNAME} || {
		error "Failed to determine new boot device to be used for live upgrade"
		return 1
	}

	echo "Checking to see is Live Upgrade required"
        echo "Running ::: $EXPECT $AT_LIB/exp_files/solaris_liveupgrade.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} ${mwsom} ${mwssolaris} \"${check}\" ${CI_MWS_BIP} $NEW_BOOT_DEVICE"
        $EXPECT $AT_LIB/exp_files/solaris_liveupgrade.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} ${mwsom} ${mwssolaris} "${check}" ${CI_MWS_BIP} $NEW_BOOT_DEVICE
	ret=$?
	if [[ "$ret" == "1" ]];then
           	error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Liveupgrade Unsuccessful"
		return 1
       	fi
	if [[ "$ret" == "0" ]];then
		message "Finished: Solaris Live Upgrade" 
		echo "Going to sleep for 30 minutes to allow the Solaris Upgrade server to reboot"
       		$SLEEP 1800
        fi
	if [[ "$ret" == "2" ]];then
      		message "Solaris Liveupgrade not required"
		message "Finished: Solaris Live Upgrade" 
        fi

	$EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
        ret=$?
	if [[ "$ret" != "0" ]];then
        	error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "liveupgrade: Not possible to ssh to ${CI_ADMIN2_HOSTNAME}"
		return 1
        fi



	message "Starting: HA check Admin2"
	$EXPECT $AT_LIB/exp_files/check_ha_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
	if [[ "$?" != "0" ]];then
        	error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Liveupgrade: Oss not ONLINE on ${CI_ADMIN2_HOSTNAME}"
		return 1
        fi
	message "Finished: HA check Admin2"


	message "Starting: OM Liveupgrade"
        $EXPECT $AT_LIB/exp_files/solaris_liveupgrade_OM.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} ${mwsom} ${mwssolaris} "${check}" ${CI_MWS_BIP}
	if [[ "$?" != "0" ]];then
        	error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Liveupgrade: OM Liveupgrade"
		return 1
        fi
	message "Finished: OM Liveupgrade"

	#RB Sol LUG stop
}

xUG_preChecks2()
{
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	message "Starting: Sybase Health Check"
	$EXPECT $AT_LIB/exp_files/sybase_check.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
	message "Finished: Sybase Health Check"

        message "Starting: Pre-checks on ${CI_ADMIN2_HOSTNAME}"
	$EXPECT $AT_LIB/exp_files/pre_checks2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} || { local _rt=$?; err_msg "Pre-checks on ${CI_ADMIN2_HOSTNAME} failed" $LINENO $FUNCNAME; return ${_rt}; }
        message "Finished: Pre-checks on ${CI_ADMIN2_HOSTNAME}"


}


xUG_EU_preChecks2 ()
{
        message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
        message "Starting: Sybase Health Check"
        $EXPECT $AT_LIB/exp_files/sybase_check.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
        message "Finished: Sybase Health Check"

        message "Starting: Pre-checks on ${CI_ADMIN2_HOSTNAME}"
        $EXPECT $AT_LIB/exp_files/pre_check2_eu.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} || { local _rt=$?; err_msg "Pre-checks on ${CI_ADMIN2_HOSTNAME} failed" $LINENO $FUNCNAME; return ${_rt}; }
        message "Finished: Pre-checks on ${CI_ADMIN2_HOSTNAME}"


}




xUG_doUG ()
{
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
	message "Starting: Base Software Upgrade" 
        bip=$(echo ${bkupBaseIPP} |awk -F. '{print $2}')
	$EXPECT $AT_LIB/exp_files/upgrade_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} ${CI_RELEASE} ${CI_SHIPMENT} ${CI_MWS_BIP}
   	ret1=$?
        if [[ "$ret1" != "0" ]];then
        	if [ -f $LOGDIR/${INSTALL} ]; then
               		echo "<html> <body>"  > $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
               	 	cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
                	echo "</body></html>"  >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
            	fi

		installfinish=`date +'%a %b %e %Y %T'`

           	 error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Install"
		return 1
        fi

	installfinish=`date +'%a %b %e %Y %T'`
        $SLEEP 2400
}


xUG_preCutoverChecks ()
{
        message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
        message "Starting: Sybase Health Check"
        $EXPECT $AT_LIB/exp_files/sybase_check.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
        message "Finished: Sybase Health Check"

        # eolikil 10/11/14 commented out no longer needed 
        #message "Starting check on HA group Ossfs "
        #$EXPECT $AT_LIB/exp_files/offline_2nd_storage_nic.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
        #$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME}.athtem.eei.ericsson.se /var/tmp/platform_taf/harness/lib/exp_files/offline_2nd_storage_nic.bsh" shroot 
        #if [ $? -ne 0 ]; then
        #        echo "HA group Ossfs on ${CI_ADMIN2_HOSTNAME} may have a problem"
        #fi
        #message "Finished: check on HA group Ossfs"

        message "Starting: Post system upgrade, Pre-cutover checks on ${CI_ADMIN2_HOSTNAME}"
        #$EXPECT $AT_LIB/exp_files/pre_cutover_checks.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} || { local _rt=$?; err_msg "Pre-cutover checks on ${CI_ADMIN2_HOSTNAME} failed" $LINENO $FUNCNAME; return ${_rt}; }
        # Run the 1st scripted check and load output to a variable for processing after:
        _expOut=`$EXPECT $AT_LIB/exp_files/pre_cutover_checks.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} || { _rt=$?; err_msg "Upgrade Post-checks failed." $LINENO $FUNCNAME $_rt; return ${_rt}; }` ; _lineNo=$LINENO

        # below code is to reprocess the error message (if generated) by the expect command as the
        # return code and error message is sent to the $_expOut variable instead of the shell and we
        # need the return code to asses if the command was OK.
        # Also processing the other parts of the error message so it can be reconstructed and displayed.
        _hasErrors=`echo "${_expOut}" |grep "ERROR:.*FUNCTION:.*LINE:"`
        _return=`echo "${_hasErrors}" | awk -F"CODE:" '{print $2}'`
        _message=`echo "${_hasErrors}" | awk -F"ERROR:" '{print $2}'|awk -F"FUNCTION:" '{print $1}' | $SED 's/^[ \t]*//;s/[ \t]*$//'`
        #_lineNo=`echo "${_hasErrors}" | awk -F"LINE:" '{print $2}'|awk -F"IN:" '{print $1}'`

        if [[ ${_return} -gt 0 ]]; then
                echo "${_expOut}"
                err_msg "${_message}" $LINENO $FUNCNAME ${_return}
                return ${_return}
        fi


        # Now process the output of the expect command to look for possible issues
        _log1=`echo "${_expOut}" | grep log |tail -1 |awk '{print $NF}'`
        if [[ -z ${_log1} ]]; then
                err_msg "Pre Sys Upgrade checks failed to create log file" $LINENO $FUNCNAME ${_return}
                return 1
        fi

        _errors=`echo "${_expOut}" | grep "NOK" | egrep -v 'MCs|This warning can be ignored|During normal runtime, Sybase1 should be on the other admin server'`


        if [[ -n ${_errors} ]]; then
        # add processing on $_errors to check if they can be ignored with a warning?
                _err_count=`echo "${_errors}" |grep -c NOK`
                _err_list=`echo "${_errors}" |grep NOK`
                err_msg "$_err_count checks failed when running pre_cutover_checks.exp Check $_log1 on $CI_ADMIN2_HOSTNAME for details" $LINENO $FUNCNAME ${_return}
                echo -e "\n\nFull list of NOK checks:\n=========================\n$_err_list\n"
                #echo "$_expOut"
                return 1
        else echo "Post-upgrade check: $AT_LIB/exp_files/pre_cutover_checks.exp on ${CI_ADMIN2_HOSTNAME} completed OK"

        fi

        #$BANNER break  # only for debugging

        message "Finished: Pre-cutover checks on ${CI_ADMIN2_HOSTNAME}"

}


xUG_cutover ()
{	
#RB prepare for cutover
		message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
		message "Starting: Check for Cutover"
		resadmin1=$($EXPECT $AT_LIB/exp_files/get_backup_ip.exp  ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME})
		if [[ "$?" != "0" ]];then
			error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - Get backup IP ${CI_ADMIN1_HOSTNAME}"
			return 1
		fi
		BUIP1=$(echo $resadmin1 | $SED 's/.*;//')
		state_a1=$(echo $resadmin1 |$SED 's/;.*//')
		resadmin2=$($EXPECT $AT_LIB/exp_files/get_backup_ip.exp  ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME})
		if [[ "$?" != "0" ]];then
			error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - Get backup IP ${CI_ADMIN2_HOSTNAME}"
			return 1
		fi
		BUIP2=$(echo $resadmin2 | $SED 's/.*;//')
		state_a2=$(echo $resadmin2 |$SED 's/;.*//')
#RB do cutover
		if [[ "$state_a1" == "LIVE" && "$BUIP1" != "" && "$BUIP2" != "" ]];then
			message "Starting: Cutover"
			$EXPECT $AT_LIB/exp_files/check_ha_rollback_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
               		if [[ "$?" != "0" ]];then
                   		error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - HA Group not ONLINE"
				return 1
               		fi


			$EXPECT $AT_LIB/exp_files/online_mcs.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
               		$EXPECT $AT_LIB/exp_files/cutover_isolate_live_node.exp ${CI_ADMIN1_HOSTNAME} $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
               		if [[ "$?" != "0" ]];then
                   		error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - Isolate Live Node"
				return 1
               		fi

			$EXPECT $AT_LIB/exp_files/cutover_upgrade_node.exp $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
               		if [[ "$?" != "0" ]];then
                   		error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node Failed"
				return 1
               		fi
		else
			error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node"
			return 1
		fi

		message "Finished: Cutover"
#RB cutover finished
}

xUG_singleNode_cutover ()
{
		message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
		get_server_details $CI_ADMIN1_HOSTNAME || {
			error "Failed to get \"$CI_ADMIN1_HOSTNAME\" server details" "CI config issue"
			return 1
		}
		BUIP1=${_SERVER_DETAILS[13]}
#debug
echo "backup1 set to: $BUIP1"
		get_server_details $CI_ADMIN2_HOSTNAME || {
			error "Failed to get \"$CI_ADMIN2_HOSTNAME\" server details" "CI config issue"
			return 1
		}
		BUIP2=${_SERVER_DETAILS[13]}
#debug
echo "backup2 set to: $BUIP2"
#RB do cutover
		if [[ "$BUIP1" != "" && "$BUIP2" != "" ]];then
                        message "Starting: Cutover"
                        $EXPECT $AT_LIB/exp_files/check_ha_rollback_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - HA Group not ONLINE"
                                return 1
                        fi

			$EXPECT $AT_LIB/exp_files/offline_peer_mc.exp ${CI_ADMIN1_HOSTNAME} $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
                        $EXPECT $AT_LIB/exp_files/cutover_isolate_live_node.exp ${CI_ADMIN1_HOSTNAME} $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - Isolate Live Node"
                                return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/cutover_upgrade_node.exp $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node Failed"
                                return 1
                        fi

                else
                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node"
                        return 1
                fi

                message "Finished: Single Node Cutover"
#RB cutover finished
}

xUG_twoNode_cutover ()
{
                message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
		get_server_details $CI_ADMIN1_HOSTNAME || {
			error "Failed to get \"$CI_ADMIN1_HOSTNAME\" server details" "CI config issue"
			return 1
		}
		BUIP1=${_SERVER_DETAILS[13]}
		get_server_details $CI_ADMIN2_HOSTNAME || {
			error "Failed to get \"$CI_ADMIN2_HOSTNAME\" server details" "CI config issue"
			return 1
		}
		BUIP2=${_SERVER_DETAILS[13]}
                
                if [[ -z "$BUIP1" || -z "$BUIP2" ]]; then
                        error "Failed to get admin1 or admin2 backup IP" "CI config issue"
                        return 1
                fi
#RB do cutover
                # eolikil 03/08/  why do we need this if statement?????
		if [ "$CI_CUTOVER_COMPLETED" == "NO" ]
		then
                   xUG_offline_peer_mcs ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} CO

                   if [[ "$BUIP1" != "" && "$BUIP2" != "" ]];then
                        message "Starting: Cutover"
                        $EXPECT $AT_LIB/exp_files/check_ha_rollback_admin2.exp ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME}
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - HA Group not ONLINE"
                                return 1
                        fi

                        #$EXPECT $AT_LIB/exp_files/offline_peer_mc.exp ${CI_ADMIN2_HOSTNAME} $BUIP1 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
                        $EXPECT $AT_LIB/exp_files/cutover_isolate_live_node1.exp ${CI_ADMIN1_HOSTNAME} $BUIP1 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node - Isolate Live Node"
                                return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/cutover_upgrade_node.exp $BUIP2 $CI_MWS_HOSTNAME $CI_MWS_ROOTPW
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node Failed"
                                return 1
                        fi
                   xUG_online_peer_mcs ${CI_ADMIN1_HOSTNAME} ${CI_ADMIN2_HOSTNAME} CO

                else
                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Cutover Upgraded Node"
                        return 1
                   fi
		fi
                        $EXPECT $AT_LIB/exp_files/cutover_admin2_part1.exp ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 checksss"
                                echo "problem with admin2 but continue anyway"
                                return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/cutover_admin2_part2.exp ${CI_ADMIN2_HOSTNAME}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Unblock Disks"
                                return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/check_mirrors.exp ${CI_ADMIN2_HOSTNAME}
                        ret=$?

                        if [[ "$ret" != "3" ]];then
                                echo "in Not insync, proceed with sync"
                                $EXPECT $AT_LIB/exp_files/cutover_sync_admin1.exp ${CI_ADMIN2_HOSTNAME}
                                if [[ "$?" != "0" ]];then
                                        error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Re-synchronize Disk completion"
                                        return 1
                                fi
                        fi

                        X86II_add_mws_admin2_dhcp_client_fullCO CO || return 1
                        X86II_admin2_jump_fullCO CO || return 1

                        message "Admin 1 jumped"
                        $SLEEP 300
                        $EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN1_HOSTNAME} NO
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Admin2 BMR"
                                return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/re_add_admin2.exp ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                 error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Add Admin1 back to cluster"
                                return 1
                        fi

                        sleep 2400
                        $EXPECT $AT_LIB/exp_files/check_alive.exp ${CI_ADMIN2_HOSTNAME} ${CI_ADMIN1_HOSTNAME}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                 error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Add Admin1 back to cluster"
                                return 1
                        fi

                        $EXPECT $AT_LIB/exp_files/dmr_admin2.exp ${CI_ADMIN1_HOSTNAME}
                        ret=$?
                        if [[ "$ret" != "0" ]];then
                                 error "Server: ${CI_ADMIN2_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Adding Root Disk to newly added node"
                                return 1
                        fi



#RB cutover finished
}


xUG_postChecks ()
{
message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
        testdate=`date '+%Y%m%d'`
        testtime=`date '+%H:%M:%S'`
		
		message "Starting: Post Upgrade Check"
        $EXPECT $AT_LIB/exp_files/post_check_ug.exp $CI_ADMIN1_HOSTNAME ${CI_RELEASE} $CI_SHIPMENT_SRC $CI_TEAM UG NA $CI_PLATFORM $testdate $testtime "$installfinish" "$WDATE" "$II_build_complete" $CI_BASE ${CI_ADMIN2_HOSTNAME} ${CI_MWS_HOSTNAME}
		message "Finished: Post Upgrade Check"
}

xUG_updateResults ()
{
	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
		message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
		#RB post results to web        
        	if [ -f $LOGDIR/${INSTALL} ]; then
           		echo "<html> <body>"  > $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
            		cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
            		echo "</body></html>"  >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
        	fi

		if [ -f $TESTLOGDIR/post_check-UG-${CI_RELEASE}-NA-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt ]; then
            		echo "<html> <body>"  > $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
            		echo "<br><h1>Summary</h1>"  >> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
			cat $TESTLOGDIR/post_check-UG-${CI_RELEASE}-NA-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt| grep RESULT | $SED s/"$ RESULTLINE:"//g | $SED s/"RESULTLINE:"//g | $SED 's/$/\<BR\>/'>> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
            		echo "<br><h1>Summary End</h1>"  >> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
            		cat $TESTLOGDIR/post_check-UG-${CI_RELEASE}-NA-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt| $SED 's/$/\<BR\>/'>> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
            		echo "</body></html>"  >> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
        	fi
        fi
}



x86Upgrade_func ()
{


	# code moved to function xUG_setupUG
		xUG_setupUG
	# code moved to function xUG_rollBack
		xUG_rollBack
	# code moved to function xUG_copySentinel
		xUG_checkCluster
	# code moved to function xUG_copySentinel
		xUG_copySentinel
	# code moved to function xUG_installUSCK
		xUG_installUSCK
	# new code split off from previous step
		xUG_preChecks1

#RB remove extra files start		
		message "Starting: cleanup"
        $EXPECT $AT_LIB/exp_files/cleanup.exp ${CI_ADMIN1_HOSTNAME} i386 
        message "Finished: cleanup"
#RB remove extra files stop

    # code moved to function xUG_splitCluster
		xUG_splitCluster
	# code moved to function xUG_solLUG_omUG
		xUG_solLUG_omUG
	# code moved to function xUG_preChecks2
		xUG_preChecks2
	# code moved to function xUG_doUG
		xUG_doUG
	# New code added to function xUG_preCutoverChecks
		xUG_preCutoverChecks
	# code moved to function xUG_cutover
		xUG_cutover
	# code moved to function xUG_postChecks
		xUG_postChecks
	# code moved to function xUG_updateResults
		xUG_updateResults

}

sparcUpgrade_checkMirrors() {
		message "Starting: Check Mirrors"
		$EXPECT $AT_LIB/exp_files/check_mirrors.exp ${CI_ADMIN1_HOSTNAME} 	
		ret=$? 
		if [[ "$ret" == "1" ]];then
			echo "if serious problem don't continue" 
			error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Mirror check"
			return 1
		elif [[ "$ret" == "2" ]];then
			echo "no mirrors defined, do nothing proceed with upgrade" 
		elif [[ "$ret" == "3" ]];then
			message "Starting: Detach Mirror 2"
                        $EXPECT $AT_LIB/exp_files/detach_m2.exp ${CI_ADMIN1_HOSTNAME}
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Mirror 2 detach"
				return 1
                        fi
			message "Finished: Detach Mirror 2"
		elif [[ "$ret" == "4" ]];then
 			if [[ "$CI_BASE" == "11.3.2" && "$CI_PLATFORM" == "sparc" ]];then
				message "Starting: Remove Sparc Volume 11.3.2 only"
                                echo "Running::: $EXPECT $AT_LIB/exp_files/remove_sparc_volume.exp ${CI_ADMIN1_HOSTNAME}"
                                $EXPECT $AT_LIB/exp_files/remove_sparc_volume.exp ${CI_ADMIN1_HOSTNAME}
				message "Finished: Remove Sparc Volume 11.3.2 only"
                        fi
			message "Starting: Boot from Detach"
			echo "Runnning ::: $EXPECT $AT_LIB/exp_files/boot_from_detach.exp ${CI_ADMIN1_HOSTNAME}"
			$EXPECT $AT_LIB/exp_files/boot_from_detach.exp ${CI_ADMIN1_HOSTNAME} 	
			if [[ "$?" != "0" ]];then
				error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Boot from Detach"
				return 1
			fi
			$SLEEP 1800
			message "Finished: Boot form Detach"
			$EXPECT $AT_LIB/exp_files/check_sol_rollback.exp ${CI_ADMIN1_HOSTNAME}
			ret=$?
                	if [[ "$ret" == "3" ]];then
				message "Started: Solaris Rollback"
				echo "Running::: $EXPECT $AT_LIB/exp_files/solaris_rollback.exp ${CI_ADMIN1_HOSTNAME} \"/export/SW_LOCATION/OM_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}/om\""
				$EXPECT $AT_LIB/exp_files/solaris_rollback.exp ${CI_ADMIN1_HOSTNAME} "/export/SW_LOCATION/OM_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}/om" ${CI_MWS_IP} d10
				$SLEEP 3000
				message "Finished: Solaris Rollback"
			fi
			message "Starting: cleanup"
                        $EXPECT $AT_LIB/exp_files/cleanup.exp ${CI_ADMIN1_HOSTNAME} sparc
			message "Finished: cleanup"
			message "Starting: Sync Mirrors"
                        echo "Runnning ::: $EXPECT $AT_LIB/exp_files/sync_sparc.exp ${CI_ADMIN1_HOSTNAME}"
                        $EXPECT $AT_LIB/exp_files/sync_sparc.exp ${CI_ADMIN1_HOSTNAME}         
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Mirror sync"
				return 1
                        fi
			message "Finished: Sync Mirrors"

			message "Started: Server Check"

			echo "Running ::: $EXPECT $AT_LIB/exp_files/check_reboot_finished.exp ${CI_ADMIN1_HOSTNAME}" 	
			$EXPECT $AT_LIB/exp_files/check_reboot_finished.exp ${CI_ADMIN1_HOSTNAME} 
			$EXPECT $AT_LIB/exp_files/online_mcs.exp ${CI_ADMIN1_HOSTNAME} NO 
			message "Finished: Server Check"

		fi
		return 0
	

}


sparc_euUpgrade_checkMirrors() {
                message "Starting: Check Mirrors"
                $EXPECT $AT_LIB/exp_files/check_mirrors.exp ${CI_ADMIN1_HOSTNAME}
                ret=$?
                if [[ "$ret" == "1" ]];then
                        echo "if serious problem don't continue"
                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Mirror check"
                        return 1
                elif [[ "$ret" == "2" ]];then
                        echo "no mirrors defined, do nothing proceed with upgrade"
                elif [[ "$ret" == "3" ]];then
                        echo "in sync, if x86 detach and  proceed with upgrade"
                        if [[ "$CI_PLATFORM" == "i386" ]];then
                        message "Starting: Detach Mirror 2"
                        $EXPECT $AT_LIB/exp_files/detach_m2.exp ${CI_ADMIN1_HOSTNAME}
                                if [[ "$?" != "0" ]];then
                                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Mirror 2 detach"
                                        return 1
                                fi
                        message "Finished: Detach Mirror 2"
                        fi
                elif [[ "$ret" == "4" ]];then
                        if [[ "$CI_BASE" == "11.3.2" && "$CI_PLATFORM" == "sparc" ]];then
                                message "Starting: Remove Sparc Volume 11.3.2 only"
                                echo "Running::: $EXPECT $AT_LIB/exp_files/remove_sparc_volume.exp ${CI_ADMIN1_HOSTNAME}"
                                $EXPECT $AT_LIB/exp_files/remove_sparc_volume.exp ${CI_ADMIN1_HOSTNAME}
                                message "Finished: Remove Sparc Volume 11.3.2 only"
                        fi
                        message "Starting: Boot from Detach"
                        echo "Runnning ::: $EXPECT $AT_LIB/exp_files/boot_from_detach.exp ${CI_ADMIN1_HOSTNAME}"
                        $EXPECT $AT_LIB/exp_files/boot_from_detach.exp ${CI_ADMIN1_HOSTNAME}
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Boot from Detach"
                                return 1
                        fi
                        $SLEEP 1800
                        message "Finished: Boot form Detach"

                        message "Starting: cleanup"
                        $EXPECT $AT_LIB/exp_files/cleanup.exp ${CI_ADMIN1_HOSTNAME} sparc
                        message "Finished: cleanup"

                        message "Starting: Sync Mirrors"
                        echo "Runnning ::: $EXPECT $AT_LIB/exp_files/sync_sparc.exp ${CI_ADMIN1_HOSTNAME}"
                        $EXPECT $AT_LIB/exp_files/sync_sparc.exp ${CI_ADMIN1_HOSTNAME}
                        if [[ "$?" != "0" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Mirror sync"
                                return 1
                        fi
                        message "Finished: Sync Mirrors"

                        message "Started: Server Check"
                        echo "Running ::: $EXPECT $AT_LIB/exp_files/check_reboot_finished.exp ${CI_ADMIN1_HOSTNAME}"
                        $EXPECT $AT_LIB/exp_files/check_reboot_finished.exp ${CI_ADMIN1_HOSTNAME}
                        $EXPECT $AT_LIB/exp_files/online_mcs.exp ${CI_ADMIN1_HOSTNAME} NO
                        message "Finished: Server Check"

                fi
                return 0


}


#
# Function to perform Solaris Live Upgrade if Required
#

sparcUpgrade_SLU() {
  		$EXPECT $AT_LIB/exp_files/get_sentinel.exp ${CI_ADMIN1_HOSTNAME} ${CI_RELEASE} || {
			error "Failed to set sentintel license" "sentinel license problem"
			return 1
		}

  		$EXPECT $AT_LIB/exp_files/system_upgrade_utils.exp ${CI_ADMIN1_HOSTNAME} || {
			error "Failed to get solaris SLU utils" "failed to get SLU kit"
			return 1
		}
		message "Starting: Solaris Live Upgrade"
                mwsserver=/net/$CI_MWS_IP
                MWSLOC=/export/jumpstart/teams/$CI_TEAM
                servertype=sol_sparc.loc
                imageloc=Solaris_10/Product/SUNWsolnm/reloc/etc/release
		MWSOM=/export/SW_LOCATION/OM_MEDIA
                mwssolaris=$( dirname $( cat ${mwsserver}/${MWSLOC}/OSSRC_${CI_RELEASE}/${CI_SHIPMENT_SRC}/${servertype} ) )
                mwsom="${MWSOM}/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}/om"

  		#changed so liveupgrade will allways be run
                check="NO"
		UG_get_new_boot_device ${CI_ADMIN1_HOSTNAME} || {
			error "Failed to determine new boot device to be used for live upgrade"
			return 1
		}
                echo "Checking to see is Live Upgrade required"
                $EXPECT $AT_LIB/exp_files/solaris_liveupgrade.exp ${CI_ADMIN1_HOSTNAME} NO ${mwsom} ${mwssolaris} "${check}" ${CI_MWS_IP} $NEW_BOOT_DEVICE
			ret=$?
                        if [[ "$ret" == "1" ]];then
                                error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Liveupgrade"
				return 1
                        fi
                        if [[ "$ret" == "0" ]];then
				message "Finished: Solaris Live Upgrade"
                                echo "Going to sleep for 30 minutes to allow the Solaris Upgrade server to reboot"
                                $SLEEP 1800
                        fi
                        if [[ "$ret" == "2" ]];then
                                message "Solaris Liveupgrade not required"
				message "Finished: Solaris Live Upgrade"
                        fi

		message "Starting: Versant Workaround"
                $EXPECT $AT_LIB/exp_files/versant_wo.exp  ${CI_ADMIN1_HOSTNAME} NO NO || {
			error "Failed to apply versant workaround" "versant w/a failure"
			return 1
		}
                message "Finished: Versant Workaround"
		message "Starting: OM Liveupgrade"
                $EXPECT $AT_LIB/exp_files/solaris_liveupgrade_OM.exp ${CI_ADMIN1_HOSTNAME} NO ${mwsom} ${mwssolaris} "${check}" ${CI_MWS_IP} || {
                        error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Liveupgrade"
			return 1
                }
		message "Finished: OM Liveupgrade"


}


sparcUpgrade_func ()
{
		message "Starting: Base Software Upgrade"
		get_server_details $CI_ADMIN1_HOSTNAME  || {
		 	error "Failed to get \"$server_hostname\" server details" "CI config issue"
			return 1
		}

                $EXPECT $AT_LIB/exp_files/CI_UPGRADE_JUMPIT.exp $CI_RELEASE ${CI_SHIPMENT} ${_SERVER_DETAILS[1]} $CI_TYPE NA $CI_PLATFORM $CI_MWS_IP
                ret1=$?
		message "Finished: Base Software Upgrade"

		if [[ "$ret1" != "0" ]];then
		 	if [ -f $LOGDIR/${INSTALL} ]; then
					echo "<html> <body>"  > $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
                			cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
					echo "</body></html>"  >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
        	 	fi
			installfinish=`date +'%a %b %e %Y %T'`
			error "Server: ${CI_ADMIN1_HOSTNAME} Install Type: ${CI_TYPE} Error at: " "Install"
			return 1
		fi
                $SLEEP 3600
}

sparcUpgrade_postChecks() {
                testdate=`date '+%Y%m%d'`
                testtime=`date '+%H:%M:%S'`
		installfinish=`date +'%a %b %e %Y %T'`
                $EXPECT $AT_LIB/exp_files/post_check_ug.exp $CI_ADMIN1_HOSTNAME $CI_RELEASE $CI_SHIPMENT_SRC $CI_TEAM UG NA $CI_PLATFORM $testdate $testtime "$installfinish" "$WDATE" "$II_build_complete" $CI_BASE NO $CI_MWS_HOSTNAME
                if [ -f $LOGDIR/${INSTALL} ]; then
                   	echo "<html> <body>"  > $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
                        cat $LOGDIR/${INSTALL} | $SED 's/$/\<BR\>/' >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
                        echo "</body></html>"  >> $LOGDIRHTML/installug-$CI_PLATFORM-$WDATE.html
                fi
                if [ -f $TESTLOGDIR/post_check-UG-$CI_RELEASE-NA-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt ]; then
                        echo "<html> <body>"  > $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
                        echo "<br><h1>Summary</h1>"  >> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
                        cat $TESTLOGDIR/post_check-UG-$CI_RELEASE-NA-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt| grep RESULT | $SED s/"$ RESULTLINE:"//g | $SED s/"RESULTLINE:"//g | $SED 's/$/\<BR\>/'>> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
                        echo "<br><h1>Summary End</h1>"  >> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
                        cat $TESTLOGDIR/post_check-UG-$CI_RELEASE-NA-$CI_SHIPMENT-NA-$CI_PLATFORM-$testdate-$testtime.txt| $SED 's/$/\<BR\>/'>> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
                        echo "</body></html>"  >> $LOGDIRHTML/testug-$CI_PLATFORM-$WDATE.html
                fi
}

sparcUpgrade_installUSCK ()
{
	message "$(basename $BASH_SOURCE) is Running function: $FUNCNAME"
        echo -e "\n\t\t<<<Updating ${CI_ADMIN1_HOSTNAME}...>>>\n"
        $EXPECT $AT_LIB/exp_files/install_usck_and_wranmom.exp ${CI_ADMIN1_HOSTNAME} $CI_MWS_IP:/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}_UG || { local _rt=$?; err_msg "Install USCK pkg to ${CI_ADMIN1_HOSTNAME} failed." $LINENO $FUNCNAME; return ${_rt}; }
}


# 
# This function gets called as part of the ts_setup() function of an upgrade test suite
#

UG_prep () {
	#copy current manifest to previous manifest for next time
	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
		create_content || return 1
		cp /net/${CI_MWS_HOSTNAME}/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_$CI_RELEASE/$CI_SHIPMENT/ossrc_base_sw/build_manifest_${CI_PLATFORM} /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/build_manifest_${CI_PLATFORM}_II_CI_PREVIOUS
		chmod 777 /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/build_manifest_${CI_PLATFORM}_II_CI_PREVIOUS
		installstart=`date +'%a %b %e %Y %T'`
		echo -ne "$installstart" > /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/ugresults1-${CI_PLATFORM}-$WDATE
	fi


}

# 
# This function gets called as part of the ts_cleanup() function of an upgrade test suite
#

UG_wrapup () {
	echo "Performing post upgrade wrap-up tasks"
	if [ "$CI_UPDATE_OLD_WEBSITE" = TRUE ]; then
		installfinish=`date +'%a %b %e %Y %T'`
		testdate=`date '+%Y%m%d'`
		testtime=`date '+%H:%M:%S'`
		checkformat=$((`cat /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/ugresults1-$CI_PLATFORM-$WDATE|$SED 's/[^@]//g'|wc -m`-1))
		if [[ "$checkformat" != "10" ]];then
            	echo "<TR><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD><TD>error</TD></TR>" >> /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/results
        		else
            	cat /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/ugresults1-$CI_PLATFORM-$WDATE >> /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/results
        	fi
		#rm /net/$CI_MWS_HOSTNAME/export/jumpstart/teams/$CI_TEAM/OSSRC_${CI_RELEASE}/$CI_SHIPMENT_SRC/ugresults1-$CI_PLATFORM-$WDATE
	fi


}

UG_get_new_boot_device() {
	unset NEW_BOOT_DEVICE
	server_hostname=$1
	[ -z "$server_hostname" ] && {
		error "$FUNCNAME: server host arg not specified"
		return 1
	}
	get_server_details $server_hostname || {
		error "Failed to get \"$server_hostname\" server details" "CI config issue"
		return 1
	}
	$EXPECT $AT_BIN/ssh_setup2.sh scp "$AT_LIB/exp_files/get_new_be.bsh root@${_SERVER_DETAILS[1]}:/var/tmp" ${_SERVER_DETAILS[8]} > /dev/null 2>&1 || {
		error "Failed to copy get_new_be.bsh to admin1"
		return 1
	}

	NEW_BOOT_DEVICE=$($EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${_SERVER_DETAILS[1]} /var/tmp/get_new_be.bsh $CI_ADMIN1_HOSTNAME /var/tmp" ${_SERVER_DETAILS[8]} | $SED 's/\r$//' | tail -1 2> /dev/null) || {
		error "Failed to determine root metadevice on $CI_ADMIN1_HOSTNAME"
		return 1
	}
}

#
# Function to create config file for vApp install
#

X86_vApp_prepare_install() {
	local l_etcdir=${AT_ROOT}/build_scripts/infrastructure/etc
	local l_cloud_media_cfg_template=$l_etcdir/oss_cloud_install_media_config.template
	local l_sollocmws=$(cat /net/${CI_MWS_HOSTNAME}/export/jumpstart/teams/$CI_TEAM/OSSRC_$CI_RELEASE/$CI_SHIPMENT_SRC/sol_x86.loc)
	local l_om_media_loc=/export/SW_LOCATION/OM_MEDIA/OSSRC_${CI_OM_RELEASE}/${CI_OM_SHIPMENT}
	local l_ossrc_media_loc=/export/SW_LOCATION/OSSRC_MEDIA/OSSRC_${CI_RELEASE}/${CI_SHIPMENT}
	local l_scriptsrv_cfgdir=/export/scripts/CLOUD/configs/ta_specific/INFRASTRUCTURE
	local l_mws_hostname=$( echo $CI_MWS_HOSTNAME | awk -F. '{ print $1 }' )

	get_script_server || {
		echo "Error - OSS cloud scripting server not specified in env file"
		return 1
	}
	get_vapp_server || {
		echo "Error - vApp/gateway server not specified in env file"
		return 1
	}

	if [ -z "$l_sollocmws" ]; then
		error "Unable to determine x86 media cache location on mws" "media problem"
		return 1
	fi
	
	if [ -z "$l_om_media_loc" ]; then
		error "Unable to determine OM media cache location on mws" "media problem"
		return 1
	fi
	if [ -z "$l_ossrc_media_loc" ]; then
		error "Unable to determine OSSRC media cache location on mws" "media problem"
		return 1
	fi
	if [ -z "$CI_COMINF_MEDIA_LOC" ]; then
		error "Unable to determine COMINF media cache location on mws" "media problem"
		return 1
	fi
	if [ -z "$CI_OMSAS_MEDIA_LOC" ]; then
		error "Unable to determine OMSAS media cache location on mws" "media problem"
		return 1
	fi
	if [ -z "$CI_ENIQS_MEDIA_LOC" ]; then
		error "Unable to determine ENIQ stats media cache location on mws" "media problem"
		return 1
	fi

	for loc in $l_sollocmws $l_om_media_loc $l_ossrc_media_loc $CI_COMINF_MEDIA_LOC $CI_OMSAS_MEDIA_LOC $CI_ENIQS_MEDIA_LOC; do
		if [ ! -d "/net/${CI_MWS_HOSTNAME}/$loc" ]; then
			error "Media location /net/${CI_MWS_HOSTNAME}/$loc not found" "media problem"
			return 1
		fi
	done
	local l_mediaconfigfile=$( basename ${l_cloud_media_cfg_template%.template} ).${G_CLOUD_VAPP}
	sed -e "s,##MWS_HOSTNAME##,$l_mws_hostname,g" -e "s,##COMINF_MEDIA_LOC##,$CI_COMINF_MEDIA_LOC,g" \
		 -e "s,##SOL_MEDIA_LOC##,$l_sollocmws,g" -e "s,##OM_MEDIA_LOC##,$l_om_media_loc,g"  \
		 -e "s,##OSSRC_MEDIA_LOC##,$l_ossrc_media_loc,g" -e "s,##OMSAS_MEDIA_LOC##,$CI_OMSAS_MEDIA_LOC,g"  \
		 -e "s,##ENIQS_MEDIA_LOC##,$CI_ENIQS_MEDIA_LOC,g" \
		$l_cloud_media_cfg_template > /tmp/$l_mediaconfigfile || {
			error "Failed to create media config file for vApp." "vApp config error"
			return 1
	}
	$EXPECT $AT_BIN/ssh_setup2.sh scp "/tmp/$l_mediaconfigfile root@$G_CLOUD_SCRIPT_SERVER_IP:$l_scriptsrv_cfgdir" $G_CLOUD_SCRIPT_SERVER_ROOTPW > /dev/null 2>&1 || {
		error "failed to copy media config file to scripting server $G_CLOUD_SCRIPT_SERVER_IP" "vApp config error"
		return 1
	}
	return 0
}

#
# Function to install vApp
#

X86_vApp_install() {
	local l_cloud_master_script=/export/scripts/CLOUD/bin/master.sh
	local l_etcdir=${AT_ROOT}/build_scripts/infrastructure/etc
	local l_cloud_media_cfg_template=$l_etcdir/oss_cloud_install_media_config.template
	local l_configfile=/export/scripts/CLOUD/configs/templates/oss_box/variables_sfs_full.txt
	local l_scriptsrv_cfgdir=/export/scripts/CLOUD/configs/ta_specific/INFRASTRUCTURE
	local l_rolloutconfigfile=oss_cloud_install_config



	X86_vApp_prepare_install || return 1
	local l_mediaconfigfile=$( basename ${l_cloud_media_cfg_template%.template} ).${G_CLOUD_VAPP}
	local l_logfile=install_infra_${G_CLOUD_VAPP}.log

	$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$G_CLOUD_SCRIPT_SERVER_IP /bin/rm -f /tmp/$l_logfile  < /dev/null > /dev/null  2>&1" $G_CLOUD_SCRIPT_SERVER_ROOTPW
	echo "Starting building of OSS Cloud Private Testbox on $G_CLOUD_VAPP."
	echo "This will take a while...."
	# note when calling harness on remote server we redirect stdout and stdin to files
	# to prevent remote ssh session hanging see http://www.snailbook.com/faq/background-jobs.auto.html
	echo "Using command:" 
	echo "$EXPECT $AT_BIN/ssh_setup2.sh ssh \"root@$G_CLOUD_SCRIPT_SERVER_IP $l_cloud_master_script -c $l_configfile:$l_scriptsrv_cfgdir/$l_rolloutconfigfile:$l_scriptsrv_cfgdir/$l_mediaconfigfile -g $G_CLOUD_VAPP -f rollout_config \""
	$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@$G_CLOUD_SCRIPT_SERVER_IP $l_cloud_master_script -c $l_configfile:$l_scriptsrv_cfgdir/$l_rolloutconfigfile:$l_scriptsrv_cfgdir/$l_mediaconfigfile -g $G_CLOUD_VAPP -f rollout_config < /dev/null > /tmp/$l_logfile 2>&1" $G_CLOUD_SCRIPT_SERVER_ROOTPW 
	retcode=$?
	echo "Return code from vApp installation is $retcode"
	/bin/rm -rf /tmp/$l_logfile > /dev/null 2>&1
	$EXPECT $AT_BIN/ssh_setup2.sh scp "root@$G_CLOUD_SCRIPT_SERVER_IP:/tmp/$l_logfile /tmp"  $G_CLOUD_SCRIPT_SERVER_ROOTPW && 
	cat /tmp/$l_logfile
	if [ $retcode -ne 0 ]; then
		echo "**Error** vApp installation script returned non-zero code \"$retcode\""
		return 1
	fi
	



	return 0
		


}

#
# Check vms within vApp can be contacted
#

X86_vApp_checkvms() {
	echo "Checking VMs within vApp are contactable.."
	local _l_mandatory_server[0]=yes
	local _l_mandatory_server[1]=yes
	local _l_mandatory_server[2]=yes
	local _l_mandatory_server[3]=yes
	local _l_mandatory_server[4]=yes
	local _l_mandatory_server[5]=yes
	local _l_mandatory_server[6]=yes
	local _l_mandatory_server[7]=yes
	local _l_mandatory_server[8]=yes
	local _l_mandatory_server[9]=yes
	local _l_mandatory_server[10]=yes
	local _l_port[0]=2201
	local _l_port[1]=2202
	local _l_port[2]=2203
	local _l_port[3]=2204
	local _l_port[4]=2205
	local _l_port[5]=2206
	local _l_port[6]=2207
	local _l_port[7]=2208
	local _l_port[8]=2209
	local _l_port[9]=2247
	local _l_port[10]=2251
	local _l_port_server[0]=blank
	local _l_port_server[1]=netsim
	local _l_port_server[2]=omsas
	local _l_port_server[3]=omservm
	local _l_port_server[4]=admin
	local _l_port_server[5]=uas
	local _l_port_server[6]=omservs
	local _l_port_server[7]=nedss
	local _l_port_server[8]=ebas
	local _l_port_server[9]=netsim
	local _l_port_server[10]=eniqs
	get_script_server || {
		echo "Error - OSS cloud scripting server not specified in env file"
		return 1
	}
	get_vapp_server || {
		echo "Error - vApp/gateway server not specified in env file"
		return 1
	}

	local l_count=1
        while [ $l_count -lt ${#_l_port_server[@]} ]; do
		echo "Checking vApp VM server ${_l_port_server[$l_count]} is contactable on gateway IP: $G_CLOUD_VAPP_IP port: ${_l_port[$l_count]}"
		$EXPECT $AT_BIN/ssh_setup2.sh ssh "-oPort=${_l_port[$l_count]} root@$G_CLOUD_VAPP_IP exit" shroot > /dev/null 2>&1 || {
			if [ "${_l_mandatory_server[$l_count]}" = yes ]; then
				error "Failed to contact vApp VM server on gateway IP: $G_CLOUD_VAPP_IP port: ${_l_port[$l_count]}" "vApp issue"
				return 1
			else
				echo "Warning - failed to contact vApp VM server on gateway IP: $G_CLOUD_VAPP_IP port: ${_l_port[$l_count]}. May not be issue since this server is not part of all vApp deployments." 
			fi
		}
		let l_count+=1
	done
return 0
}

#
# perform post-install config steps on vApp Vms
#
X86_vApp_post_install_config() {
	local l_ssh_master_natport
	local l_ssh_slave_natport
	local l_configfile=config.ini
	echo "Doing post install steps on vApp"
	
	return 0
}

#
# Get vApp/Gateway server details
#

get_script_server() {
        local l_count=0
        G_CLOUD_SCRIPT_SERVER=""
        G_CLOUD_SCRIPT_SERVER_IP=""
        G_CLOUD_SCRIPT_SERVER_ROOTPW=""
        while [ $l_count -lt ${#CI_SERVER_IP[@]} ]; do
                if [ "${CI_SERVER_CONFIG[$l_count]}" = scripting_server ]; then
                        G_CLOUD_SCRIPT_SERVER=${CI_SERVER_HOSTNAME[$l_count]}
                        G_CLOUD_SCRIPT_SERVER_IP=${CI_SERVER_IP[$l_count]}
                        G_CLOUD_SCRIPT_SERVER_ROOTPW=${CI_SERVER_ROOTPW[$l_count]}
                        break
                fi
                let l_count+=1
        done
        [ -z "$G_CLOUD_SCRIPT_SERVER" ] && return 1
        return 0

}

get_vapp_server() {
        local l_count=0
        G_CLOUD_VAPP_ROOTPW=""
	# G_CLOUD_VAPP and G_CLOUD_VAPP_IP now set in Jenkins
	if [[ -z "$G_CLOUD_VAPP" || -z "$G_CLOUD_VAPP_IP" ]]; then
		echo "Error - required vApp parameters missing. Check Jenkins job config"
		return 1
	fi
        while [ $l_count -lt ${#CI_SERVER_IP[@]} ]; do
                if [ "${CI_SERVER_CONFIG[$l_count]}" = gateway ]; then
                        #G_CLOUD_VAPP=${CI_SERVER_HOSTNAME[$l_count]}
                        #G_CLOUD_VAPP_IP=${CI_SERVER_IP[$l_count]}
                        G_CLOUD_VAPP_ROOTPW=${CI_SERVER_ROOTPW[$l_count]}
                        break
                fi
                let l_count+=1
        done
        [ -z "$G_CLOUD_VAPP" ] && return 1
        return 0

}


#
# get server inst type
#

get_inst_type () {
	CI_INST_TYPE=
	if [ -s /ericsson/config/inst_type ]; then
		CI_INST_TYPE=$( cat /ericsson/config/inst_type )
	elif [ -s /eniq/installation/config/inst_type ]; then
		CI_INST_TYPE=$( cat /eniq/installation/config/inst_type  )
	else
		echo "Error - unable to determine server inst type"
		return 1
	fi
		
}
	

#Function to set the power profile of the blade
set_ilo_power()
{
get_server_details $1
        if [ $? -ne "0" ]; then
                error "Admin1 configuration not found.. Unable to continue Power Profile setup." "CI config issue"
                return 1
        fi
        server_vendor=${_SERVER_DETAILS[5]}
        if [ "$server_vendor" != hp ]; then
                        return 0
        else
                # assume HP hw
                ilo_ip=${_SERVER_DETAILS[4]}
                if [ -z "$ilo_ip" ]; then
                        error "Unable to determine ILO IP of server $1" "CI config issue"
                        return 1
                fi

                $EXPECT $AT_LIB/exp_files/set_ilo_power.exp $1 $ilo_ip | tee -a $LOGDIR/$INSTALL

        	[ ${PIPESTATUS[0]} -ne 0 ] && {
               		 error "Setting of Power Profile of Server failed"
                	 return 1
                }
        fi
        return 0
}

#Function to check the power profile of the blade
check_ilo_power()
{
get_server_details $1
        if [ $? -ne "0" ]; then
                error "Admin1 configuration not found.. Unable to continue Power Profile check." "CI config issue"
                return 1
        fi

	server_vendor=${_SERVER_DETAILS[5]}
        if [ "$server_vendor" != hp ]; then
                        return 0
        else
                # assume HP hw

		 ilo_ip=${_SERVER_DETAILS[4]}
                 if [ -z "$ilo_ip" ]; then
                        error "Unable to determine ILO IP of server $1" "CI config issue"
                        return 1
                fi

		$EXPECT $AT_LIB/exp_files/check_ilo_power.exp $1 $ilo_ip | tee -a $LOGDIR/$INSTALL

		[ ${PIPESTATUS[0]} -ne 0 ] && {
               		 error "Setting of Power Profile of Server failed"
               		 return 1
        	}
fi
return 0
}

x86_cluster_set_ilo_power()
{
get_server_details $CI_ADMIN1_HOSTNAME
get_server_details $CI_ADMIN2_HOSTNAME

for host in $CI_ADMIN1_HOSTNAME $CI_ADMIN2_HOSTNAME; do
set_ilo_power $host
done

}

x86_cluster_check_ilo_power()
{

for host in $CI_ADMIN1_HOSTNAME $CI_ADMIN2_HOSTNAME; do
check_ilo_power $host
done

}
# function called for dmtool bmr restore preparation
# to stop the cluster
# [mv.DI_DMR]
x86_cluster_stop()
{
local_return=0

 if [ -n "$(/bin/pgrep had)" ];
        then
        echo "INFO:: stopping this cluster"
        echo "INFO:: run hastop -all"
        hastop -all
        let _time_now_=${SECONDS}
        let _local_timeout_=$((_time_now_ + 600 ))
        while (( _time_now_ <  _local_timeout_ ));
                do
                /bin/pgrep had 
                if [ $? -ne 1 ]; then
                let _time_now_=${_time_now_}+5
                echo -ne ".\c"
                sleep 5
                else
                echo "INFO:: finished stopping cluster"
                break
                fi
        done
        [[ ${_time_now_} -ge ${_local_timeout_} ]] && local_return=1
 else
        echo "INFO:: cluster already stopped"
 fi

return $local_return

}

#
# DMR testing functions
#


#
# Function to set DMR global variables
#
DMR_set_globals() {
	DMRSNAPOSS1VIPINFILE=dump.snap.oss.1vip
	DMRSNAPSYB1VIPINFILE=dump.snap.syb.1vip
	DMRDETACHOSS1VIPINFILE=dump.detach.oss.1vip
	DMRDETACHSYB1VIPINFILE=dump.detach.syb.1vip
	DMRSNAPOSS2VIPINFILE=dump.snap.oss.2vip
	DMRSNAPSYB2VIPINFILE=dump.snap.syb.2vip
	DMRSNAPALL1VIPINFILE=dump.snap.all.1vip
	DMRDETACHALL1VIPINFILE=dump.detach.all.1vip
	DMRSNAPSYB2VIPINVALID1INFILE=dump.snap.syb.2vip.invalid1
	DMRDETACHSYB1VIPINVALID1INFILE=dump.detach.syb.1vip.invalid1
	DMRDETACHSYB1VIPALLDGSINFILE=dump.detach.syb.1vip.alldgs
	DMRSNAPSYB1VIPALLDGSINFILE=dump.snap.syb.1vip.alldgs
	DMRDETACHOSS1VIPALLDGSINFILE=dump.detach.oss.1vip.alldgs
	DMRSNAPOSS1VIPALLDGSINFILE=dump.snap.oss.1vip.alldgs
	DMRDETACHSYB2VIPALLDGSINFILE=dump.detach.syb.2vip.alldgs
	DMRSNAPSYB2VIPALLDGSINFILE=dump.snap.syb.2vip.alldgs
	DMRDETACHOSS2VIPALLDGSINFILE=dump.detach.oss.2vip.alldgs
	DMRSNAPOSS2VIPALLDGSINFILE=dump.snap.oss.2vip.alldgs
	DMRSNAPOSSALL1VIPALLDGSINFILE=dump.snap.all.1vip.alldgs
	DMRDEFAULTVNXOMBSTAG=NBtmp
	DMRDEFAULTNASOMBSTAG=ombs
	DMR1STHANDSHAKEMESSAGEWAITLENGTH=120
	DMRSCREENLOG=/ericsson/dmr/log/dm_screen.log
	DMRCMDLOG=/ericsson/dmr/log/dm_cmd.log
	DMRBACKUPMETADATADIR=$PWD/metadata
	DMRRESTOREMOUNTPT=/Restore
	DMRRESTOREOSSSYBMETADATA=metadata_oss_syb.tar
	DMRRESTOREOSSMETADATA=metadata_oss.tar
	DMRRESTORESYBMETADATA=metadata_syb.tar
	return 0

}

#Function to install SFS test package
SFS_TS_install_pkg () {
        local l_sfs_ts_pkgfilename=SFSstp.pkg
        local l_sfs_ts_pkgname=${l_sfs_ts_pkgfilename%.pkg}
        local l_sfs_ts_pkg_adm=package.adm
        local l_local_pkg_adm_path=${AT_ROOT}/build_scripts/infrastructure/etc/$l_sfs_ts_pkg_adm

	if [ $CI_ADMIN2_HOSTNAME  != NO ]; then 
        	get_server_details $CI_ADMIN2_HOSTNAME || {
               		 echo "Error - failed to get admin2 server details"
                	return 1
       		 }
	fi
	
        local l_admin2_pass=${_SERVER_DETAILS[8]}


        mkdir -p /tmp/sfs_ts$$ || {
                echo "Error - failed to create temporary mount point"
                return 1
        }
        mount $CI_MWS_IP:/export /tmp/sfs_ts$$ || {
                echo "Error - failed to mount MWS /export fs"
                return 1
        }
        local l_mws_sfs_ts_pkg_path=/tmp/sfs_ts$$/CI/TC/1366/$l_sfs_ts_pkgfilename
        if [ ! -s $l_mws_sfs_ts_pkg_path ]; then
                echo "Error - unable to locate new SFS_TS package  $l_mws_sfs_ts_pkg_path"
                umount /tmp/sfs_ts$$
                /bin/rm -rf /tmp/sfs_ts$$
                return 1
        fi

 echo "** Checking SFS_TS package on $( hostname ) **"
        if /bin/pkginfo | grep -w $l_sfs_ts_pkgname > /dev/null ; then
                existing_version=$( /usr/bin/pkgparam $l_sfs_ts_pkgname VERSION )
        fi
        new_version=$( /usr/bin/pkgparam -d $l_mws_sfs_ts_pkg_path $l_sfs_ts_pkgname VERSION )

        if [ "$new_version" = "$existing_version" ]; then
                echo "Not upgrading $l_sfs_ts_pkgname on $(hostname) since existing version is same as new version on MWS - $existing_version"
        else
                /bin/pkginfo | grep -w $l_sfs_ts_pkgname > /dev/null && {
                        echo "Removing existing SFS_TS package $l_sfs_ts_pkgname on $(hostname)"
                        /usr/sbin/pkgrm -n -a $l_local_pkg_adm_path $l_sfs_ts_pkgname > /dev/null || {
                                echo "Error - failed to remove l_sfs_ts_pkgname on $(hostname)"
                                umount /tmp/sfs_ts$$
                                /bin/rm -rf /tmp/sfs_ts$$
                                return 1
                        }
                }
                # add new package
                echo "Installing new package version $new_version on $(hostname)"
                /usr/sbin/pkgadd -n -a $l_local_pkg_adm_path -d $l_mws_sfs_ts_pkg_path all > /dev/null || {
                        echo "Failed to install new package"
                        umount /tmp/sfs_ts$$
                        /bin/rm -rf /tmp/sfs_ts$$
                        return 1
                }
        fi

        # admin 2 - we just upgrade package
	if [ $CI_ADMIN2_HOSTNAME  != NO ]; then
       	 echo "** Checking SFS_TS package on $CI_ADMIN2_HOSTNAME **"
       	 $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME} /bin/pkginfo $l_sfs_ts_pkgname" $l_admin2_pass > /dev/null &&
       	 $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME} /bin/rm -f /tmp/sfs_ts_pkg_version" $l_admin2_pass > /dev/null &&
       	 $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME} /usr/bin/pkgparam $l_sfs_ts_pkgname VERSION > /tmp/sfs_ts_pkg_version" $l_admin2_pass > /dev/null &&
       	 $EXPECT $AT_BIN/ssh_setup2.sh scp "root@${CI_ADMIN2_HOSTNAME}:/tmp/sfs_ts_pkg_version  /tmp" $l_admin2_pass > /dev/null &&
       	 if [ -s /tmp/sfs_ts_pkg_version ]; then
                existing_admin2_version=$( cat /tmp/sfs_ts_pkg_version )
        else
                existing_admin2_version=
        fi
if [ "$new_version" = "$existing_admin2_version" ]; then
                echo "Not upgrading $l_sfs_ts_pkgname on $CI_ADMIN2_HOSTNAME since existing version is same as new version on MWS - $existing_admin2_version"
        else 
                $EXPECT $AT_BIN/ssh_setup2.sh scp "$l_local_pkg_adm_path $l_mws_sfs_ts_pkg_path root@${CI_ADMIN2_HOSTNAME}:/var/tmp" $l_admin2_pass > /dev/null || {
                        echo "Error - failed to copy SFS_TS package to admin2"
                        umount /tmp/sfs_ts$$
                        /bin/rm -rf /tmp/sfs_ts$$
                        return 1
                }
                $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME} /bin/pkginfo | grep -w $l_sfs_ts_pkgname" $l_admin2_pass > /dev/null && {
                        echo "Removing existing SFS_TS package $l_sfs_ts_pkgname"
                        $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME} /usr/sbin/pkgrm -n -a /var/tmp/$l_sfs_ts_pkg_adm $l_sfs_ts_pkgname" $l_admin2_pass > /dev/null || {
                                echo "Error - failed to remove l_sfs_ts_pkgname on $CI_ADMIN2_HOSTNAME"
                                umount /tmp/sfs_ts$$
                                /bin/rm -rf /tmp/sfs_ts$$
                                return 1
                        }
                }
                # add new package
                echo "Installing new package version $new_version on $CI_ADMIN2_HOSTNAME"
                $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN2_HOSTNAME} /usr/sbin/pkgadd -n -a /var/tmp/$l_sfs_ts_pkg_adm -d /var/tmp/$l_sfs_ts_pkgfilename all" $l_admin2_pass > /dev/null || {
                        echo "Failed to install new package on $CI_ADMIN2_HOSTNAME"
                        return 1
                }
        fi
	fi
        
        umount /tmp/sfs_ts$$
        /bin/rm -rf /tmp/sfs_ts$$
        return 0
        
}

add_sfs_ts_client() {
echo "Admin Server is ${CI_SERVER_ADMIN} "
echo "Solaris Client is ${CI_SERVER_HOSTNAME} ${CI_SERVER_IP}"
$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_SERVER_ADMIN} /opt/ericsson/ddc/bin/installRemote.ts -t OTHER -h ${CI_SERVER_IP}" ${CI_SERVER_ROOTPW} || {
        echo "Failed to set-up ${CI_SERVER_HOSTNAME}"
        return 1
        }

}

update_install_remote() {

#Confirm installRemote script exists

if [ -f /opt/ericsson/ddc/bin/installRemote ]; then
	echo -e "Edit installRemote"
	${SED} -e 's/^request_password/#request_password/g' /opt/ericsson/ddc/bin/installRemote > /tmp/installRemote.1 
	${SED} -e 's/${PASSWD}/shroot/g' /tmp/installRemote.1 > /tmp/installRemote.2
	echo -e "Copy Updated installRemote to installRemote.ts"
	/usr/bin/cp /tmp/installRemote.2 /opt/ericsson/ddc/bin/installRemote.ts
	if [ $? -eq 0 ]; then
		echo -e "Copy Succesfull"
	else
		echo -e "Copy Failed"
		return 1
	fi
	#Set copied file to executable
	/usr/bin/chmod 555 /opt/ericsson/ddc/bin/installRemote.ts	
	if [ $? -eq 0 ]; then
                echo -e "File executable"
        else
                return 1
        fi


		
else
	echo -e "ERROR: installRemote script does not exist."
	return 1
fi
}


#
# Function to check for successful application of Solaris patches
#
# This function supports sparc and x86 initial install and upgrade
#
# All OSS and Eniq profiles are supported
#
#

check_solaris_patches() {
        local l_patchlogdir
        local l_om_media_path
        local l_om_media_loc
        local l_mws_ip
        local l_conf_dir
        local l_server_prof
        local l_context=$1 
	local l_installed_patches_version
	local l_media_patches_version
	local l_localcxp_kernel_version
	local l_mediacxp_kernel_version
	local l_system_kernel_version
	local l_arch=$( uname -p)
	local l_patchtypes
	local testfail=FALSE

	# this TC supports ii and ug contexts
	if [[ "$l_context" != II && "$l_context" != UG ]]; then
		echo "Error - unsupported context \"$l_content\""
		return 1
	fi

        # check system type
        if [ -d /ericsson/config ] ;then
                l_conf_dir="/ericsson/config"
        elif [ -d /eniq/installation/config ] ;then
                l_conf_dir="/eniq/installation/config"
        else
                echo "Error - unable to find config dir"
                return 1
        fi
        l_server_prof=$( cat $l_conf_dir/ericsson_use_config | awk -F= '{ print $2 }' )
        [ -z "$l_server_prof" ] && {
                echo "Error - unable to determine server profile"
                return 1
        }

	case "$l_server_prof" in
               	appserv|smrs_slave|om_sserv_master|om_serv_slave|infra_slave)
                       	l_patchtypes="SunOS"
                       	;;
               	stats)
                       	l_patchtypes="SunOS"
                       	;;
               	system)
                       	l_patchtypes="SunOS Veritas 3pp"
                       	;;
		*)
			echo "Warning - unexpected profile \"$l_server_prof\" - using default patch types "
                       	l_patchtypes="SunOS"
			;;
			
       	esac

        #l_om_media_loc=$( grep 'om_sw_locate=' $l_conf_dir/bootargs | awk -F= '{ print $2 }' )
        #l_mws_ip=$( echo $l_om_media_loc | awk -F'@' '{ print $1 }' )
	[ -z "$CI_TEAM" ] && {
		echo "Error - env var CI_TEAM not set"
		return 1
	}  
	[ -z "$CI_MWS_IP" ] && {
		echo "Error - env var CI_MWS_IP not set"
		return 1
	}  
	[ -z "$CI_FQ_SHIPMENT" ] && {
		echo "Error - env var CI_FQ_SHIPMENT not set"
		return 1
	}  
        l_om_media_path=/export/SW_LOCATION/OM_MEDIA/OSSRC_${CI_FQ_SHIPMENT}_${CI_TEAM}
        echo "OM media used in install: $l_om_media_path"
        # temporarily mount om media
        mkdir -p /tmp/om$$ || {
                echo "Error - failed to create tmp mount point for om media"
                return 1
        }
        mount $CI_MWS_IP:$l_om_media_path /tmp/om$$ || {
                echo "Error - failed to tmp mount om media"
                return 1
        }
        /bin/cp /tmp/om$$/om/Patches/cxp_info /tmp/cxp_info || {
                echo "Error - failed to copy patches cxp_info from om media"    
                return 1
        }
	for patchtype in $l_patchtypes; do
        	/bin/cp /tmp/om$$/om/Patches/$l_arch/$patchtype/patch_order /tmp/patch_order.${patchtype} || {
                	echo "Error - failed to copy $patchtype patches patch_order from om media"    
                	return 1
        	}
	done
        umount /tmp/om$$ || {
                echo "Error - failed to umount om media"
                return 1
        }

	l_system_kernel_version=$( uname -a | awk '{print $4}' | sed 's/Generic_//' )
	l_mediacxp_kernel_version=$( grep "$(uname -p)-kernel-patch" /tmp/cxp_info | awk -F= '{print $2}' )
	l_media_patches_version=$( grep 'VERSION=' /tmp/cxp_info | awk -F= '{ print $2 }' )

        if [  -s /.Patches/cxp_info ]; then
		l_localcxp_kernel_version=$( grep "$(uname -p)-kernel-patch" /.Patches/cxp_info | awk -F= '{print $2}' )
		l_installed_patches_version=$( grep 'VERSION=' /.Patches/cxp_info | awk -F= '{ print $2 }' )
        	cmp -s /.Patches/cxp_info /tmp/cxp_info || {
                	echo "Warning  - patches cxp_info on system differs from copy on OM media" 
		}
		if [ "$l_system_kernel_version" != "$l_localcxp_kernel_version" ]; then
			echo "Error -  system kernel version does not match local cxp_info \"$l_system_kernel_version\" vs \"$l_localcxp_kernel_version\""
			testfail=TRUE
		else
			echo "system kernel version matches local cxp_info \"$l_system_kernel_version\""
		fi  
		if [ "$l_mediacxp_kernel_version" != "$l_localcxp_kernel_version" ]; then
			echo "Error -  media cxp_info kernel version does not match local cxp_info \"$l_mediacxp_kernel_version\" vs \"$l_localcxp_kernel_version\""
			testfail=TRUE
		else
			echo "media cxp_info kernel version matches local cxp_info \"$l_mediacxp_kernel_version\""
		fi  
		if [ "$l_installed_patches_version" != "$l_media_patches_version" ]; then
			echo "Error - installed solaris patches version \"$l_installed_patches_version\" does not match media version \"$l_media_patches_version\""
			testfail=TRUE
		else
			echo "installed solaris patches version matches media version \"$l_media_patches_version\""
		fi
        fi

	if [ "$l_context" = II ]; then
		case "$l_server_prof" in
                	appserv|smrs_slave|om_serv_master|om_serv_slave|infra_slave)
                        	l_patchlogdir=/var/tmp/eric_bootstrap/log
                        	;;
                	stats)
                        	l_patchlogdir=/eniq/local_logs/installation
                        	;;
                	system)
                        	l_patchlogdir=/var/ericsson/core/log
                        	;;
			*)
				echo "Warning - unexpected profile \"$l_server_prof\" - using default patch log location"
                        	l_patchlogdir=/var/tmp/eric_bootstrap/log
				;;
				
        	esac
	else
		l_patchlogdir=/var/log/ericsson/SLU
		
	fi
	if [ ! -d "$l_patchlogdir" ]; then
		echo "Error - patch log dir $l_patchlogdir does not exist!"
		return 1
	fi
	echo "Checking for patch logs in $l_patchlogdir"
	if [ "$l_context" = II ]; then
		# checking for patches mentioned in logs not mentioned in patch order files
		echo "Checking patches mentioned in patch order file vs logs" 
		local l_cmp_patch_orderfile=/var/tmp/cmp_patch_order
		local l_logpatches=/var/tmp/logpatches
		/bin/rm -f $l_cmp_patch_orderfile $l_logpatches $l_cmp_patch_orderfile.2 $l_logpatches.2
		touch $l_cmp_patch_orderfile $l_logpatches
		for patchtype in $l_patchtypes; do
			awk -F: '{print $1}' /tmp/patch_order.$patchtype >> $l_cmp_patch_orderfile.2
		done
		sort $l_cmp_patch_orderfile.2 > $l_cmp_patch_orderfile 
		regexp1="([0-9]+){6}-([0-9]+){2}.*Validating patches"
		regexp2="([0-9]+){6}-([0-9]+){2}.*patch already applied"
		for file in $l_patchlogdir/*
		do
			while read line; do
				if [[ "$line" =~ $regexp1 ]] || [[ "$line" =~ $regexp2 ]]; then
					echo ${BASH_REMATCH[0]} | awk '{print $1}'  >> $l_logpatches.2
				fi
			done <<< "$( cat $file )"
		done
		sort -u $l_logpatches.2 > $l_logpatches
		cmp -s $l_cmp_patch_orderfile $l_logpatches || {
			echo "Error: the following patches are in patch order files but not mentioned in logs:"
			diff $l_cmp_patch_orderfile $l_logpatches | grep '<' | awk '{print $2}'
			echo "Error: the following patches are in the logs but are not in the patch order files:"
			diff $l_cmp_patch_orderfile $l_logpatches | grep '>' | awk '{print $2}'
			testfail=TRUE
		}
	fi

		

	# check for errors or failure messages in logs
	local l_exceptions="\
finished without errors\
|Error files directory does not exist\
|The script completed with no errors\
|returned no errors\
|If DBCC printed error messages\
|/etc/opt/ericsson/errorfiles>\
|will be uninterrupted or error free\
|Error parsing metadata repository\
|/ericsson/syb/bin/installjsdb_updater.sh returned no errors\
|Configuration Shared Memory Dumps for Error 839 - TR HR23995\
|There is already a condition of type error and value 839\
|/ossrc/3pp/var/opt/sybase/sybase/errorlogs\
|The configuration completed with no errors\
|default error log directory changed successfully to\
|fatal-error, notice, severe-error, severe-warning\
|/var/opt/ericsson/log/OpenDJ//error\
|: error\
|Java/Demo/Applet/rainbow/lmclient/ErrorHandler.class\
|Java/Demo/Applet/rainbow/lmclient/ErrorThread.class\
|Java/rainbow/lmclient/ErrorHandler.class\
|Java/rainbow/lmclient/ErrorThread.class\
|Java delete file failed. Executing native rm\
|busyhourcfg web.xml not found, no merge done\
|Unable to determine boot environment name from description provided\
|Manuals/SysAdminHelp/man_files/Setting_Error_Logging.htm\
|\[AdmNode=Ericsson,AdmHost=masterservice,ManagedComponentpms_seg=pms_seg\] not found\
|Failed to patch Live Upgrade on BE\
|Please see ERRORS in metainit\(1M\) for additional information\
"
	local l_known_errors="\
Sybase Bug CR648848 - TR HN81412\
|/lib/postrun:  not found\
"


	echo "Checking patch logs for errors.."
	StringSearch -d $l_patchlogdir  -s 'error|fail|not found' -e "${l_exceptions}" -w "${l_known_errors}" > /dev/null || testfail=TRUE  
	if [ -n "$ERRORS" ]; then
		banner "NEW ERRS"
		echo -e "$ERRORS"
	fi 
	if [ -n "$WARNINGS" ]; then
		banner "KNOWN ERRS"
		echo -e "$WARNINGS"
	fi 

	if [ "$testfail" = TRUE ]; then
		return 1
	else
		return 0
	fi
}


# function to add Server for full CO  TC as  client on MWS
# for now assumption is that Admin2 has been upgraded node and Admin1
# needs to be reinstalled. 
# eolikil 03/08/14

X86II_add_mws_admin2_dhcp_client_fullCO () {
        SERVER=$CI_ADMIN1_HOSTNAME
        get_server_details $SERVER || {
                error "Unable to get $SERVER  details" "CI config issue"
                return 1
        }
        macaddr=${_SERVER_DETAILS[2]}
        ip_addr=${_SERVER_DETAILS[1]}
        ipv6_addr=${_SERVER_DETAILS[10]}
        march=${_SERVER_DETAILS[3]}
        server_vendor=${_SERVER_DETAILS[5]}
        netmask=${_SERVER_DETAILS[14]}
        # if netmask is not in env file, try pre-ini file
        [ -z "$netmask" ] && {
                get_preini_param $CI_ADMIN1_HOSTNAME pubNETMM netmask
        }
        X86II_create_dhcp_client_file $SERVER $ip_addr $netmask $macaddr $server_vendor "inst_type=ossrc bmr_inst rmirr" ||
return 1

}
	

#
# Function to jumpstart non upgraded  admin server for full CO 
# for now assumption is that Admin2 has been upgraded node and Admin1
# needs to be reinstalled.
# eolikil 03/08/14

#
X86II_admin2_jump_fullCO() {

SERVER=$CI_ADMIN1_HOSTNAME

        [ -n "$CI_DEBUG_SKIP_JUMP_RETURN_CODE" ] && {
                echo "*debug* - exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE"
                [ $CI_DEBUG_SKIP_JUMP_RETURN_CODE -eq 1 ] && error "exiting $FUNCNAME with code $CI_DEBUG_SKIP_JUMP_RETURN_CODE" "debug exit"
                return $CI_DEBUG_SKIP_JUMP_RETURN_CODE
        }
        get_server_details $SERVER
        if [ $? -ne "0" ]; then
                error "$SERVER Configuration not found.. Unable to continue jumpstart.." "CI config issue"
                return 1
        fi
        ilo_ip=${_SERVER_DETAILS[4]}
        if [ -z "$ilo_ip" ]; then
                error "Unable to determine ILO IP of server $SERVER" "CI config issue"
                return 1
        fi
        ipmitoolboot=false
        if [ "$CI_IPMITOOL_PXEBOOT" = TRUE ]; then
                X86_install_ipmi_pxeboot $SERVER || {
                error "Problem occured trying to pxe-boot $SERVER using ipmitool" "CI config issue"
                return 1
                }
                ipmitoolboot=true
        fi

        $EXPECT $AT_LIB/exp_files/jumpit_admin2.exp $SERVER $ilo_ip $ipmitoolboot | tee -a $LOGDIR/$INSTALL [ ${PIPESTATUS[0]} -ne 0 ] && {
                error "Jumpstart of $SERVER failed" "jumpstart failure"
                return 1
        }
        return 0
}


switchGroup_Oss() {
        #Switch Oss group over
        #$EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_SERVER_HOSTNAME[0]}.athtem.eei.ericsson.se " shroot
        #echo "Switching Oss group to Offline Node  ..."
        #switchGroup Oss || {
        #err_msg "ERROR: Switching Oss group failed!" $LINENO $FUNCNAME $?
        #        return 1
        #        }
        #echo "...Oss group switch completed."
        #return 0
        $EXPECT $AT_BIN/ssh_setup2.sh scp "$AT_LIB/exp_files/switch_Ossgroup.bsh root@${CI_ADMIN1_HOSTNAME}.athtem.eei.ericsson.se:/tmp" shroot || {
                #> /dev/null 2>&1
                error "Failed to copy switch_Ossgroup.bsh  to admin1"
                return 1
                }


        $EXPECT $AT_BIN/ssh_setup2.sh ssh "root@${CI_ADMIN1_HOSTNAME}.athtem.eei.ericsson.se /tmp/switch_Ossgroup.bsh" shroot
        if [ $? -ne 0 ]; then
                echo "HA switch  Oss group  may have a problem"
        fi 
}



